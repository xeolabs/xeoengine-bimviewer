/*
 * xeoEngine V0.1.0
 *
 * A WebGL-based 3D visualization engine from xeoLabs
 * http://xeoengine.org/
 *
 * Built on 2016-01-29
 *
 * MIT License
 * Copyright 2016, Lindsay Kay
 * http://xeolabs.com/
 *
 */

/**
 The xeoEngine namespace.

 @class XEO
 @main XEO
 @static
 @author xeolabs / http://xeolabs.com/
 */
(function () {

    "use strict";

    var XEO = function () {

        /**
         * Semantic version number. The value for this is set by an expression that's concatenated to
         * the end of the built binary by the xeoEngine build script.
         * @property version
         * @namespace XEO
         * @type {String}
         */
        this.version = null;

        /**
         * Tracks statistics within xeoEngine, such as numbers of
         * scenes, textures, geometries etc.
         * @final
         * @property stats
         * @type {*}
         * @final
         */
        this.stats = {
            build: {
                version: XEO.version
            },
            client: {
                browser: (navigator && navigator.userAgent) ? navigator.userAgent : "n/a"
            },

            // TODO: replace 'canvas' with 'pixels'
            //canvas: {
            //    width: 0,
            //    height: 0
            //},
            components: {
                scenes: 0,
                entities: 0
            },
            memory: {

                // Note that these counts will include any positions, colors,
                // normals and indices that xeoEngine internally creates on-demand
                // to support color-index triangle picking.

                meshes: 0,
                positions: 0,
                colors: 0,
                normals: 0,
                tangents: 0,
                uvs: 0,
                indices: 0,
                textures: 0,
                programs: 0
            },
            frame: {
                frameCount: 0,
                fps: 0,
                useProgram: 0,
                setUniform: 0,
                setUniformCacheHits: 0,
                bindTexture: 0,
                bindArray: 0,
                drawElements: 0,
                drawChunks: 0
            }
        };

        // Ensures unique scene IDs
        // Lazy-instantiated because its class is on the
        // namespace of this object, and so won't be defined yet
        this._sceneIDMap = null;

        // Default singleton Scene, lazy-initialized in getter
        this._scene = null;

        /**
         * Existing  {{#crossLink "Scene"}}Scene{{/crossLink}}s , mapped to their IDs
         * @property scenes
         * @namespace XEO
         * @type {{String:XEO.Scene}}
         */
        this.scenes = {};

        // Task queue, which is pumped on each frame;
        // tasks are pushed to it with calls to XEO.schedule

        this._taskQueue = [];

        //-----------------------------------------------------------------------
        // Game loop
        //
        // https://developer.mozilla.org/en-US/docs/Games/Anatomy
        //
        // http://gameprogrammingpatterns.com/game-loop.html
        //-----------------------------------------------------------------------

        var self = this;

        (function () {

            var tickEvent = {
                sceneId: null,
                time: null,
                startTime: null,
                prevTime: null,
                deltaTime: null
            };

            // Hoisted vars

            var taskBudget = 8; // How long we're allowed to spend on tasks in each frame
            var frameTime;
            var lastFrameTime = 0;
            var elapsedFrameTime;
            var newFPS;
            var fpsSamples = [];
            var numFPSSamples = 30;
            var totalFPS = 0;
            var updateTime;
            var lastUpdateTime = 0;
            var id;
            var scene;

            var frame = function () {

                frameTime = Date.now();

                // Moving average of FPS

                if (lastFrameTime > 0) {
                    elapsedFrameTime = frameTime - lastFrameTime;
                    newFPS = 1000 / elapsedFrameTime;
                    totalFPS += newFPS;
                    fpsSamples.push(newFPS);
                    if (fpsSamples.length >= numFPSSamples) {
                        totalFPS -= fpsSamples.shift();
                    }
                    self.stats.frame.fps = Math.round(totalFPS / fpsSamples.length);

                }

                update();

                render();

                lastFrameTime = frameTime;

                window.requestAnimationFrame(frame);
            };


            function update() {

                updateTime = Date.now();

                lastUpdateTime = updateTime;

                // Process as many enqueued tasks as we can
                // within the per-frame task budget

                self._runScheduledTasks(updateTime + taskBudget);

                tickEvent.time = updateTime;

                // Fire a "tick" event at the scene, which will in turn cause
                // all sorts of scene components to schedule more tasks

                for (id in self.scenes) {
                    if (self.scenes.hasOwnProperty(id)) {

                        scene = self.scenes[id];

                        // Fire the tick event at the scene

                        tickEvent.sceneId = id;
                        tickEvent.startTime = scene.startTime;
                        tickEvent.deltaTime = tickEvent.prevTime != null ? tickEvent.time - tickEvent.prevTime : 0;

                        scene.fire("tick", tickEvent, true);
                    }
                }

                tickEvent.prevTime = updateTime;
            }

            function render() {
                for (id in self.scenes) {
                    if (self.scenes.hasOwnProperty(id)) {
                        self.scenes[id]._compile(); // Render, maybe rebuild draw list first
                    }
                }
            }

            window.requestAnimationFrame(frame);

        })();
    };

    XEO.prototype = {

        constructor: XEO,

        /**
         The default {{#crossLink "Scene"}}Scene{{/crossLink}}.

         Components created without an explicit parent {{#crossLink "Scene"}}Scene{{/crossLink}} will be created within this
         {{#crossLink "Scene"}}Scene{{/crossLink}} by default.

         xeoEngine creates the default {{#crossLink "Scene"}}Scene{{/crossLink}} as soon as you either
         reference this property for the first time, or create your first {{#crossLink "Entity"}}Entity{{/crossLink}} without
         a specified {{#crossLink "Scene"}}Scene{{/crossLink}}.

         @property scene
         @namespace XEO
         @final
         @type Scene
         */
        get scene() {

            // XEO.Scene constructor will call this._addScene
            // to register itself on XEO

            return this._scene || (this._scene = new window.XEO.Scene({
                    id: "default.scene"
                }));
        },

        /**
         * Registers a scene on xeoEngine.
         * This is called within the XEO.Scene constructor.
         *
         * @method _addScene
         * @param {Scene} scene The scene
         * @private
         */
        _addScene: function (scene) {

            this._sceneIDMap = this._sceneIDMap || new window.XEO.utils.Map();

            if (scene.id) {

                // User-supplied ID

                if (this.scenes[scene.id]) {
                    console.error("[ERROR] Scene " + XEO._inQuotes(scene.id) + " already exists");
                    return;
                }

            } else {

                // Auto-generated ID

                scene.id = this._sceneIDMap.addItem(scene);
            }

            this.scenes[scene.id] = scene;

            var self = this;

            // Unregister destroyed scenes

            scene.on("destroyed",
                function () {

                    self._sceneIDMap.removeItem(scene.id);

                    delete self.scenes[scene.id];
                });
        },

        /**
         * Schedule a task for xeoEngine to run at the next frame.
         *
         * Internally, this pushes the task to a FIFO queue. Within each frame interval, xeoEngine processes the queue
         * for a certain period of time, popping tasks and running them. After each frame interval, tasks that did not
         * get a chance to run during the task are left in the queue to be run next time.
         *
         * @method schedule
         * @param {Function} callback Callback that runs the task.
         * @param {Object} [scope] Scope for the callback.
         */
        scheduleTask: function (callback, scope) {
            this._taskQueue.push(callback);
            this._taskQueue.push(scope);
        },

        // Pops and propcesses tasks in the queue, until the
        // given number of milliseconds has elapsed.
        _runScheduledTasks: function (until) {

            var time = (new Date()).getTime();
            var taskQueue = this._taskQueue;
            var callback;
            var scope;

            while (taskQueue.length > 0 && time < until) {
                callback = taskQueue.shift();
                scope = taskQueue.shift();
                if (scope) {
                    callback.call(scope);
                } else {
                    callback();
                }
                time = (new Date()).getTime();
            }
        },

        /**
         * Destroys all user-created {{#crossLink "Scene"}}Scenes{{/crossLink}} and
         * clears the default {{#crossLink "Scene"}}Scene{{/crossLink}}.
         *
         * @method clear
         * @demo foo
         */
        clear: function () {

            var scene;

            for (var id in this.scenes) {
                if (this.scenes.hasOwnProperty(id)) {

                    scene = this.scenes[id];

                    // Only clear the default Scene
                    // but destroy all the others

                    if (id === "default.scene") {
                        scene.clear();
                    } else {
                        scene.destroy();
                    }
                }
            }
            this.scenes = {};
        },

        /**
         * Tests if the given object is an array
         * @private
         */
        _isArray: function (testEntity) {
            return testEntity && !(testEntity.propertyIsEnumerable('length')) && typeof testEntity === 'object' && typeof testEntity.length === 'number';
        },

        /**
         * Tests if the given value is a string
         * @param value
         * @returns {boolean}
         * @private
         */
        _isString: function (value) {
            return (typeof value === 'string' || value instanceof String);
        },


        /**
         * Tests if the given value is a number
         * @param value
         * @returns {boolean}
         * @private
         */
        _isNumeric: function (value) {
            return !isNaN(parseFloat(value)) && isFinite(value);
        },

        /** Returns a shallow copy
         */
        _copy: function (o) {
            return this._apply(o, {});
        },

        /** Add properties of o to o2, overwriting them on o2 if already there
         */
        _apply: function (o, o2) {
            for (var name in o) {
                if (o.hasOwnProperty(name)) {
                    o2[name] = o[name];
                }
            }
            return o2;
        },

        /**
         * Add non-null/defined properties of o to o2
         * @private
         */
        _apply2: function (o, o2) {
            for (var name in o) {
                if (o.hasOwnProperty(name)) {
                    if (o[name] !== undefined && o[name] !== null) {
                        o2[name] = o[name];
                    }
                }
            }
            return o2;
        },

        /**
         * Add properties of o to o2 where undefined or null on o2
         * @private
         */
        _applyIf: function (o, o2) {
            for (var name in o) {
                if (o.hasOwnProperty(name)) {
                    if (o2[name] === undefined || o2[name] === null) {
                        o2[name] = o[name];
                    }
                }
            }
            return o2;
        },

        /**
         * Returns true if the given map is empty.
         * @param obj
         * @returns {boolean}
         * @private
         */
        _isEmptyObject: function (obj) {
            for (var name in obj) {
                if (obj.hasOwnProperty(name)) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Returns the given ID as a string, in quotes if the ID was a string to begin with.
         *
         * This is useful for logging IDs.
         *
         * @param {Number| String} id The ID
         * @returns {String}
         * @private
         */
        _inQuotes: function (id) {
            return this._isNumeric(id) ? ("" + id) : ("'" + id + "'");
        }
    };

    // Have a lower-case XEO namespace as well,
    // just because it's easier to type when live-coding

    window.XEO = window.XEO = new XEO();

})
();
;/*
 Based on Simple JavaScript Inheritance
 By John Resig http://ejohn.org/
 MIT Licensed.
 */
// Inspired by base2 and Prototype
(function () {

    var initializing = false;

    var fnTest = /xyz/.test(function () { xyz; }) ? /\b_super\b/ : /.*/;

    // The base Class implementation (does nothing)
    this.Class = function () {
    };

    // Create a new Class that inherits from this class
    Class.extend = function (prop) {

        var _super = this.prototype;

        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var prototype = new this();
        initializing = false;

        // Copy the properties over onto the new prototype
        for (var name in prop) {

            //
            if (name === "_props") {
                var props = prop[name];
                var descriptor;
                for (var key in props) {
                    descriptor = props[key];

                    // If no setter is provided, then the property
                    // is strictly read-only. Insert a dummy setter
                    // to log a warning.

                    if (!descriptor.set) {
                        (function () {

                            var name = key;

                            descriptor.set = function () {
                                this.warn("Property '" + name + "' is read-only, ignoring assignment");
                            };
                        })();
                    }


                    // Want property to show up in inspectors
                    descriptor.enumerable = true;

                    Object.defineProperty(prototype, key, descriptor);
                }
                continue;
            }

            // Check if we're overwriting an existing function
            prototype[name] = typeof prop[name] === "function" && typeof _super[name] === "function" && fnTest.test(prop[name]) ?
                (function (name, fn) {
                    return function () {
                        var tmp = this._super;

                        // Add a new ._super() method that is the same method
                        // but on the super-class
                        this._super = _super[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                })(name, prop[name]) : prop[name];
        }

        // The dummy class constructor
        function Class() {

            // All construction is actually done in the init method
            if (!initializing && this.__init)
                this.__init.apply(this, arguments);
        }

        // Populate our constructed prototype object
        Class.prototype = prototype;

        // Enforce the constructor to be what we expect
        Class.prototype.constructor = Class;

        // And make this class extendable
        Class.extend = arguments.callee;

        return Class;
    };
})();

;(function () {

    "use strict";

    XEO.utils = XEO.utils || {};

    /**
     * Generic map of IDs to items - can generate own IDs or accept given IDs. IDs should be strings in order to not
     * clash with internally generated IDs, which are numbers.
     */
    XEO.utils.Map = function (items, baseId) {

        /**
         * Items in this map
         */
        this.items = items || [];

        baseId = baseId || 0;
        var lastUniqueId = baseId + 1;

        /**
         * Adds an item to the map and returns the ID of the item in the map. If an ID is given, the item is
         * mapped to that ID. Otherwise, the map automatically generates the ID and maps to that.
         *
         * id = myMap.addItem("foo") // ID internally generated
         *
         * id = myMap.addItem("foo", "bar") // ID is "foo"
         *
         */
        this.addItem = function () {
            var item;
            if (arguments.length === 2) {
                var id = arguments[0];
                item = arguments[1];
                if (this.items[id]) { // Won't happen if given ID is string
                    throw "ID clash: '" + id + "'";
                }
                this.items[id] = item;
                return id;

            } else {
                while (true) {
                    item = arguments[0] || {};
                    var findId = lastUniqueId++;
                    if (!this.items[findId]) {
                        this.items[findId] = item;
                        return findId;
                    }
                }
            }
        };

        /**
         * Removes the item of the given ID from the map and returns it
         */
        this.removeItem = function (id) {
            var item = this.items[id];
            delete this.items[id];
            return item;
        };
    };

})();
;(function () {

    "use strict";

    XEO.renderer = XEO.renderer || {};

    /**
     *  Renderer compiled from a {@link SceneJS.Scene}, providing methods to render and pick.
     *
     * <p>A Renderer is a container of {@link XEO.renderer.Object}s which are created (or updated) by a depth-first
     * <b>compilation traversal</b> of a {@link SceneJS.Scene}.</b>
     *
     * <h2>Rendering Pipeline</h2>
     *
     * <p>Conceptually, a Renderer implements a pipeline with the following stages:</p>
     *
     * <ol>
     * <li>Create or update {@link XEO.renderer.Object}s during scene compilation</li>
     * <li>Organise the {@link XEO.renderer.Object} into an <b>object list</b></li>
     * <li>Determine the GL state sort order for the object list</li>
     * <li>State sort the object list</li>
     * <li>Create a <b>draw list</b> containing {@link XEO.renderer.Chunk}s belonging to the {@link XEO.renderer.Object}s in the object list</li>
     * <li>Render the draw list to draw the image</li>
     * </ol>
     *
     * <p>An update to the scene causes the pipeline to be re-executed from one of these stages, and SceneJS is designed
     * so that the pipeline is always re-executed from the latest stage possible to avoid redoing work.</p>
     *
     * <p>For example:</p>
     *
     * <ul>
     * <li>when an object is created or updated, we need to (re)do stages 2, 3, 4, 5 and 6</li>
     * <li>when an object is made invisible, we need to redo stages 5 and 6</li>
     * <li>when an object is assigned to a different scene render layer (works like a render bin), we need to redo
     *   stages 3, 4, 5, and 6</li>
     *<li>when the colour of an object changes, or maybe when the viewpoint changes, we simplt redo stage 6</li>
     * </ul>
     *
     * <h2>Object Creation</h2>
     * <p>The object soup (stage 1) is constructed by a depth-first traversal of the scene graph, which we think of as
     * "compiling" the scene graph into the Renderer. As traversal visits each scene component, the component's state core is
     * set on the Renderer (such as {@link #flags}, {@link #layer}, {@link #renderer} etc), which we think of as the
     * cores that are active at that instant during compilation. Each of the scene's leaf components is always
     * a {@link SceneJS.Geometry}, and when traversal visits one of those it calls {@link #buildObject} to create an
     * object in the soup. For each of the currently active cores, the object is given a {@link XEO.renderer.Chunk}
     * containing the WebGL calls for rendering it.</p>
     *
     * <p>The object also gets a shader (implemented by {@link XEO.renderer.Program}), taylored to render those state cores.</p>
     *
     * <p>Limited re-compilation may also be done on portions of a scene that have been added or sufficiently modified. When
     * traversal visits a {@link SceneJS.Geometry} for which an object already exists in the display, {@link #buildObject}
     * may update the {@link XEO.renderer.Chunk}s on the object as required for any changes in the core soup since the
     * last time the object was built. If differences among the cores require it, then {@link #buildObject} may also replace
     * the object's {@link XEO.renderer.Program} in order to render the new core soup configuration.</p>
     *
     * <p>So in summary, to each {@link XEO.renderer.Object} it builds, {@link #buildObject} creates a list of
     * {@link XEO.renderer.Chunk}s to render the set of component state cores that are currently set on the {@link XEO.Renderer}.
     * When {@link #buildObject} is re-building an existing object, it may replace one or more {@link XEO.renderer.Chunk}s
     * for state cores that have changed from the last time the object was built or re-built.</p>

     * <h2>Object Destruction</h2>
     * <p>Destruction of a scene graph branch simply involves a call to {@link #removeObject} for each {@link SceneJS.Geometry}
     * in the branch.</p>
     *
     * <h2>Draw List</h2>
     * <p>The draw list is actually comprised of two lists of state chunks: a "pick" list to render a pick buffer
     * for colour-indexed GPU picking, along with a "draw" list for normal image rendering. The chunks in these lists
     * are held in the state-sorted order of their objects in #_objectList, with runs of duplicate states removed.</p>
     *
     * <p>After a scene update, we set a flag on the display to indicate the stage we will need to redo from. The pipeline is
     * then lazy-redone on the next call to #render or #pick.</p>
     */
    XEO.renderer.Renderer = function (stats, cfg) {

        // Collects runtime statistics
        this.stats = stats || {};

        // Renderer is bound to the lifetime of an HTML5 canvas
        this._canvas = cfg.canvas;

        // Factory which creates and recycles XEO.renderer.Program instances
        this._programFactory = new XEO.renderer.ProgramFactory(this.stats, {
            canvas: cfg.canvas
        });

        // Factory which creates and recycles XEO.renderer.Object instances
        this._objectFactory = new XEO.renderer.ObjectFactory();

        // Factory which creates and recycles XEO.renderer.Chunk instances
        this._chunkFactory = new XEO.renderer.ChunkFactory();

        // State chunks that are dynamically inserted by the renderer
        this._extraChunks = [];
        this._numExtraChunks = 0;

        /**
         * Indicates if the canvas is transparent
         * @type {boolean}
         */
        this.transparent = cfg.transparent === true;

        // The objects in the render
        this.objects = {};

        // Ambient color
        this._ambient = null;

        // The object list, containing all elements of #objects, kept in GL state-sorted order
        this._objectList = [];
        this._objectListLen = 0;

        // The "draw list", comprised collectively of three lists of state chunks belong to visible objects
        // within #_objectList: a "pick" list to render a pick buffer for colour-indexed GPU picking, along with an
        // "draw" list for normal image rendering.  The chunks in these lists are held in the state-sorted order of
        // their objects in #_objectList, with runs of duplicate states removed.

        this._objectPickList = [];
        this._objectPickListLen = 0;

        this._drawChunkList = [];      // State chunk list to render all objects
        this._drawChunkListLen = 0;

        this._pickObjectChunkList = [];  // State chunk list to render scene to pick buffer
        this._pickObjectChunkListLen = 0;


        // The frame context holds state shared across a single render of the
        // draw list, along with any results of the render, such as pick hits
        this._frameCtx = {
            pickObjects: [], // Pick names of objects hit during pick render
            canvas: this._canvas
        };

        //----------------- Render states --------------------------------------

        /**
         Visibility render state.
         @property visibility
         @type {renderer.Visibility}
         */
        this.visibility = null;

        /**
         Modes render state.
         @property modes
         @type {renderer.Modes}
         */
        this.modes = null;

        /**
         Render state for an effects layer.
         @property layer
         @type {renderer.Layer}
         */
        this.layer = null;

        /**
         Render state for an effects pipeline stage.
         @property stage
         @type {renderer.Layer}
         */
        this.stage = null;

        /**
         Depth buffer render state.
         @property depthBuf
         @type {renderer.DepthBuf}
         */
        this.depthBuf = null;

        /**
         Color buffer render state.
         @property colorBuf
         @type {renderer.ColorBuf}
         */
        this.colorBuf = null;

        /**
         Lights render state.
         @property lights
         @type {renderer.Lights}
         */
        this.lights = null;

        /**
         Material render state.
         @property material
         @type {renderer.Material}
         */
        this.material = null;

        /**
         Environmental reflection render state.
         @property reflection
         @type {renderer.Reflect}
         */
        this.reflect = null;

        /**
         Modelling transform render state.
         @property modelTransform
         @type {renderer.ModelTransform}
         */
        this.modelTransform = null;

        /**
         View transform render state.
         @property viewTransform
         @type {renderer.ViewTransform}
         */
        this.viewTransform = null;

        /**
         Projection transform render state.
         @property projTransform
         @type {renderer.ProjTransform}
         */
        this.projTransform = null;

        /**
         Billboard render state.
         @property billboard
         @type {renderer.Billboard}
         */
        this.billboard = null;

        /**
         Stationary render state.
         @property stationary
         @type {renderer.Stationary}
         */
        this.stationary = null;

        /**
         Color target render state.
         @property colorTarget
         @type {renderer.RenderTarget}
         */
        this.colorTarget = null;

        /**
         Depth target render state.
         @property depthTarget
         @type {renderer.RenderTarget}
         */
        this.depthTarget = null;

        /**
         Cross-section planes render state.
         @property clips
         @type {renderer.Clips}
         */
        this.clips = null;

        /**
         Morph targets render state.
         @property morphTargets
         @type {renderer.MorphTargets}
         */
        this.morphTargets = null;

        /**
         Custom shader render state.
         @property shader
         @type {renderer.Shader}
         */
        this.shader = null;

        /**
         Render state providing custom shader params.
         @property shaderParams
         @type {renderer.Shader}
         */
        this.shaderParams = null;

        /**
         Geometry render state.
         @property geometry
         @type {renderer.Geometry}
         */
        this.geometry = null;


        //----------------- Renderer dirty flags -------------------------------

        /**
         * Flags the object list as needing to be rebuilt from renderer objects
         * on the next call to {@link #render} or {@link #pick}. Setting this
         * will cause the rendering pipeline to be executed from stage #2
         * (see class comment), causing object list rebuild, state order
         * determination, state sort, draw list construction and image render.
         * @type Boolean
         */
        this.objectListDirty = true;

        /**
         * Flags the object list as needing state orders to be (re)computed on the
         * next call to {@link #render} or {@link #pick}. Setting this will cause
         * the rendering pipeline to be executed from stage #3 (see class comment),
         * causing state order determination, state sort, draw list construction
         * and image render.
         * @type Boolean
         */
        this.stateOrderDirty = true;

        /**
         * Flags the object list as needing to be state-sorted on the next call
         * to {@link #render} or {@link #pick}.Setting this will cause the
         * rendering pipeline to be executed from stage #4 (see class comment),
         * causing state sort, draw list construction and image render.
         * @type Boolean
         */
        this.stateSortDirty = true;

        /**
         * Flags the draw list as needing to be rebuilt from the object list on
         * the next call to {@link #render} or {@link #pick}.  Setting this will
         * cause the rendering pipeline to be executed from stage #5
         * (see class comment), causing draw list construction and image render.
         * @type Boolean
         */
        this.drawListDirty = true;

        /**
         * Flags the image as needing to be redrawn from the draw list on the
         * next call to {@link #render} or {@link #pick}. Setting this will
         * cause the rendering pipeline to be executed from stage #6
         * (see class comment), causing the image render.
         * @type Boolean
         */
        this.imageDirty = true;
    };

    /**
     * Reallocates WebGL resources for objects within this renderer.
     */
    XEO.renderer.Renderer.prototype.webglRestored = function () {

        // Re-allocate programs
        this._programFactory.webglRestored();

        // Re-bind chunks to the programs
        this._chunkFactory.webglRestored();

        var gl = this._canvas.gl;

        // Rebuild pick buffer

        if (this.pickBuf) {
            this.pickBuf.webglRestored(gl);
        }

        // Need redraw

        this.imageDirty = true;
    };

    /**
     * Internally creates (or updates) a {@link XEO.renderer.Object} of the given
     * ID from whatever component state cores are currently set on this {@link XEO.Renderer}.
     * The object is created if it does not already exist in the display, otherwise
     * it is updated with the current states, possibly replacing states already
     * referenced by the object.
     *
     * @param {String} objectId ID of object to create or update
     */
    XEO.renderer.Renderer.prototype.buildObject = function (objectId) {

        var object = this.objects[objectId];

        if (!object) {
            object = this._objectFactory.get(objectId);
        }

        // Attach to the object any states that we need to get off it later.
        // Most of these will be used when composing the object's shader.

        object.stage = this.stage;
        object.layer = this.layer;
        object.colorTarget = this.colorTarget;
        object.depthTarget = this.depthTarget;
        object.material = this.material;
        object.reflect = this.reflect;
        object.geometry = this.geometry;
        object.visibility = this.visibility;
        object.modes = this.modes;
        object.billboard = this.billboard;
        object.stationary = this.stationary;

        // Build hash of the object's state configuration. This is used
        // to hash the object's shader so that it may be reused by other
        // objects that have the same state configuration.

        var hash = ([

            // Make sure that every state type
            // with a hash is concatenated here

            this.geometry.hash,
            this.shader.hash,
            this.clips.hash,
            this.material.hash,
            //this.reflect.hash,
            this.lights.hash,
            this.billboard.hash,
            this.stationary.hash

        ]).join(";");

        if (!object.program || hash !== object.hash) {

            // Get new program for object if needed

            if (object.program) {
                this._programFactory.put(object.program);
            }

            object.program = this._programFactory.get(hash, this);

            object.hash = hash;
        }

        var programState = object.program;

        if (programState) {

            var program = programState.program;

            if (!program.allocated || !program.compiled || !program.validated || !program.linked) {

                if (this.objects[objectId]) {

                    // Don't keep faulty objects in the renderer
                    this.removeObject(objectId);
                }

                return {
                    error: true,
                    errorLog: program.errorLog
                }
            }
        }


        // Build sequence of draw chunks on the object

        // The order of some of these is important because some chunks will set
        // state on this._framectx to be consumed by other chunks downstream.

        this._setChunk(object, 0, "program", object.program); // Must be first
        this._setChunk(object, 1, "modelTransform", this.modelTransform);
        this._setChunk(object, 2, "viewTransform", this.viewTransform);
        this._setChunk(object, 3, "projTransform", this.projTransform);
        this._setChunk(object, 4, "modes", this.modes);
        this._setChunk(object, 5, "shader", this.shader);
        this._setChunk(object, 6, "shaderParams", this.shaderParams);
        this._setChunk(object, 7, "depthBuf", this.depthBuf);
        this._setChunk(object, 8, "colorBuf", this.colorBuf);
        this._setChunk(object, 9, "lights", this.lights);
        this._setChunk(object, 10, this.material.type, this.material); // Supports different material systems
        this._setChunk(object, 11, "clips", this.clips);
        this._setChunk(object, 12, "geometry", this.geometry);
        this._setChunk(object, 13, "draw", this.geometry, true); // Must be last

        if (!this.objects[objectId]) {

            this.objects[objectId] = object;

            this.objectListDirty = true;

        } else {

            // At the very least, the object sort order will need be recomputed

            this.stateOrderDirty = true;
        }

        return object;
    };

    /** Adds a render state chunk to a render graph object.
     */
    XEO.renderer.Renderer.prototype._setChunk = function (object, order, type, state, neg) {

        var id;

        var chunkType = this._chunkFactory.types[type];

        if (type === "program") {
            id = (object.program.id + 1) * 100000000;

        } else if (chunkType.constructor.prototype.programGlobal) {
            id = state.id;

        } else {
            id = ((object.program.id + 1) * 100000000) + ((state.id + 1));
        }

        if (neg) {
            id *= 100000;
        }

        var oldChunk = object.chunks[order];

        if (oldChunk) {
            this._chunkFactory.putChunk(oldChunk);
        }

        // Attach new chunk

        object.chunks[order] = this._chunkFactory.getChunk(id, type, object.program.program, state);

        // Ambient light is global across everything in display, and
        // can never be disabled, so grab it now because we want to
        // feed it to gl.clearColor before each display list render

        if (type === "lights") {
            this._setAmbient(state);
        }
    };

    // Sets the singular ambient light.
    XEO.renderer.Renderer.prototype._setAmbient = function (state) {

        var lights = state.lights;
        var light;
        var intensity;

        for (var i = 0, len = lights.length; i < len; i++) {

            light = lights[i];

            if (light.type === "ambient") {

                this._ambient = light;
            }
        }
    };

    /**
     * Removes an object from this Renderer
     *
     * @param {String} objectId ID of object to remove
     */
    XEO.renderer.Renderer.prototype.removeObject = function (objectId) {

        var object = this.objects[objectId];

        if (!object) {

            // Object not found
            return;
        }

        // Release draw chunks
        var chunks = object.chunks;
        for (var i = 0, len = chunks.length; i < len; i++) {
            this._chunkFactory.putChunk(chunks[i]);
        }

        // Release object's shader
        this._programFactory.put(object.program);

        object.program = null;
        object.hash = null;

        // Release object
        this._objectFactory.put(object);

        delete this.objects[objectId];

        // Need to repack object map into fast iteration list
        this.objectListDirty = true;
    };


    /**
     * Renders a new frame, if neccessary.
     */
    XEO.renderer.Renderer.prototype.render = function (params) {

        params = params || {};

        if (this.objectListDirty) {
            this._buildObjectList();        // Build the scene object list
            this.objectListDirty = false;
            this.stateOrderDirty = true;    // Now needs state ordering
        }

        if (this.stateOrderDirty) {
            this._makeStateSortKeys();      // Determine the state sort order
            this.stateOrderDirty = false;
            this.stateSortDirty = true;     // Now needs state sorting
        }

        if (this.stateSortDirty) {
            this._stateSort();              // State sort the scene object list
            this.stateSortDirty = false;
            this.drawListDirty = true;      // Now need to build object draw list
        }

        if (this.drawListDirty) {           // Build draw list from object list
            this._buildDrawList();
            this.imageDirty = true;         // Now need to render the draw list
        }

        if (this.imageDirty || params.force) {
            this._doDrawList({                  // Render the draw list
                clear: (params.clear !== false) // Clear buffers by default
            });
            this.stats.frame.frameCount++;
            this.imageDirty = false;
        }
    };

    /**
     * Builds the object list from the object map
     */
    XEO.renderer.Renderer.prototype._buildObjectList = function () {
        this._objectListLen = 0;
        for (var objectId in this.objects) {
            if (this.objects.hasOwnProperty(objectId)) {
                this._objectList[this._objectListLen++] = this.objects[objectId];
            }
        }
    };

    /**
     * Generates object state sort keys
     */
    XEO.renderer.Renderer.prototype._makeStateSortKeys = function () {
        var object;
        for (var i = 0, len = this._objectListLen; i < len; i++) {
            object = this._objectList[i];
            if (!object.program) { // Non-visual object (eg. sound)
                object.sortKey = -1;
            } else {
                object.sortKey =
                    ((object.stage.priority + 1) * 10000000000000000)
                    + ((object.modes.transparent ? 2 : 1) * 100000000000000)
                    + ((object.layer.priority + 1) * 10000000000000)
                    + ((object.program.id + 1) * 100000000)
                    + ((object.material.id + 1) * 10000)
                    + object.geometry.id;
            }
        }
    };

    /**
     * State-sorts the object list
     */
    XEO.renderer.Renderer.prototype._stateSort = function () {
        this._objectList.length = this._objectListLen;
        this._objectList.sort(function (a, b) {
            return a.sortKey - b.sortKey;
        });
    };

    /**
     * Logs the object list
     */
    XEO.renderer.Renderer.prototype._logObjectList = function () {
        console.log("--------------------------------------------------------------------------------------------------");
        console.log(this._objectListLen + " objects");
        for (var i = 0, len = this._objectListLen; i < len; i++) {
            var object = this._objectList[i];
            console.log("XEO.Renderer : object[" + i + "] sortKey = " + object.sortKey);
        }
        console.log("--------------------------------------------------------------------------------------------------");
    };

    /**
     * Builds the draw list, which is the list of draw state-chunks to apply to WebGL
     * to render the visible objects in the object list for the next frame.
     * Preserves the state sort order of the object list among the draw chunks.
     */
    XEO.renderer.Renderer.prototype._buildDrawList = function () {

        this._clearExtraChunks();

        this._lastDrawChunkId = this._lastDrawChunkId || [];
        this._lastPickObjectChunkId = this._lastPickObjectChunkId || [];

        for (var i = 0; i < 20; i++) {
            this._lastDrawChunkId[i] = null;
            this._lastPickObjectChunkId[i] = null;
        }

        this._drawChunkListLen = 0;
        this._pickObjectChunkListLen = 0;

        // For each render target, a list of objects to render to that target
        var targetObjectLists = {};

        // A list of all the render target object lists
        var targetListList = [];

        // List of all targets
        var targetList = [];

        var object;
        var colorRenderBuf;
        var depthRenderBuf;
        var target;
        var targetChunk;
        var list;
        var id;

        this._objectDrawList = this._objectDrawList || [];
        this._objectDrawListLen = 0;
        this._objectPickListLen = 0;

        for (var i = 0, len = this._objectListLen; i < len; i++) {

            object = this._objectList[i];

            // Cull invisible objects

            if (object.visibility.visible === false) {
                continue;
            }

            // Put objects with render targets into a bin for each target

            colorRenderBuf = object.colorTarget ? object.colorTarget.renderBuf : null;
            depthRenderBuf = object.depthTarget ? object.depthTarget.renderBuf : null;

            if (colorRenderBuf) {

                target = object.colorTarget;

                list = targetObjectLists[target.id];

                if (!list) {

                    list = [];

                    targetObjectLists[target.id] = list;

                    targetListList.push(list);

                    id = -this._numExtraChunks;

                    targetChunk = this._chunkFactory.getChunk(id, "renderTarget", object.program.program, target);

                    this._extraChunks[this._numExtraChunks++] = targetChunk;

                    targetList.push(targetChunk);
                }

                list.push(object);

            } else if (depthRenderBuf) {

                target = object.depthTarget;

                list = targetObjectLists[target.id];

                if (!list) {

                    list = [];

                    targetObjectLists[target.id] = list;

                    targetListList.push(list);

                    id = -this._numExtraChunks;

                    targetChunk = this._chunkFactory.getChunk(id, "renderTarget", object.program.program, target);

                    this._extraChunks[this._numExtraChunks++] = targetChunk;

                    targetList.push(targetChunk);
                }

                list.push(object);

            } else {

                // Put objects without render targets into their own list

                this._objectDrawList[this._objectDrawListLen++] = object;
            }
        }

        // Append chunks for objects within render targets first

        var pickable;
        var renderTargetBound = false;

        for (var i = 0, len = targetListList.length; i < len; i++) {

            targetChunk = targetList[i];
            list = targetListList[i];

            this._appendRenderTargetChunk(targetChunk);

            for (var j = 0, lenj = list.length; j < lenj; j++) {

                object = list[j];

                pickable = object.stage && object.stage.pickable; // We'll only pick objects in pickable stages

                this._appendObjectToDrawChunkLists(object, pickable);

                renderTargetBound = true;
            }
        }

        if (renderTargetBound) {

            // Unbinds any render target bound previously

            id = this._numExtraChunks * -1000.0;

            this._appendRenderTargetChunk(this._chunkFactory.getChunk(id, "renderTarget", object.program.program, {}));

            this._extraChunks[this._numExtraChunks++] = targetChunk;
        }

        // Append chunks for objects not in render targets

        for (var i = 0, len = this._objectDrawListLen; i < len; i++) {

            object = this._objectDrawList[i];

            pickable = !object.stage || (object.stage && object.stage.pickable); // Don't pick unpickable stages, ie. FX passes

            this._appendObjectToDrawChunkLists(object, pickable);
        }

        // Draw list is now up to date.

        this.drawListDirty = false;
    };

    XEO.renderer.Renderer.prototype._clearExtraChunks = function () {
        for (var i = 0, len = this._numExtraChunks; i < len; i++) {
            this._chunkFactory.putChunk(this._extraChunks[i]);
        }
        this._numExtraChunks = 0;
    };

    XEO.renderer.Renderer.prototype._appendRenderTargetChunk = function (chunk) {
        this._drawChunkList[this._drawChunkListLen++] = chunk;
    };

    /**
     * Appends an object to the draw and pick lists.
     * @param object
     * @param pickable
     * @private
     */
    XEO.renderer.Renderer.prototype._appendObjectToDrawChunkLists = function (object, pickable) {

        var chunks = object.chunks;
        var pickable = pickable && object.modes.pickable;
        var chunk;

        for (var i = 0, len = chunks.length; i < len; i++) {

            chunk = chunks[i];

            if (chunk) {

                // As we apply the state chunk lists we track the ID of most types
                // of chunk in order to cull redundant re-applications of runs
                // of the same chunk - except for those chunks with a 'unique' flag,
                // because we don't want to collapse runs of draw chunks because
                // they contain the GL drawElements calls which render the objects.

                if (chunk.draw) {

                    // Draw pass

                    if (chunk.unique || this._lastDrawChunkId[i] !== chunk.id) {

                        // Don't reapply repeated chunks

                        this._drawChunkList[this._drawChunkListLen++] = chunk;
                        this._lastDrawChunkId[i] = chunk.id;
                    }
                }

                if (chunk.pickObject) {

                    // Object-picking pass

                    if (pickable) {

                        // Don't pick unpickable objects

                        if (chunk.unique || this._lastPickObjectChunkId[i] !== chunk.id) {

                            // Don't reapply repeated chunks

                            this._pickObjectChunkList[this._pickObjectChunkListLen++] = chunk;
                            this._lastPickObjectChunkId[i] = chunk.id;
                        }
                    }
                }
            }
        }

        if (pickable) {
            this._objectPickList[this._objectPickListLen++] = object;
        }
    };

    /**
     * Logs the contents of the draw list to the console.
     *
     * @private
     */
    XEO.renderer.Renderer.prototype._logDrawList = function () {

        console.log("--------------------------------------------------------------------------------------------------");
        console.log(this._drawChunkListLen + " draw list chunks");

        for (var i = 0, len = this._drawChunkListLen; i < len; i++) {

            var chunk = this._drawChunkList[i];

            console.log("[chunk " + i + "] type = " + chunk.type);

            switch (chunk.type) {
                case "draw":
                    console.log("\n");
                    break;

                case "renderTarget":
                    console.log(" type = renderTarget");
                    break;
            }
        }

        console.log("--------------------------------------------------------------------------------------------------");
    };

    /**
     * Logs the contents of the pick list to the console.
     *
     * @private
     */
    XEO.renderer.Renderer.prototype._logPickList = function () {

        console.log("--------------------------------------------------------------------------------------------------");
        console.log(this._pickObjectChunkListLen + " pick list chunks");

        for (var i = 0, len = this._pickObjectChunkListLen; i < len; i++) {

            var chunk = this._pickObjectChunkList[i];

            console.log("[chunk " + i + "] type = " + chunk.type);

            switch (chunk.type) {
                case "draw":
                    console.log("\n");
                    break;
                case "renderTarget":
                    console.log(" type = renderTarget");
                    break;
            }
        }

        console.log("--------------------------------------------------------------------------------------------------");
    };

    /**
     * Attempts to pick an object at the given canvas coordinates.
     *
     * @param {*} params Picking params.
     * @returns {*} Hit result, if any.
     */
    XEO.renderer.Renderer.prototype.pick = function (params) {

        var gl = this._canvas.gl;

        var hit = null;

        var canvasX = params.canvasPos[0];
        var canvasY = params.canvasPos[1];

        var pickBuf = this.pickBuf;

        if (!pickBuf) {

            // Lazy-create the pick buffer

            pickBuf = new XEO.renderer.webgl.RenderBuffer({
                gl: this._canvas.gl,
                canvas: this._canvas.canvas
            });

            this.pickBuf = pickBuf;
        }

        // Do any pending render

        this.render();

        pickBuf.bind();

        pickBuf.clear();

        this._doDrawList({
            pickObject: true,
            clear: true
        });

        //     gl.finish();

        // Convert picked pixel color to object index

        var pix = pickBuf.read(canvasX, canvasY);
        var pickedObjectIndex = pix[0] + pix[1] * 256 + pix[2] * 65536;
        pickedObjectIndex = (pickedObjectIndex >= 1) ? pickedObjectIndex - 1 : -1;

        var object = this._objectPickList[pickedObjectIndex];

        if (object) {

            // Object was picked

            hit = {
                entity: object.id,
                canvasPos: [
                    canvasX,
                    canvasY
                ]
            };

            // Now do a primitive-pick if requested

            if (params.rayPick) {

                pickBuf.clear();

                this._doDrawList({
                    rayPick: true,
                    object: object,
                    clear: true
                });

                gl.finish();

                // Convert picked pixel color to primitive index

                pix = pickBuf.read(canvasX, canvasY);
                var primitiveIndex = pix[0] + pix[1] * 256 + pix[2] * 65536;
                primitiveIndex = (primitiveIndex >= 1) ? primitiveIndex - 1 : -1;

                hit.primitiveIndex = primitiveIndex;
            }
        }

        pickBuf.unbind();

        return hit;
    };

    /** Renders either the draw or pick list.
     *
     * @param {*} params
     * @param {Boolean} params.clear Set true to clear the color, depth and stencil buffers first
     * @param {Boolean} params.pickObject
     * @param {Boolean} params.rayPick
     * @param {Boolean} params.object
     * @private
     */
    XEO.renderer.Renderer.prototype._doDrawList = function (params) {

        var gl = this._canvas.gl;

        var ambient = this._ambient;
        var ambientColor;
        if (ambient) {
            var color = ambient.color;
            var intensity = ambient.intensity;
            ambientColor = [color[0] * intensity, color[1] * intensity, color[2] * intensity, 1.0];
        } else {
            ambientColor = [0, 0, 0];
        }

        var frameCtx = this._frameCtx;

        frameCtx.renderTarget = null;
        frameCtx.renderBuf = null;
        frameCtx.depthbufEnabled = null;
        frameCtx.clearDepth = null;
        frameCtx.depthFunc = gl.LESS;
        frameCtx.blendEnabled = false;
        frameCtx.backfaces = true;
        frameCtx.frontface = true; // true == "ccw" else "cw"
        frameCtx.pickIndex = 0; // Indexes this._pickObjects
        frameCtx.textureUnit = 0;
        frameCtx.transparent = false; // True while rendering transparency bin
        frameCtx.ambientColor = ambientColor;
        frameCtx.drawElements = 0;
        frameCtx.useProgram = 0;
        frameCtx.bindTexture = 0;
        frameCtx.bindArray = 0;

        this.stats.frame.setUniform = 0;
        this.stats.frame.setUniformCacheHits = 0;

        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

        gl.enable(gl.DEPTH_TEST);

        if (this.transparent) {

            // Canvas is transparent - set clear color with zero alpha
            // to allow background to show through

            gl.clearColor(0, 0, 0, 0);

        } else {

            // Canvas is opaque - set clear color to the current ambient
            // color, which can be provided by an ambient light source

            gl.clearColor(ambientColor[0], ambientColor[1], ambientColor[2], 1.0);
        }

        if (params.clear) {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
        }

        gl.frontFace(gl.CCW);
        gl.disable(gl.CULL_FACE);
        gl.disable(gl.BLEND);

        if (params.pickObject) {

            // Pick an object

            for (var i = 0, len = this._pickObjectChunkListLen; i < len; i++) {
                this._pickObjectChunkList[i].pickObject(frameCtx);
            }

        } else if (params.rayPick) {

            // Pick a primitive of an object

            if (params.object) {

                var chunks = params.object.chunks;
                var chunk;

                for (var i = 0, len = chunks.length; i < len; i++) {
                    chunk = chunks[i];
                    if (chunk.pickPrimitive) {
                        chunk.pickPrimitive(frameCtx);
                    }
                }
            }

        } else {

            // Render all visible objects

            var startTime = (new Date()).getTime();

            for (var i = 0, len = this._drawChunkListLen; i < len; i++) {
                this._drawChunkList[i].draw(frameCtx);
            }

            var endTime = (new Date()).getTime();

            this.stats.frame.renderTime = (endTime - startTime) / 1000.0;
            this.stats.frame.drawElements = frameCtx.drawElements;
            this.stats.frame.useProgram = frameCtx.useProgram;
            this.stats.frame.bindTexture = frameCtx.bindTexture;
            this.stats.frame.bindArray = frameCtx.bindArray;
        }

        gl.flush();

        if (frameCtx.renderBuf) {
            frameCtx.renderBuf.unbind();
        }

        var numTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        for (var ii = 0; ii < numTextureUnits; ++ii) {
            gl.activeTexture(gl.TEXTURE0 + ii);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }

        this.stats.frame.drawChunks = this._drawChunkListLen;
    };

    /**
     * Destroys this Renderer.
     */
    XEO.renderer.Renderer.prototype.destroy = function () {
        this._programFactory.destroy();
    };
})();
;/**
 * Renderer states
 */
(function () {

    "use strict";

    XEO.renderer = XEO.renderer || {};


    /**

     Base class for Renderer states.

     renderer.State
     @module XEO

     @constructor
     @param cfg {*} Configs
     */
    XEO.renderer.State = Class.extend({

        __init: function (cfg) {

            this.id = this._ids.addItem({});

            this.hash = cfg.hash || "" + this.id; // Not used by all sub-classes

            for (var key in cfg) {
                if (cfg.hasOwnProperty(key)) {
                    this[key] = cfg[key];
                }
            }
        },

        destroy: function () {
            this._ids.removeItem(this.id);
        }
    });

    //XEO.renderer.State.prototype.destroy = function () {
    //    states.removeItem(this.id);
    //};

    /**

     Visibility state.

     renderer.Visibility
     @module XEO

     @constructor
     @param cfg {*} Configs
     @param cfg.visible {Boolean} Flag which controls visibility of the associated render objects.
     @extends renderer.State
     */
    XEO.renderer.Visibility = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Modes state.

     renderer.Mode
     @module XEO

     @constructor
     @param cfg {*} Configs
     @param cfg.pickable {Boolean} Flag which controls pickability of the associated render objects.
     @param cfg.clipping {Boolean} Flag which controls whether associated render objects are clippable.
     @param cfg.transparent {Boolean} Flag which controls transparency of the associated render objects.
     @param cfg.frontFace {Boolean} Flag which determines winding order of backfaces on the associated render objects - true == "ccw", false == "cw".
     @extends renderer.State
     */
    XEO.renderer.Modes = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Layer state.

     renderer.Layer
     @module XEO

     @constructor
     @param cfg {*} Configs
     @param cfg.priority {Number} Layer render priority.
     @extends renderer.State
     */
    XEO.renderer.Layer = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Stage state.

     renderer.Stage
     @module XEO

     @constructor
     @param cfg {*} Configs
     @param cfg.priority {Number} Stage render priority.
     @extends renderer.State
     */
    XEO.renderer.Stage = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Depth buffer state.

     renderer.DepthBuf
     @module XEO

     @constructor
     @param cfg {*} Configs
     @param cfg.clearDepth {Number} Clear depth
     @param cfg.depthBuf {String} Depth function
     @extends renderer.State
     */
    XEO.renderer.DepthBuf = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Color buffer state.

     renderer.ColorBuf
     @module XEO

     @constructor
     @param cfg {*} Configs
     @param cfg.blendEnabled {Boolean} Indicates if blending is enebled for
     @param cfg.colorMask {Array of String} The color mask
     @extends renderer.State
     */
    XEO.renderer.ColorBuf = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Renderer lights state.

     renderer.Lights
     @module XEO

     @constructor
     @param cfg {*} Configs
     @param cfg.colorMask {Array of Object} The light sources
     @extends renderer.State
     */
    XEO.renderer.Lights = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     PhongMaterial state.

     renderer.PhongMaterial
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.PhongMaterial = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Environmental reflection state.

     renderer.Reflect
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.Reflect = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Modelling transform state.

     renderer.ModelTransform
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.ModelTransform = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Viewing transform state.

     renderer.ViewTransform
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.ViewTransform = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Projection transform state.

     renderer.ProjTransform
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.ProjTransform = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Billboard transform state.

     renderer.Billboard
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.Billboard = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Stationary transform state.

     renderer.Stationary
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.Stationary = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });


    /**

     Render target state.

     renderer.RenderTarget
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.RenderTarget = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    XEO.renderer.RenderTarget.DEPTH = 0;
    XEO.renderer.RenderTarget.COLOR = 1;

    /**

     Clip planes state.

     renderer.Clips
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.Clips = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Renderer morph targets state.

     renderer.MorphTargets
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.MorphTargets = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Shader state.

     renderer.Shader
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.Shader = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Shader parameters state.

     renderer.ShaderParams
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.ShaderParams = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Texture state.

     renderer.Texture
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.Texture = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });


    /**

     Fresnel state.

     renderer.Fresnel
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.Fresnel = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });


    /**

     Geometry state.

     renderer.Geometry
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.Geometry = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

    /**

     Program state.

     renderer.ProgramState
     @module XEO

     @constructor
     @param cfg {*} Configs
     @extends renderer.State
     */
    XEO.renderer.ProgramState = XEO.renderer.State.extend({
        _ids: new XEO.utils.Map({})
    });

})();


;(function () {

    "use strict";

    /**
     * An object within a XEO.renderer.Renderer
     */
    XEO.renderer.Object = function (id) {

        /**
         * ID for this object, unique among all objects in the Renderer
         */
        this.id = id;

        /**
         * Hash code for this object, unique among all objects in the Renderer
         */
        this.hash = null;

        /**
         * State sort key, computed from #layer, #program and #material
         * @type Number
         */
        this.sortKey = null;

        /**
         * Sequence of state chunks applied to render this object
         */
        this.chunks = [];

        /**
         * Shader programs that render this object, also used for (re)computing #sortKey
         */
        this.program = null;

        /**
         * State for the XEO.renderer.Stage that this object was compiled from, used for (re)computing #sortKey and visibility cull
         */
        this.stage = null;

        /**
         * State for the XEO.renderer.Modes that this object was compiled from, used for visibility cull
         */
        this.modes = null;

        /**
         * State for the XEO.renderer.Layer that this object was compiled from, used for (re)computing #sortKey and visibility cull
         */
        this.layer = null;

        /**
         * State for the XEO.renderer.Material that this object was compiled from, used for (re)computing #sortKey
         */
        this.material = null;
    };
})();;                (function () {

    "use strict";

    XEO.renderer.ObjectFactory = function () {

        var freeObjects = [];
        var numFreeObjects = 0;

        this.get = function (id) {

            var object;

            if (numFreeObjects > 0) {

                object = freeObjects[--numFreeObjects];

                object.id = id;

                return object;
            }

            return new XEO.renderer.Object(id);
        };

        this.put = function (object) {
            freeObjects[numFreeObjects++] = object;
        };
    };

})();


;(function () {

    "use strict";

    XEO.renderer = XEO.renderer || {};

    /**
     *  Vertex and fragment shaders for pick and draw
     *
     * @param {*} stats Collects runtime statistics
     * @param {String} hash Hash code which uniquely identifies the capabilities of the program, computed from hashes on the {@link Scene_Core}s that the {@link XEO.renderer.ProgramSource} composed to render
     * @param {XEO.renderer.ProgramSource} source Sourcecode from which the the program is compiled in {@link #build}
     * @param {WebGLRenderingContext} gl WebGL context
     */
    XEO.renderer.Program = function (stats, hash, source, gl) {

        this.stats = stats;

        /**
         * Hash code for this program's capabilities, same as the hash on {@link #source}
         * @type String
         */
        this.hash = source.hash;

        /**
         * Source code for this program's shaders
         * @type renderer.ProgramSource
         */
        this.source = source;

        /**
         * WebGL context on which this program's shaders are allocated
         * @type WebGLRenderingContext
         */
        this.gl = gl;

        /**
         * The drawing program
         * @type webgl.Program
         */
        this.draw = null;

        /**
         * The object picking program
         * @type webgl.Program
         */
        this.pickObject = null;

        /**
         * The primitive picking program
         * @type webgl.Program
         */
        this.pickPrimitive = null;

        /**
         * The count of display objects using this program
         * @type Number
         */
        this.useCount = 0;

        /**
         * True when successfully allocated
         * @type {boolean}
         */
        this.allocated = false;

        /**
         * True when successfully compiled
         * @type {boolean}
         */
        this.compiled = false;

        /**
         * True when successfully linked
         * @type {boolean}
         */
        this.linked = false;

        /**
         * True when successfully validated
         * @type {boolean}
         */
        this.validated = false;

        /**
         * Contains error log on failure to allocate, compile, validate or link
         * @type {boolean}
         */
        this.errorLog = null;


        this.build(gl);
    };

    /**
     *  Creates the render and pick programs.
     * This is also re-called to re-create them after WebGL context loss.
     */
    XEO.renderer.Program.prototype.build = function (gl) {

        this.gl = gl;

        this.allocated = false;
        this.compiled = false;
        this.linked = false;
        this.validated = false;
        this.errorLog = null;

        this.draw = new XEO.renderer.webgl.Program(this.stats, gl, this.source.vertexDraw, this.source.fragmentDraw);
        this.pickObject = new XEO.renderer.webgl.Program(this.stats, gl, this.source.vertexPickObject, this.source.fragmentPickObject);
        this.pickPrimitive = new XEO.renderer.webgl.Program(this.stats, gl, this.source.vertexPickPrimitive, this.source.fragmentPickPrimitive);

        if (!this.draw.allocated) {
            this.errorLog = ["Draw program failed to allocate"].concat(this.draw.errorLog);
            return;
        }

        if (!this.pickObject.allocated) {
            this.errorLog = ["Object-picking program failed to allocate"].concat(this.pickObject.errorLog);
            return;
        }

        if (!this.pickPrimitive.allocated) {
            this.errorLog = ["Primitive-picking program failed to allocate"].concat(this.pickPrimitive.errorLog);
            return;
        }

        this.allocated = true;

        if (!this.draw.compiled) {
            this.errorLog = ["Draw program failed to compile"].concat(this.draw.errorLog);
            return;
        }

        if (!this.pickObject.compiled) {
            this.errorLog = ["Object-picking program failed to compile"].concat(this.pickObject.errorLog);
            return;
        }

        if (!this.pickPrimitive.compiled) {
            this.errorLog = ["Primitive-picking program failed to compile"].concat(this.pickPrimitive.errorLog);
            return;
        }

        this.compiled = true;

        if (!this.draw.linked) {
            this.errorLog = ["Draw program failed to link"].concat(this.draw.errorLog);
            return;
        }

        if (!this.pickObject.linked) {
            this.errorLog = ["Object-picking program failed to link"].concat(this.pickObject.errorLog);
            return;
        }

        if (!this.pickPrimitive.linked) {
            this.errorLog = ["Primitive-picking program failed to link"].concat(this.pickPrimitive.errorLog);
            return;
        }

        this.linked = true;

        if (!this.draw.validated) {
            this.errorLog = ["Draw program failed to validate"].concat(this.draw.errorLog);
            return;
        }

        if (!this.pickObject.validated) {
            this.errorLog = ["Object-picking program failed to validate"].concat(this.pickObject.errorLog);
            return;
        }

        if (!this.pickPrimitive.validated) {
            this.errorLog = ["Primitive-picking program failed to validate"].concat(this.pickPrimitive.errorLog);
            return;
        }

        this.validated = true;
    };

})();
;(function () {

    "use strict";

    /**
     *  Manages {@link XEO.renderer.ProgramState} instances.
     * @param stats Collects runtime statistics
     * @param cfg Configs
     */
    XEO.renderer.ProgramFactory = function (stats, cfg) {

        this.stats = stats;

        this._canvas = cfg.canvas;

        this._programStates = {};
    };


    /**
     * Get a program that fits the given set of states.
     * Reuses any free program in the pool that matches the given hash.
     */
    XEO.renderer.ProgramFactory.prototype.get = function (hash, states) {

        var programState = this._programStates[hash];

        if (!programState) {

            // No program exists for the states

            // Create it and map it to the hash

            var source = XEO.renderer.ProgramSourceFactory.getSource(hash, states);

            var program = new XEO.renderer.Program(this.stats, hash, source, this._canvas.gl);

            programState = new XEO.renderer.ProgramState({
                program: program,
                useCount: 1
            });

            this._programStates[hash] = programState;

            this.stats.memory.programs++;
        }

        programState.useCount++;

        return programState;
    };

    /**
     * Release a program back to the pool.
     */
    XEO.renderer.ProgramFactory.prototype.put = function (programState) {

        var program = programState.program;

        if (--program.useCount <= 0) {

            program.draw.destroy();
            program.pickObject.destroy();
            program.pickPrimitive.destroy();

            XEO.renderer.ProgramSourceFactory.putSource(program.hash);

            delete this._programStates[program.hash];

            this.stats.memory.programs--;
        }
    };

    /**
     * Rebuild all programs in the pool after WebGL context was lost and restored.
     */
    XEO.renderer.ProgramFactory.prototype.webglRestored = function () {

        var gl = this._canvas.gl;

        for (var id in this._programStates) {
            if (this._programStates.hasOwnProperty(id)) {

                this._programStates[id].build(gl);
            }
        }
    };

    XEO.renderer.ProgramFactory.prototype.destroy = function () {
    };

})();
;(function () {

    "use strict";

    /**
     *  Source code for pick and draw shader programs, to be compiled into one or more {@link XEO.renderer.Program}s
     *
     * @param {String} hash Hash code identifying the rendering capabilities of the programs
     * @param {String} vertexPickObject Vertex shader source for object picking.
     * @param {String} fragmentPickObject Fragment shader source for object picking.
     * @param {String} vertexPickPrimitive Vertex shader source for primitive picking.
     * @param {String} fragmentPickPrimitive Fragment shader source for primitive picking.
     * @param {String} vertexDraw Vertex shader source for drawing.
     * @param {String} fragmentDraw Fragment shader source for drawing.
     */
    XEO.renderer.ProgramSource = function (hash,
                                           vertexPickObject, fragmentPickObject,
                                           vertexPickPrimitive, fragmentPickPrimitive,
                                           vertexDraw, fragmentDraw) {

        /**
         * Hash code identifying the capabilities of the {@link XEO.renderer.Program} that is compiled from this source
         * @type String
         */
        this.hash = hash;

        /**
         * Vertex shader source for object picking
         * @type {Array of String]
         */
        this.vertexPickObject = vertexPickObject;

        /**
         * Fragment shader source for object picking.
         * @type {Array of String}
         */
        this.fragmentPickObject = fragmentPickObject;

        /**
         * Vertex shader source for primitive picking.
         * @type {Array of String]
         */
        this.vertexPickPrimitive = vertexPickPrimitive;

        /**
         * Fragment shader source for primitive picking.
         * @type {Array of String}
         */
        this.fragmentPickPrimitive = fragmentPickPrimitive;

        /**
         * Vertex shader source for drawing.
         * @type {Array of String}
         */
        this.vertexDraw = vertexDraw;

        /**
         * Fragment shader source for drawing.
         * @type {Array of String}
         */
        this.fragmentDraw = fragmentDraw;

        /**
         * Count of {@link XEO.renderer.Program}s compiled from this program source code
         * @type Number
         */
        this.useCount = 0;
    };

})();

;(function () {

    "use strict";

    /**
     *  Manages creation, sharing and recycle of {@link XEO.renderer.ProgramSource} instances
     */
    XEO.renderer.ProgramSourceFactory = new (function () {

        var cache = {}; // Caches source code against hashes

        var src = ""; // Accumulates source code as it's being built

        var states; // Cache rendering state
        var texturing; // True when rendering state contains textures
        var normals; // True when rendering state contains normals
        var normalMapping; // True when rendering state contains tangents
        var reflection; // True when rendering state contains reflections

        var diffuseFresnel;
        var specularFresnel;
        var opacityFresnel;
        var reflectivityFresnel;
        var emissiveFresnel;

        /**
         * Get source code for a program to render the given states.
         * Attempts to reuse cached source code for the given hash.
         */
        this.getSource = function (hash, _states) {

            var source = cache[hash];

            if (source) {
                source.useCount++;
                return source;
            }

            states = _states;

            texturing = hasTextures();
            normals = hasNormals();
            normalMapping = hasNormalMap();
            reflection = hasReflection();

            diffuseFresnel = states.material.diffuseFresnel;
            specularFresnel = states.material.specularFresnel;
            opacityFresnel = states.material.opacityFresnel;
            reflectivityFresnel = states.material.reflectivityFresnel;
            emissiveFresnel = states.material.emissiveFresnel;

            source = new XEO.renderer.ProgramSource(
                hash,
                vertexPickObject(),
                fragmentPickObject(),
                vertexPickPrimitive(),
                fragmentPickPrimitive(),
                vertexDraw(),
                fragmentDraw()
            );

            cache[hash] = source;

            return source;
        };

        function hasTextures() {
            if (!states.geometry.uv) {
                return false;
            }
            var material = states.material;
            return material.ambientMap ||
                material.diffuseMap ||
                material.specularMap ||
                material.emissiveMap ||
                material.opacityMap ||
                material.reflectivityMap ||
                states.material.normalMap;
        }

        function hasReflection() {
            return false;
            //return (states.cubemap.layers && states.cubemap.layers.length > 0 && states.geometry.normalBuf);
        }

        function hasNormals() {
            var primitive = states.geometry.primitiveName;
            if (states.geometry.normals && (primitive === "triangles" || primitive === "triangle-strip" || primitive === "triangle-fan")) {
                return true;
            }
            return false;
        }

        function hasNormalMap() {
            return (states.geometry.normals && states.material.normalMap);
        }

        /**
         * Releases program source code back to this factory.
         */
        this.putSource = function (hash) {
            var source = cache[hash];
            if (source) {
                if (--source.useCount === 0) {
                    cache[source.hash] = null;
                }
            }
        };


        // NOTE: Picking shaders will become more complex and will eventually be
        // composed from state, in the same manner as the draw shaders.

        function vertexPickObject() {
            begin();
            add("attribute vec3 xeo_aPosition;");
            add("uniform mat4 xeo_uModelMatrix;");
            add("uniform mat4 xeo_uViewMatrix;");
            add("uniform mat4 xeo_uViewNormalMatrix;");
            add("uniform mat4 xeo_uProjMatrix;");
            add("varying vec4 xeo_vWorldPosition;");
            add("varying vec4 xeo_vViewPosition;");
            add("void main(void) {");
            add("   vec4 tmpVertex = vec4(xeo_aPosition, 1.0); ");
            add("   xeo_vWorldPosition = xeo_uModelMatrix * tmpVertex; ");
            add("   xeo_vViewPosition = xeo_uViewMatrix * xeo_vWorldPosition;");
            add("   gl_Position = xeo_uProjMatrix * xeo_vViewPosition;");
            add("}");
            return end();
        }

        function fragmentPickObject() {
            begin();
            add("precision " + getFSFloatPrecision(states._canvas.gl) + " float;");
            add("uniform vec4 xeo_uPickColor;");
            add("void main(void) {");
            add("   gl_FragColor = xeo_uPickColor; ");
            add("}");
            return end();
        }

        function vertexPickPrimitive() {
            begin();
            add("attribute vec3 xeo_aPosition;");
            add("attribute vec4 xeo_aColor;");
            add("uniform vec3 xeo_uPickColor;");
            add("uniform mat4 xeo_uModelMatrix;");
            add("uniform mat4 xeo_uViewMatrix;");
            add("uniform mat4 xeo_uProjMatrix;");
            add("varying vec4 xeo_vWorldPosition;");
            add("varying vec4 xeo_vViewPosition;");
            add("varying vec4 xeo_vColor;");
            add("void main(void) {");
            add("   vec4 tmpVertex = vec4(xeo_aPosition, 1.0); ");
            add("   vec4 worldPosition = xeo_uModelMatrix * tmpVertex; ");
            add("   vec4 viewPosition = xeo_uViewMatrix * worldPosition;");
            add("   xeo_vColor = xeo_aColor;");
            add("   gl_Position = xeo_uProjMatrix * viewPosition;");
            add("}");
            return end();
        }

        function fragmentPickPrimitive() {
            begin();
            add("precision " + getFSFloatPrecision(states._canvas.gl) + " float;");
            add("varying vec4 xeo_vColor;");
            add("void main(void) {");
            add("   gl_FragColor = xeo_vColor;");
            add("}");
            return end();
        }

        function vertexDraw() {

            var vertex = states.shader.vertex;

            if (vertex) {

                // Custom vertex shader
                return vertex;
            }

            begin();

            add("// Modeling matrix");
            add("uniform mat4 xeo_uModelMatrix;          // Modeling matrix");
            add("uniform mat4 xeo_uViewMatrix;           // Viewing matrix");
            add("uniform mat4 xeo_uProjMatrix;           // Projection matrix");
            add("uniform vec3 xeo_uEye;                  // World-space eye position");

            add("attribute vec3 xeo_aPosition;           // Local-space vertex position");

            add();

            add("varying vec4 xeo_vViewPosition;         // Output: View-space fragment position");

            if (normals) {

                add();

                add("attribute vec3 xeo_aNormal;             // Local-space vertex normal");

                add("uniform mat4 xeo_uModelNormalMatrix;    // Modeling normal matrix");
                add("uniform mat4 xeo_uViewNormalMatrix;     // Viewing normal matrix");

                add("varying vec3 xeo_vViewEyeVec;           // Output: View-space vector from fragment position to eye");
                add("varying vec3 xeo_vViewNormal;           // Output: View-space normal");

                if (normalMapping) {
                    add("attribute vec4 xeo_aTangent;            // Vertex tangent vector");
                }

                // Lights
                for (var i = 0; i < states.lights.lights.length; i++) {

                    var light = states.lights.lights[i];

                    if (light.type === "ambient") {
                        continue;
                    }

                    if (light.type === "dir") {
                        add("uniform vec3 xeo_uLightDir" + i + ";   // Directional light direction");
                    }

                    if (light.type === "point") {
                        add("uniform vec3 xeo_uLightPos" + i + ";   // Positional light position");
                    }

                    if (light.type === "spot") {
                        add("uniform vec3 xeo_uLightPos" + i + ";   // Spot light position");
                    }

                    add("varying vec4 xeo_vViewLightVecAndDist" + i + "; // Output: Vector from vertex to light, packaged with the pre-computed length of that vector");
                }
            }

            if (texturing) {

                add();

                // Vertex UV coordinate
                add("attribute vec2 xeo_aUV;");

                // Fragment UV coordinate
                add("varying vec2 xeo_vUV;");
            }

            if (states.geometry.colors) {

                // Vertex color
                add("attribute vec4 xeo_aColor;");

                // Fragment color
                add("varying vec4 xeo_vColor;");
            }

            if (states.geometry.primitiveName === "points") {
                add("uniform float xeo_uPointSize;");
            }

            if (states.billboard.active) {

                add("void billboard(inout mat4 mat) {");
                add("   mat[0][0] = -1.0;");
                add("   mat[0][1] = 0.0;");
                add("   mat[0][2] = 0.0;");
                if (states.billboard.spherical) {
                    add("   mat[1][0] = 0.0;");
                    add("   mat[1][1] = 1.0;");
                    add("   mat[1][2] = 0.0;");
                }
                add("   mat[2][0] = 0.0;");
                add("   mat[2][1] = 0.0;");
                add("   mat[2][2] =1.0;");
                add("}");
            }

            // ------------------- main -------------------------------

            add();
            add("void main(void) {");
            add();
            add("   vec4 localPosition = vec4(xeo_aPosition, 1.0); ");

            if (normals) {

                add("   vec4 localNormal = vec4(xeo_aNormal, 0.0); ");
                add("   mat4 modelNormalMatrix = xeo_uModelNormalMatrix;");
                add("   mat4 viewNormalMatrix = xeo_uViewNormalMatrix;");
            }

            add("   mat4 modelMatrix = xeo_uModelMatrix;");
            add("   mat4 viewMatrix = xeo_uViewMatrix;");
            add("   vec4 worldPosition;");

            if (states.stationary.active) {
                add("   viewMatrix[3][0] = viewMatrix[3][1] = viewMatrix[3][2] = 0.0;")
            }

            if (states.billboard.active) {

                add("   mat4 modelViewMatrix =  xeo_uViewMatrix * xeo_uModelMatrix;");

                add("   billboard(modelMatrix);");
                add("   billboard(viewMatrix);");
                add("   billboard(modelViewMatrix);");

                if (normals) {

                    add("   mat4 modelViewNormalMatrix =  xeo_uViewNormalMatrix * xeo_uModelNormalMatrix;");

                    add("   billboard(modelNormalMatrix);");
                    add("   billboard(viewNormalMatrix);");
                    add("   billboard(modelViewNormalMatrix);");
                }

                add("   worldPosition = modelMatrix * localPosition;");
                add("   vec4 viewPosition = modelViewMatrix * localPosition;");

            } else {

                add("   worldPosition = modelMatrix * localPosition;");
                add("   vec4 viewPosition  = viewMatrix * worldPosition; ");
            }

            if (normals) {

                add("   vec3 worldNormal = (modelNormalMatrix * localNormal).xyz; ");
                add("   xeo_vViewNormal = (viewNormalMatrix * vec4(worldNormal, 1.0)).xyz;");

                if (normalMapping) {

                    // Compute tangent-bitangent-normal matrix

                    add("   vec3 tangent = normalize((xeo_uViewNormalMatrix * xeo_uModelNormalMatrix * xeo_aTangent).xyz);");
                    add("   vec3 bitangent = cross(xeo_vViewNormal, tangent);");
                    add("   mat3 TBM = mat3(tangent, bitangent, xeo_vViewNormal);");
                }

                add("   vec3 tmpVec3;");

                // Lights

                for (var i = 0; i < states.lights.lights.length; i++) {

                    light = states.lights.lights[i];

                    if (light.type === "ambient") {
                        continue;
                    }

                    if (light.type === "dir") {

                        // Directional light

                        if (light.space === "world") {

                            // World space light

                            add("   tmpVec3 = xeo_uLightDir" + i + ";");

                            // Transform to View space
                            add("   tmpVec3 = vec3(viewMatrix * vec4(tmpVec3, 0.0)).xyz;");

                            if (normalMapping) {

                                // Transform to Tangent space
                                add("   tmpVec3 *= TBM;");
                            }

                        } else {

                            // View space light

                            add("   tmpVec3 = xeo_uLightDir" + i + ";");

                            if (normalMapping) {

                                // Transform to Tangent space
                                add("   tmpVec3 *= TBM;");
                            }
                        }

                        // Output
                        add("   xeo_vViewLightVecAndDist" + i + " = vec4(-tmpVec3, 0.0);");
                    }

                    if (light.type === "point") {

                        // Positional light

                        if (light.space === "world") {

                            // World space

                            // Transform into View space

                            add("   tmpVec3 = (viewMatrix * vec4(xeo_uLightPos" + i + ", 0.0)).xyz - viewPosition.xyz;"); // Vector from World coordinate to light pos

                            if (normalMapping) {
                                // Transform to Tangent space
                                add("   tmpVec3 *= TBM;");
                            }

                        } else {

                            // View space

                            add("   tmpVec3 = xeo_uLightPos" + i + ".xyz - viewPosition.xyz;"); // Vector from View coordinate to light pos

                            if (normalMapping) {

                                // Transform to tangent space
                                add("   tmpVec3 *= TBM;");
                            }
                        }

                        // Output
                        add("   xeo_vViewLightVecAndDist" + i + " = vec4(tmpVec3, length(xeo_uLightPos" + i + ".xyz - worldPosition.xyz));");
                    }
                }

                add("   xeo_vViewEyeVec = ((viewMatrix * vec4(xeo_uEye, 0.0)).xyz  - viewPosition.xyz);");

                if (normalMapping) {
                    add("   xeo_vViewEyeVec *= TBM;");
                }
            }

            if (texturing) {
                add("   xeo_vUV = xeo_aUV;");
            }

            if (states.geometry.colors) {
                add("   xeo_vColor = xeo_aColor;");
            }

            if (states.geometry.primitiveName === "points") {
                add("   gl_PointSize = xeo_uPointSize;");
            }

            add("   xeo_vViewPosition = viewPosition;");

            add("   gl_Position = xeo_uProjMatrix * viewPosition;");

            add("}");

            return end();
        }


        function fragmentDraw() {

            var fragment = states.shader.fragment;
            if (fragment) {
                // Custom fragment shader
                return fragment;
            }

            begin();

            add("precision " + getFSFloatPrecision(states._canvas.gl) + " float;");
            add();

            if (normals) {

                add("varying vec4 xeo_vViewPosition;");

                add();

                add("uniform vec3 xeo_uSpecular;");
                add("uniform float xeo_uShininess;");
                add("uniform float xeo_uReflectivity;");
            }

            add("uniform vec3 xeo_uEmissive;");
            add("uniform float xeo_uOpacity;");
            add("uniform vec3 xeo_uDiffuse;");

            add();

            if (states.geometry.colors) {
                add("varying vec4 xeo_vColor;");
            }

            if (texturing) {

                add();
                comment("Texture variables");
                add();

                if (states.geometry.uv) {
                    add("varying vec2 xeo_vUV;");
                }

                if (states.material.emissiveMap) {
                    add("uniform sampler2D xeo_uEmissiveMap;");
                    if (states.material.emissiveMap.matrix) {
                        add("uniform mat4 xeo_uEmissiveMapMatrix;");
                    }
                }

                if (states.material.opacityMap) {
                    add("uniform sampler2D xeo_uOpacityMap;");
                    if (states.material.opacityMap.matrix) {
                        add("uniform mat4 xeo_uOpacityMapMatrix;");
                    }
                }

                if (states.material.ambientMap) {
                    add("uniform sampler2D xeo_uAmbientMap;");
                    if (states.material.ambientMap.matrix) {
                        add("uniform mat4 xeo_uAmbientMapMatrix;");
                    }
                }

                if (states.material.diffuseMap) {
                    add("uniform sampler2D xeo_uDiffuseMap;");
                    if (states.material.diffuseMap.matrix) {
                        add("uniform mat4 xeo_uDiffuseMapMatrix;");
                    }
                }

                if (normals) {

                    if (states.material.specularMap) {
                        add("uniform sampler2D xeo_uSpecularMap;");
                        if (states.material.specularMap.matrix) {
                            add("uniform mat4 xeo_uSpecularMapMatrix;");
                        }
                    }

                    if (states.material.reflectivityMap) {
                        add("uniform sampler2D xeo_uTextureReflectivity;");
                        if (states.material.reflectivityMap.matrix) {
                            add("uniform mat4 xeo_uTextureReflectivityMatrix;");
                        }
                    }

                    if (normalMapping) {
                        add("uniform sampler2D xeo_uNormalMap;");
                        if (states.material.normalMap.matrix) {
                            add("uniform mat4 xeo_uNormalMapMatrix;");
                        }
                    }
                }
            }

            add("uniform vec3 xeo_uLightAmbientColor;");
            add("uniform float xeo_uLightAmbientIntensity;");

            if (normals) {

                // World-space vector from fragment to eye

                add("varying vec3 xeo_vViewEyeVec;");

                // View-space fragment normal

                add("varying vec3 xeo_vViewNormal;");

                // Light sources

                var light;

                for (var i = 0; i < states.lights.lights.length; i++) {

                    light = states.lights.lights[i];

                    if (light.type === "ambient") {
                        continue;
                    }

                    add("uniform vec3 xeo_uLightColor" + i + ";");
                    add("uniform float xeo_uLightIntensity" + i + ";");
                    if (light.type === "point") {
                        add("uniform vec3 xeo_uLightAttenuation" + i + ";");
                    }
                    add("varying vec4 xeo_vViewLightVecAndDist" + i + ";");         // Vector from light to vertex
                }

                if (diffuseFresnel || specularFresnel || opacityFresnel || emissiveFresnel || reflectivityFresnel) {

                    add();
                    comment("Fresnel variables");
                    add();

                    if (diffuseFresnel) {
                        add("uniform float xeo_uDiffuseFresnelCenterBias;");
                        add("uniform float xeo_uDiffuseFresnelEdgeBias;");
                        add("uniform float xeo_uDiffuseFresnelPower;");
                        add("uniform vec3 xeo_uDiffuseFresnelCenterColor;");
                        add("uniform vec3 xeo_uDiffuseFresnelEdgeColor;");
                        add();
                    }

                    if (specularFresnel) {
                        add("uniform float xeo_uSpecularFresnelCenterBias;");
                        add("uniform float xeo_uSpecularFresnelEdgeBias;");
                        add("uniform float xeo_uSpecularFresnelPower;");
                        add("uniform vec3 xeo_uSpecularFresnelCenterColor;");
                        add("uniform vec3 xeo_uSpecularFresnelEdgeColor;");
                        add();
                    }

                    if (opacityFresnel) {
                        add("uniform float xeo_uOpacityFresnelCenterBias;");
                        add("uniform float xeo_uOpacityFresnelEdgeBias;");
                        add("uniform float xeo_uOpacityFresnelPower;");
                        add("uniform vec3 xeo_uOpacityFresnelCenterColor;");
                        add("uniform vec3 xeo_uOpacityFresnelEdgeColor;");
                        add();
                    }

                    if (reflectivityFresnel) {
                        add("uniform float xeo_uReflectivityFresnelCenterBias;");
                        add("uniform float xeo_uReflectivityFresnelEdgeBias;");
                        add("uniform float xeo_uReflectivityFresnelPower;");
                        add("uniform vec3 xeo_uReflectivityFresnelCenterColor;");
                        add("uniform vec3 xeo_uReflectivityFresnelEdgeColor;");
                        add();
                    }

                    if (emissiveFresnel) {
                        add("uniform float xeo_uEmissiveFresnelCenterBias;");
                        add("uniform float xeo_uEmissiveFresnelEdgeBias;");
                        add("uniform float xeo_uEmissiveFresnelPower;");
                        add("uniform vec3 xeo_uEmissiveFresnelCenterColor;");
                        add("uniform vec3 xeo_uEmissiveFresnelEdgeColor;");
                        add();
                    }

                    comment("Fresnel calculation");
                    add();
                    add("float fresnel(vec3 eyeDir, vec3 normal, float edgeBias, float centerBias, float power) {");
                    add("    float fr = abs(dot(eyeDir, normal));");
                    add("    float finalFr = clamp((fr - edgeBias) / (centerBias - edgeBias), 0.0, 1.0);");
                    add("    return pow(finalFr, power);");
                    add("}");
                }
            }

            add();

            add("void main(void) {");

            add();

            add("   vec3 ambient = xeo_uLightAmbientColor;");
            add("   vec3 emissive = xeo_uEmissive;");
            add("   float opacity = xeo_uOpacity;");

            if (states.geometry.colors) {
                add("   vec3 diffuse = xeo_vColor.rgb;"); // Diffuse color from vertex colors
            } else {
                add("   vec3 diffuse = xeo_uDiffuse;");
            }

            if (normals) {

                add("vec3 viewEyeVec = normalize(xeo_vViewEyeVec);");

                add("   vec3 specular = xeo_uSpecular;");
                add("   float shininess = xeo_uShininess;");
                add("   float reflectivity = xeo_uReflectivity;");

                if (normalMapping) {
                    add("   vec3 viewNormal = vec3(0.0, 1.0, 0.0);");

                } else {

                    // Normalize the interpolated normals in the per-fragment-fragment-shader,
                    // because if we linear interpolated two nonparallel normalized vectors,
                    // the resulting vector won’t be of length 1

                    add("   vec3 viewNormal = normalize(xeo_vViewNormal);");
                }
            }

            if (texturing) {

                // Apply textures

                add();
                comment("   Apply textures");
                add();

                add("   vec4 texturePos = vec4(xeo_vUV.s, xeo_vUV.t, 1.0, 1.0);");
                add("   vec2 textureCoord;");

                var material = states.material;

                // Opacity and emissive lighting and mapping are independent of normals

                if (material.emissiveMap) {
                    add();
                    if (material.emissiveMap.matrix) {
                        add("   textureCoord = (xeo_uEmissiveMapMatrix * texturePos).xy;");
                    } else {
                        add("   textureCoord = texturePos.xy;");
                    }
                    add("   textureCoord.y = -textureCoord.y;");
                    add("   emissive = texture2D(xeo_uEmissiveMap, textureCoord).rgb;");
                }

                if (material.opacityMap) {
                    add();
                    if (material.opacityMap.matrix) {
                        add("   textureCoord = (xeo_uOpacityMapMatrix * texturePos).xy;");
                    } else {
                        add("   textureCoord = texturePos.xy;");
                    }
                    add("   textureCoord.y = -textureCoord.y;");
                    add("   opacity = texture2D(xeo_uOpacityMap, textureCoord).b;");
                }

                if (material.ambientMap) {
                    add();
                    if (material.ambientMap.matrix) {
                        add("   textureCoord = (xeo_uAmbientMapMatrix * texturePos).xy;");
                    } else {
                        add("   textureCoord = texturePos.xy;");
                    }
                    add("   textureCoord.y = -textureCoord.y;");
                    add("   ambient = texture2D(xeo_uAmbientMap, textureCoord).rgb;");
                }

                if (material.diffuseMap) {
                    add();
                    if (material.diffuseMap.matrix) {
                        add("   textureCoord = (xeo_uDiffuseMapMatrix * texturePos).xy;");
                    } else {
                        add("   textureCoord = texturePos.xy;");
                    }
                    add("   textureCoord.y = -textureCoord.y;");
                    add("   diffuse = texture2D(xeo_uDiffuseMap, textureCoord).rgb;");
                }

                if (normals) {

                    if (material.specularMap) {
                        add();
                        if (material.specularMap.matrix) {
                            add("   textureCoord = (xeo_uSpecularMapMatrix * texturePos).xy;");
                        } else {
                            add("   textureCoord = texturePos.xy;");
                        }
                        add("   textureCoord.y = -textureCoord.y;");
                        add("   specular = texture2D(xeo_uSpecularMap, textureCoord).rgb;");
                    }

                    if (material.reflectivityMap) {
                        add();
                        if (material.reflectivityMap.matrix) {
                            add("   textureCoord = (xeo_uReflectivityMapMatrix * texturePos).xy;");
                        } else {
                            add("   textureCoord = texturePos.xy;");
                        }
                        add("   textureCoord.y = -textureCoord.y;");
                        add("   reflectivity = texture2D(xeo_uReflectivityMap, textureCoord).b;");
                    }
                }

                if (normalMapping) {

                    if (material.normalMap) {
                        add();
                        if (material.normalMap.matrix) {
                            add("   textureCoord = (xeo_uNormalMapMatrix * texturePos).xy;");
                        } else {
                            add("   textureCoord = texturePos.xy;");
                        }
                        add("   textureCoord.y = -textureCoord.y;");
                        add("   viewNormal = normalize(texture2D(xeo_uNormalMap, vec2(textureCoord.x, -textureCoord.y)).xyz * 2.0 - 1.0);");
                    }
                }
            }

            if (normals) {

                // Get Lambertian shading terms

                add();
                comment("   Apply lights");

                add();
                add("   vec3  diffuseLight = vec3(0.0, 0.0, 0.0);");
                add("   vec3  specularLight = vec3(0.0, 0.0, 0.0);");

                add();
                add("   vec3  viewLightVec;");
                add("   float dotN;");
                add("   float lightDist;");
                add("   float attenuation;");

                var light;

                for (var i = 0, len = states.lights.lights.length; i < len; i++) {

                    light = states.lights.lights[i];

                    if (light.type === "ambient") {
                        continue;
                    }

                    add("   viewLightVec = normalize(xeo_vViewLightVecAndDist" + i + ".xyz);");

                    if (light.type === "point") {
                        add();
                        add("   dotN = max(dot(viewNormal, viewLightVec), 0.0);");
                        add("   lightDist = xeo_vViewLightVecAndDist" + i + ".w;");
                        add("   attenuation = 1.0 - (" +
                            "  xeo_uLightAttenuation" + i + "[0] + " +
                            "  xeo_uLightAttenuation" + i + "[1] * lightDist + " +
                            "  xeo_uLightAttenuation" + i + "[2] * lightDist * lightDist);");

                        add("   diffuseLight += dotN * xeo_uLightColor" + i + " * attenuation;");

                        add("   specularLight += xeo_uLightIntensity" + i +
                            " *  pow(max(dot(reflect(viewLightVec, -viewNormal), -viewEyeVec), 0.0), shininess) * attenuation;");
                    }

                    if (light.type === "dir") {
                        add();
                        add("   dotN = max(dot(viewNormal, viewLightVec), 0.0);");

                        add("   diffuseLight += dotN * xeo_uLightColor" + i + ";");

                        add("   specularLight += xeo_uLightIntensity" + i +
                            " * pow(max(dot(reflect(viewLightVec, -viewNormal), -viewEyeVec), 0.0), shininess);");
                    }
                }

                add();

                // Get Fresnel terms

                if (diffuseFresnel || specularFresnel || opacityFresnel || emissiveFresnel || reflectivityFresnel) {

                    add();
                    comment("   Apply Fresnels");

                    if (diffuseFresnel) {
                        add();
                        add("float diffuseFresnel = fresnel(viewEyeVec, viewNormal, xeo_uDiffuseFresnelEdgeBias, xeo_uDiffuseFresnelCenterBias, xeo_uDiffuseFresnelPower);");
                        add("diffuse *= mix(xeo_uDiffuseFresnelEdgeColor, xeo_uDiffuseFresnelCenterColor, diffuseFresnel);");
                    }

                    if (specularFresnel) {
                        add();
                        add("float specularFresnel = fresnel(viewEyeVec, viewNormal, xeo_uSpecularFresnelEdgeBias, xeo_uSpecularFresnelCenterBias, xeo_uSpecularFresnelPower);");
                        add("specular *= mix(xeo_uSpecularFresnelEdgeColor, xeo_uSpecularFresnelCenterColor, specularFresnel);");
                    }

                    if (opacityFresnel) {
                        add();
                        add("float opacityFresnel = fresnel(viewEyeVec, viewNormal, xeo_uOpacityFresnelEdgeBias, xeo_uOpacityFresnelCenterBias, xeo_uOpacityFresnelPower);");
                        add("opacity *= mix(xeo_uOpacityFresnelEdgeColor.r, xeo_uOpacityFresnelCenterColor.r, opacityFresnel);");
                    }

                    if (emissiveFresnel) {
                        add();
                        add("float emissiveFresnel = fresnel(viewEyeVec, viewNormal, xeo_uEmissiveFresnelEdgeBias, xeo_uEmissiveFresnelCenterBias, xeo_uEmissiveFresnelPower);");
                        add("emissive *= mix(xeo_uEmissiveFresnelEdgeColor, xeo_uEmissiveFresnelCenterColor, emissiveFresnel);");
                    }
                }

                // Combine terms with Blinn-Phong BRDF

                add();
                comment("   Phong BRDF");
                add();
                add("   gl_FragColor = vec4((specular * specularLight) + ((diffuseLight + (ambient * xeo_uLightAmbientIntensity) ) * diffuse) + emissive, opacity);");

            } else {

                // No normals
                add();
                comment("   Non-Lambertian BRDF");
                add();
                add("   gl_FragColor = vec4(emissive + diffuse, opacity);");
            }

            add("}");

            return end();
        }

        // Start fresh program source
        function begin() {
            src = [];
        }

        // Append to program source
        function add(txt) {
            src.push(txt || "");
        }

        // Append to program source
        function comment(txt) {
            if (txt) {
                var c = 0;
                for (var i = 0, len = txt.length; i < len; i++) {
                    if (txt.charAt(i) === " ") {
                        c++;
                    }
                }
                var pad = c > 0 ? txt.substring(0, c - 1) : "";
                src.push(pad + "// " + txt.substring(c - 1));
            }
        }

        // Finish building program source
        function end() {
            return src;
        }

        function getFSFloatPrecision(gl) {

            if (!gl.getShaderPrecisionFormat) {
                return "mediump";
            }

            if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                return "highp";
            }

            if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                return "mediump";
            }

            return "lowp";
        }

    })();

})();;(function () {

    "use strict";

    XEO.renderer.webgl = {

        /** Maps XEO component parameter names to WebGL enum names
         */
        enums: {
            funcAdd: "FUNC_ADD",
            funcSubtract: "FUNC_SUBTRACT",
            funcReverseSubtract: "FUNC_REVERSE_SUBTRACT",
            zero: "ZERO",
            one: "ONE",
            srcColor: "SRC_COLOR",
            oneMinusSrcColor: "ONE_MINUS_SRC_COLOR",
            dstColor: "DST_COLOR",
            oneMinusDstColor: "ONE_MINUS_DST_COLOR",
            srcAlpha: "SRC_ALPHA",
            oneMinusSrcAlpha: "ONE_MINUS_SRC_ALPHA",
            dstAlpha: "DST_ALPHA",
            oneMinusDstAlpha: "ONE_MINUS_DST_ALPHA",
            contantColor: "CONSTANT_COLOR",
            oneMinusConstantColor: "ONE_MINUS_CONSTANT_COLOR",
            constantAlpha: "CONSTANT_ALPHA",
            oneMinusConstantAlpha: "ONE_MINUS_CONSTANT_ALPHA",
            srcAlphaSaturate: "SRC_ALPHA_SATURATE",
            front: "FRONT",
            back: "BACK",
            frontAndBack: "FRONT_AND_BACK",
            never: "NEVER",
            less: "LESS",
            equal: "EQUAL",
            lequal: "LEQUAL",
            greater: "GREATER",
            notequal: "NOTEQUAL",
            gequal: "GEQUAL",
            always: "ALWAYS",
            cw: "CW",
            ccw: "CCW",
            linear: "LINEAR",
            nearest: "NEAREST",
            linearMipmapNearest: "LINEAR_MIPMAP_NEAREST",
            nearestMipmapNearest: "NEAREST_MIPMAP_NEAREST",
            nearestMipmapLinear: "NEAREST_MIPMAP_LINEAR",
            linearMipmapLinear: "LINEAR_MIPMAP_LINEAR",
            repeat: "REPEAT",
            clampToEdge: "CLAMP_TO_EDGE",
            mirroredRepeat: "MIRRORED_REPEAT",
            alpha: "ALPHA",
            rgb: "RGB",
            rgba: "RGBA",
            luminance: "LUMINANCE",
            luminanceAlpha: "LUMINANCE_ALPHA",
            textureBinding2D: "TEXTURE_BINDING_2D",
            textureBindingCubeMap: "TEXTURE_BINDING_CUBE_MAP",
            compareRToTexture: "COMPARE_R_TO_TEXTURE", // Hardware Shadowing Z-depth,
            unsignedByte: "UNSIGNED_BYTE"
        }
    };

})();;(function () {

    "use strict";

    /**
     * Buffer for vertices and indices
     *
     * @param gl WebGL
     * @param type  Eg. ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER
     * @param data  WebGL array wrapper
     * @param numItems Count of items in array wrapper
     * @param itemSize Size of each item
     * @param usage Eg. STATIC_DRAW
     */
    XEO.renderer.webgl.ArrayBuffer = function (gl, type, data, numItems, itemSize, usage) {

        /**
         * True when this buffer is allocated and ready to go
         * @type {boolean}
         */
        this.allocated = false;

        this.gl = gl;

        this.type = type;

        this.itemType = data.constructor == Uint8Array ? gl.UNSIGNED_BYTE :
            data.constructor == Uint16Array ? gl.UNSIGNED_SHORT :
                data.constructor == Uint32Array ? gl.UNSIGNED_INT :
                    gl.FLOAT;

        this.usage = usage;

        this.length = 0;
        this.numItems = 0;
        this.itemSize = itemSize;

        this._allocate(data);
    };

    /**
     * Allocates this buffer
     *
     * @param data
     * @private
     */
    XEO.renderer.webgl.ArrayBuffer.prototype._allocate = function (data) {

        this.allocated = false;

        this._handle = this.gl.createBuffer();

        if (!this._handle) {
            throw "Failed to allocate WebGL ArrayBuffer";
        }

        if (this._handle) {

            this.gl.bindBuffer(this.type, this._handle);
            this.gl.bufferData(this.type, data, this.usage);
            this.gl.bindBuffer(this.type, null);

            this.length = data.length;
            this.numItems = this.length / this.itemSize;

            this.allocated = true;
        }
    };

    /**
     * Updates data within this buffer, reallocating if needed.
     *
     * @param data
     * @param offset
     */
    XEO.renderer.webgl.ArrayBuffer.prototype.setData = function (data, offset) {

        if (!this.allocated) {
            return;
        }

        if (data.length > this.length) {

            // Needs reallocation

            this.destroy();

            this._allocate(data, data.length);

        } else {

            // No reallocation needed

            if (offset || offset === 0) {

                this.gl.bufferSubData(this.type, offset, data);

            } else {

                this.gl.bufferData(this.type, data);
            }
        }
    };

    /**
     * Binds this buffer
     */
    XEO.renderer.webgl.ArrayBuffer.prototype.bind = function () {

        if (!this.allocated) {
            return;
        }

        this.gl.bindBuffer(this.type, this._handle);
    };

    /**
     * Unbinds this buffer
     */
    XEO.renderer.webgl.ArrayBuffer.prototype.unbind = function () {

        if (!this.allocated) {
            return;
        }

        this.gl.bindBuffer(this.type, null);
    };

    /**
     * Destroys this buffer
     */
    XEO.renderer.webgl.ArrayBuffer.prototype.destroy = function () {

        if (!this.allocated) {
            return;
        }

        this.gl.deleteBuffer(this._handle);

        this._handle = null;

        this.allocated = false;
    };

})();

;(function () {

    "use strict";

    /**
     * An attribute within a {@link XEO.renderer.webgl.Shader}
     */
    XEO.renderer.webgl.Attribute = function (gl, location) {

        this.gl = gl;

        this.location = location;
    };

    XEO.renderer.webgl.Attribute.prototype.bindFloatArrayBuffer = function (buffer) {

        if (buffer) {

            buffer.bind();

            this.gl.enableVertexAttribArray(this.location);

            // Vertices are not homogeneous - no w-element
            this.gl.vertexAttribPointer(this.location, buffer.itemSize, this.gl.FLOAT, false, 0, 0);
        }
    };

    XEO.renderer.webgl.Attribute.prototype.bindInterleavedFloatArrayBuffer = function (components, stride, byteOffset) {

        this.gl.enableVertexAttribArray(this.location);

        // Vertices are not homogeneous - no w-element
        this.gl.vertexAttribPointer(this.location, components, this.gl.FLOAT, false, stride, byteOffset);
    };

})();;(function () {

    "use strict";

    function joinSansComments(srcLines) {
        var src = [];
        var line;
        var n;
        for (var i = 0, len = srcLines.length; i < len; i++) {
            line = srcLines[i];
            n = line.indexOf("/");
            if (n > 0) {
                if (line.charAt(n + 1) === "/") {
                    line = line.substring(0, n);
                }
            }
            src.push(line);
        }
        return src.join("\n");
    }

    /**
     * Wrapper for a WebGL program
     *
     * @param stats Collects runtime statistics
     * @param gl WebGL gl
     * @param vertex Source code for vertex shader
     * @param fragment Source code for fragment shader
     */
    XEO.renderer.webgl.Program = function (stats, gl, vertex, fragment) {

        this.stats = stats;

        this.gl = gl;

        /**
         * True when successfully allocated
         * @type {boolean}
         */
        this.allocated = false;

        /**
         * True when successfully compiled
         * @type {boolean}
         */
        this.compiled = false;

        /**
         * True when successfully linked
         * @type {boolean}
         */
        this.linked = false;

        /**
         * True when successfully validated
         * @type {boolean}
         */
        this.validated = false;

        /**
         * Contains error log on failure to allocate, compile, validate or link
         * @type {boolean}
         */
        this.errorLog = null;

        // Inputs for this program

        this.uniforms = {};
        this.samplers = {};
        this.attributes = {};

        // Shaders

        this._vertexShader = new XEO.renderer.webgl.Shader(gl, gl.VERTEX_SHADER, joinSansComments(vertex));
        this._fragmentShader = new XEO.renderer.webgl.Shader(gl, gl.FRAGMENT_SHADER, joinSansComments(fragment));

        if (!this._vertexShader.allocated) {
            this.errorLog = ["Vertex shader failed to allocate"].concat(this._vertexShader.errorLog);
            return;
        }

        if (!this._fragmentShader.allocated) {
            this.errorLog = ["Fragment shader failed to allocate"].concat(this._fragmentShader.errorLog);
            return;
        }

        this.allocated = true;

        if (!this._vertexShader.compiled) {
            this.errorLog = ["Vertex shader failed to compile"].concat(this._vertexShader.errorLog);
            return;
        }

        if (!this._fragmentShader.compiled) {
            this.errorLog = ["Fragment shader failed to compile"].concat(this._fragmentShader.errorLog);
            return;
        }

        this.compiled = true;


        var a, i, u, u_name, location, shader;

        // Program

        this.handle = gl.createProgram();

        if (!this.handle) {
            this.errorLog = ["Failed to allocate program"];
            return;
        }

        gl.attachShader(this.handle, this._vertexShader.handle);
        gl.attachShader(this.handle, this._fragmentShader.handle);

        gl.linkProgram(this.handle);

        this.linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);

        // HACK: Disable validation temporarily: https://github.com/xeolabs/xeoengine/issues/5
        // Perhaps we should defer validation until render-time, when the program has values set for all inputs?

        //this.validated = this.linked ? gl.getProgramParameter(this.handle, gl.VALIDATE_STATUS) : false;
        this.validated = true;

        if (!this.linked || !this.validated) {

            this.errorLog = [];

            this.errorLog.push("");
            this.errorLog.push(gl.getProgramInfoLog(this.handle));

            this.errorLog.push("\nVertex shader:\n");
            this.errorLog = this.errorLog.concat(vertex);

            this.errorLog.push("\nFragment shader:\n");
            this.errorLog = this.errorLog.concat(fragment);

            return;
        }


        // Discover uniforms and samplers

        var numUniforms = gl.getProgramParameter(this.handle, gl.ACTIVE_UNIFORMS);
        var valueIndex = 0;

        for (i = 0; i < numUniforms; ++i) {

            u = gl.getActiveUniform(this.handle, i);

            if (u) {

                u_name = u.name;

                if (u_name[u_name.length - 1] === "\u0000") {
                    u_name = u_name.substr(0, u_name.length - 1);
                }

                location = gl.getUniformLocation(this.handle, u_name);

                if ((u.type === gl.SAMPLER_2D) || (u.type === gl.SAMPLER_CUBE) || (u.type === 35682)) {

                    this.samplers[u_name] = new XEO.renderer.webgl.Sampler(gl, location);

                } else {

                    this.uniforms[u_name] = new XEO.renderer.webgl.Uniform(stats.frame, gl, u.type, location);
                }
            }
        }

        // Discover attributes

        var numAttribs = gl.getProgramParameter(this.handle, gl.ACTIVE_ATTRIBUTES);

        for (i = 0; i < numAttribs; i++) {

            a = gl.getActiveAttrib(this.handle, i);

            if (a) {

                location = gl.getAttribLocation(this.handle, a.name);

                this.attributes[a.name] = new XEO.renderer.webgl.Attribute(gl, location);
            }
        }

        this.allocated = true;
    };

    XEO.renderer.webgl.Program.prototype.bind = function () {

        if (!this.allocated) {
            return;
        }

        this.gl.useProgram(this.handle);
    };

    XEO.renderer.webgl.Program.prototype.setUniform = function (name, value) {

        if (!this.allocated) {
            return;
        }

        var u = this.uniforms[name];

        if (u) {
            u.setValue(value);
        }
    };

    XEO.renderer.webgl.Program.prototype.getUniform = function (name) {

        if (!this.allocated) {
            return;
        }

        return this.uniforms[name];
    };

    XEO.renderer.webgl.Program.prototype.getAttribute = function (name) {

        if (!this.allocated) {
            return;
        }

        return this.attributes[name];
    };

    XEO.renderer.webgl.Program.prototype.bindFloatArrayBuffer = function (name, buffer) {

        if (!this.allocated) {
            return;
        }

        return this.attributes[name];
    };

    XEO.renderer.webgl.Program.prototype.bindTexture = function (name, texture, unit) {

        if (!this.allocated) {
            return false;
        }

        var sampler = this.samplers[name];

        if (sampler) {
            return sampler.bindTexture(texture, unit);

        } else {
            return false;
        }
    };

    XEO.renderer.webgl.Program.prototype.destroy = function () {

        if (!this.allocated) {
            return;
        }

        this.gl.deleteProgram(this.handle);
        this.gl.deleteShader(this._vertexShader.handle);
        this.gl.deleteShader(this._fragmentShader.handle);

        this.handle = null;
        this.attributes = null;
        this.uniforms = null;
        this.samplers = null;

        this.allocated = false;
    };

})();
;(function () {

    "use strict";

    XEO.renderer.webgl.RenderBuffer = function (cfg) {

        /**
         * True as soon as this buffer is allocated and ready to go
         */
        this.allocated = false;

        /**
         * The HTMLCanvasElement
         */
        this.canvas = cfg.canvas;

        /**
         * WebGL context
         */
        this.gl = cfg.gl;

        /**
         * Buffer resources, set up in #_touch
         */
        this.buffer = null;

        /**
         * True while this buffer is bound
         */
        this.bound = false;

        /**
         * Optional explicit buffer size - when omitted, buffer defaults to canvas size
         */
        this.size = cfg.size;
    };

    /**
     * Sets custom dimensions for this buffer.
     *
     * Buffer dynamically re-sizes to canvas when size is null.
     *
     * @param size {Array of Number} Two-element size vector
     */
    XEO.renderer.webgl.RenderBuffer.prototype.setSize = function (size) {
        this.size = size;
    };

    /**
     * Called after WebGL context is restored.
     */
    XEO.renderer.webgl.RenderBuffer.prototype.webglRestored = function (gl) {
        this.gl = gl;
        this.buffer = null;
        this.allocated = false;
        this.bound = false;
    };

    /**
     * Binds this buffer
     */
    XEO.renderer.webgl.RenderBuffer.prototype.bind = function () {

        this._touch();

        if (this.bound) {
            return;
        }

        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buffer.framebuf);

        this.bound = true;
    };

    XEO.renderer.webgl.RenderBuffer.prototype._touch = function () {

        var width;
        var height;

        if (this.size) {

            // Buffer sized to custom dimensions

            width = this.size[0];
            height = this.size[1];

        } else {

            // Buffer sized to canvas (default)

            width = this.canvas.clientWidth;
            height = this.canvas.clientHeight;
        }

        if (this.buffer) {

            // Currently have a buffer

            if (this.buffer.width === width && this.buffer.height === height) {

                // Canvas size unchanged, buffer still good

                return;

            } else {

                // Buffer needs reallocation for new canvas size

                this.gl.deleteTexture(this.buffer.texture);
                this.gl.deleteFramebuffer(this.buffer.framebuf);
                this.gl.deleteRenderbuffer(this.buffer.renderbuf);
            }
        }

        this.buffer = {
            framebuf: this.gl.createFramebuffer(),
            renderbuf: this.gl.createRenderbuffer(),
            texture: this.gl.createTexture(),
            width: width,
            height: height
        };

        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buffer.framebuf);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.buffer.texture);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);


        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.buffer.renderbuf);
        this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, width, height);
        this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.buffer.texture, 0);
        this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this.buffer.renderbuf);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);

        // Verify framebuffer is OK
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buffer.framebuf);

        if (!this.gl.isFramebuffer(this.buffer.framebuf)) {
            throw "Invalid framebuffer";
        }
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);

        var status = this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);

        switch (status) {

            case this.gl.FRAMEBUFFER_COMPLETE:
                break;

            case this.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT";

            case this.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";

            case this.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS";

            case this.gl.FRAMEBUFFER_UNSUPPORTED:
                throw "Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED";

            default:
                throw "Incomplete framebuffer: " + status;
        }

        this.bound = false;
    };

    /**
     * Clears this renderbuffer
     */
    XEO.renderer.webgl.RenderBuffer.prototype.clear = function () {
        if (!this.bound) {
            throw "Render buffer not bound";
        }
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        this.gl.disable(this.gl.BLEND);
    };

    /**
     * Reads buffer pixel at given coordinates
     */
    XEO.renderer.webgl.RenderBuffer.prototype.read = function (pickX, pickY) {
        var x = pickX;
        var y = this.canvas.height - pickY;
        var pix = new Uint8Array(4);
        this.gl.readPixels(x, y, 1, 1, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pix);
        return pix;
    };

    /**
     * Unbinds this renderbuffer
     */
    XEO.renderer.webgl.RenderBuffer.prototype.unbind = function () {
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        this.bound = false;
    };

    /** Returns the texture
     */
    XEO.renderer.webgl.RenderBuffer.prototype.getTexture = function () {

        var self = this;

        return {

            renderBuffer: this,

            bind: function (unit) {
                if (self.buffer && self.buffer.texture) {
                    self.gl.activeTexture(self.gl["TEXTURE" + unit]);
                    self.gl.bindTexture(self.gl.TEXTURE_2D, self.buffer.texture);
                    return true;
                }
                return false;
            },

            unbind: function (unit) {
                if (self.buffer && self.buffer.texture) {
                    self.gl.activeTexture(self.gl["TEXTURE" + unit]);
                    self.gl.bindTexture(self.gl.TEXTURE_2D, null);
                }
            }
        };
    };

    /** Destroys this buffer
     */
    XEO.renderer.webgl.RenderBuffer.prototype.destroy = function () {

        if (this.allocated) {

            this.gl.deleteTexture(this.buffer.texture);
            this.gl.deleteFramebuffer(this.buffer.framebuf);
            this.gl.deleteRenderbuffer(this.buffer.renderbuf);

            this.allocated = false;
            this.buffer = null;
            this.bound = false;
        }
    };

})();
;(function () {

    "use strict";

    XEO.renderer.webgl.Sampler = function (gl, location) {

        this.bindTexture = function (texture, unit) {

            if (texture.bind(unit)) {

                gl.uniform1i(location, unit);

                return true;
            }

            return false;
        };
    };

})();;(function () {

    "use strict";

    /**
     * A vertex/fragment shader in a program
     *
     * @param gl WebGL gl
     * @param type gl.VERTEX_SHADER | gl.FRAGMENT_SHADER
     * @param source Source code for shader
     */
    XEO.renderer.webgl.Shader = function (gl, type, source) {

        /**
         * True if this shader successfully allocated. When false,
         * #error will contain WebGL the error log.
         * @type {boolean}
         */
        this.allocated = false;

        /**
         * True if this shader successfully compiled. When false,
         * #error will contain WebGL the error log.
         * @type {boolean}
         */
        this.compiled = false;

        /**
         * Saves the WebGL error log when this shader failed to allocate or compile.
         * @type {boolean}
         */
        this.errorLog = null;

        /**
         * The GLSL for this shader.
         * @type {Array of String}
         */
        this.source = source;

        /**
         * WebGL handle to this shader's GPU resource
         */
        this.handle = gl.createShader(type);

        if (!this.handle) {
            this.errorLog = [
                "Failed to allocate"
            ];
            return;
        }

        this.allocated = true;

        gl.shaderSource(this.handle, source);
        gl.compileShader(this.handle);

        this.compiled = gl.getShaderParameter(this.handle, gl.COMPILE_STATUS);

        if (!this.compiled) {

            if (!gl.isContextLost()) { // Handled explicitly elsewhere, so won't re-handle here

                this.errorLog = [];
                this.errorLog.push("");
                this.errorLog.push(gl.getShaderInfoLog(this.handle));
                this.errorLog = this.errorLog.concat(this.source);
            }
        }
    };

})();;(function () {

    "use strict";

    XEO.renderer.webgl.Texture2D = function (gl) {

        this.gl = gl;

        this.target = gl.TEXTURE_2D;

        this.texture = gl.createTexture();

        this.allocated = true;
    };

    XEO.renderer.webgl.Texture2D.prototype.setImage = function (image) {

        var gl = this.gl;

        gl.bindTexture(this.target, this.texture);

        //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

        gl.bindTexture(this.target, null);
    };

    XEO.renderer.webgl.Texture2D.prototype.setProps = function (cfg) {

        var gl = this.gl;

        gl.bindTexture(this.target, this.texture);

        if (cfg.minFilter) {

            var minFilter = this._getGLEnum(cfg.minFilter);

            if (minFilter) {

                gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, minFilter);

                if (minFilter === gl.NEAREST_MIPMAP_NEAREST ||
                    minFilter === gl.LINEAR_MIPMAP_NEAREST ||
                    minFilter === gl.NEAREST_MIPMAP_LINEAR ||
                    minFilter === gl.LINEAR_MIPMAP_LINEAR) {

                    gl.generateMipmap(this.target);
                }
            }
        }

        if (cfg.magFilter) {
            var magFilter = this._getGLEnum(cfg.magFilter);
            if (magFilter) {
                gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, magFilter);
            }
        }

        if (cfg.wrapS) {
            var wrapS = this._getGLEnum(cfg.wrapS);
            if (wrapS) {
                gl.texParameteri(this.target, gl.TEXTURE_WRAP_S, wrapS);
            }
        }

        if (cfg.wrapT) {
            var wrapT = this._getGLEnum(cfg.wrapT);
            if (wrapT) {
                gl.texParameteri(this.target, gl.TEXTURE_WRAP_T, wrapT);
            }
        }

        gl.bindTexture(this.target, null);
    };

    XEO.renderer.webgl.Texture2D.prototype._getGLEnum = function (name, defaultVal) {

        if (name === undefined) {
            return defaultVal;
        }

        var glName = XEO.renderer.webgl.enums[name];

        if (glName === undefined) {
            return defaultVal;
        }

        return this.gl[glName];
    };


    XEO.renderer.webgl.Texture2D.prototype.bind = function (unit) {

        if (!this.allocated) {
            return;
        }

        if (this.texture) {

            var gl = this.gl;

            gl.activeTexture(gl["TEXTURE" + unit]);

            gl.bindTexture(this.target, this.texture);

            return true;
        }

        return false;
    };

    XEO.renderer.webgl.Texture2D.prototype.unbind = function (unit) {

        if (!this.allocated) {
            return;
        }

        if (this.texture) {

            var gl = this.gl;

            gl.activeTexture(gl["TEXTURE" + unit]);

            gl.bindTexture(this.target, null);
        }
    };

    XEO.renderer.webgl.Texture2D.prototype.destroy = function () {

        if (!this.allocated) {
            return;
        }

        if (this.texture) {

            this.gl.deleteTexture(this.texture);

            this.texture = null;
        }
    };


    XEO.renderer.webgl.clampImageSize = function (image, numPixels) {

        var n = image.width * image.height;

        if (n > numPixels) {

            var ratio = numPixels / n;

            var width = image.width * ratio;
            var height = image.height * ratio;

            var canvas = document.createElement("canvas");

            canvas.width = XEO.renderer.webgl.nextHighestPowerOfTwo(width);
            canvas.height = XEO.renderer.webgl.nextHighestPowerOfTwo(height);

            var ctx = canvas.getContext("2d");

            ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);

            image = canvas;
        }

        return image;
    };

    XEO.renderer.webgl.ensureImageSizePowerOfTwo = function (image) {

        if (!XEO.renderer.webgl.isPowerOfTwo(image.width) || !XEO.renderer.webgl.isPowerOfTwo(image.height)) {

            var canvas = document.createElement("canvas");

            canvas.width = XEO.renderer.webgl.nextHighestPowerOfTwo(image.width);
            canvas.height = XEO.renderer.webgl.nextHighestPowerOfTwo(image.height);

            var ctx = canvas.getContext("2d");

            ctx.drawImage(image,
                0, 0, image.width, image.height,
                0, 0, canvas.width, canvas.height);
            image = canvas;
        }

        return image;
    };

    XEO.renderer.webgl.isPowerOfTwo = function (x) {
        return (x & (x - 1)) === 0;
    };

    XEO.renderer.webgl.nextHighestPowerOfTwo = function (x) {
        --x;
        for (var i = 1; i < 32; i <<= 1) {
            x = x | x >> i;
        }
        return x + 1;
    };

})();
;(function () {

    "use strict";

    XEO.renderer.webgl.Uniform = function (renderStats, gl, type, location) {

        var func = null;

        var value = null;

        if (type === gl.BOOL) {

            func = function (v) {
                if (value === v) {
                    renderStats.setUniformCacheHits++;
                    return;
                }
                value = v;
                gl.uniform1i(location, v);
                renderStats.setUniform++;
            };

        } else if (type === gl.BOOL_VEC2) {

            func = function (v) {
                if (value !== null && value[0] === v[0] && value[1] === v[1]) {
                    renderStats.setUniformCacheHits++;
                    return;
                }
                value = v;
                gl.uniform2iv(location, v);
                renderStats.setUniform++;
            };

        } else if (type === gl.BOOL_VEC3) {

            func = function (v) {
                if (value !== null && value[0] === v[0] && value[1] === v[1] && value[2] === v[2]) {
                    renderStats.setUniformCacheHits++;
                    return;
                }
                value = v;
                gl.uniform3iv(location, v);
                renderStats.setUniform++;
            };

        } else if (type === gl.BOOL_VEC4) {

            func = function (v) {
                if (value !== null && value[0] === v[0] && value[1] === v[1] && value[2] === v[2] && value[3] === v[3]) {
                    renderStats.setUniformCacheHits++;
                    return;
                }
                value = v;
                gl.uniform4iv(location, v);
                renderStats.setUniform++;
            };

        } else if (type === gl.INT) {

            func = function (v) {
                if (value === v) {
                    renderStats.setUniformCacheHits++;
                    return;
                }
                value = v;
                gl.uniform1iv(location, v);
                renderStats.setUniform++;
            };

        } else if (type === gl.INT_VEC2) {

            func = function (v) {
                if (value !== null && value[0] === v[0] && value[1] === v[1]) {
                    renderStats.setUniformCacheHits++;
                    return;
                }
                value = v;
                gl.uniform2iv(location, v);
                renderStats.setUniform++;
            };

        } else if (type === gl.INT_VEC3) {

            func = function (v) {
                if (value !== null && value[0] === v[0] && value[1] === v[1] && value[2] === v[2]) {
                    renderStats.setUniformCacheHits++;
                    return;
                }
                value = v;
                gl.uniform3iv(location, v);
                renderStats.setUniform++;
            };

        } else if (type === gl.INT_VEC4) {

            func = function (v) {
                if (value !== null && value[0] === v[0] && value[1] === v[1] && value[2] === v[2] && value[3] === v[3]) {
                    renderStats.setUniformCacheHits++;
                    return;
                }
                value = v;
                gl.uniform4iv(location, v);
                renderStats.setUniform++;
            };

        } else if (type === gl.FLOAT) {

            func = function (v) {
                if (value === v) {
                    renderStats.setUniformCacheHits++;
                    return;
                }
                value = v;
                gl.uniform1f(location, v);
                renderStats.setUniform++;
            };

        } else if (type === gl.FLOAT_VEC2) {

            func = function (v) {
                if (value !== null && value[0] === v[0] && value[1] === v[1]) {
                    renderStats.setUniformCacheHits++;
                    return;
                }
                value = v;
                gl.uniform2fv(location, v);
                renderStats.setUniform++;
            };

        } else if (type === gl.FLOAT_VEC3) {

            func = function (v) {
                if (value !== null && value[0] === v[0] && value[1] === v[1] && value[2] === v[2]) {
                    renderStats.setUniformCacheHits++;
                    return;
                }
                value = v;
                gl.uniform3fv(location, v);
                renderStats.setUniform++;
            };

        } else if (type === gl.FLOAT_VEC4) {

            func = function (v) {
                if (value !== null && value[0] === v[0] && value[1] === v[1] && value[2] === v[2] && value[3] === v[3]) {
                    renderStats.setUniformCacheHits++;
                    return;
                }
                value = v;
                gl.uniform4fv(location, v);
                renderStats.setUniform++;
            };

        } else if (type === gl.FLOAT_MAT2) {

            func = function (v) {
                gl.uniformMatrix2fv(location, gl.FALSE, v);
                renderStats.setUniform++;
            };

        } else if (type === gl.FLOAT_MAT3) {

            func = function (v) {
                gl.uniformMatrix3fv(location, gl.FALSE, v);
                renderStats.setUniform++;
            };

        } else if (type === gl.FLOAT_MAT4) {

            func = function (v) {
                gl.uniformMatrix4fv(location, gl.FALSE, v);
                renderStats.setUniform++;
            };

        } else {
            throw "Unsupported shader uniform type: " + type;
        }

        this.setValue = func;

        this.getLocation = function () {
            return location;
        };
    };

})();









;(function () {

    "use strict";

    /**
     * A chunk of WebGL state changes to render a XEO.renderer.State.
     *
     * @private
     */
    XEO.renderer.Chunk = function () {
    };

    /**
     * Initialises the chunk.
     *
     * @param {Number} id Chunk ID
     * @param {XEO.renderer.Program} program Program to render this chunk
     * @param {XEO.renderer.State} state The state rendered by this chunk
     */
    XEO.renderer.Chunk.prototype.init = function (id, program, state) {

        this.id = id;

        this.program = program;

        this.state = state;

        this.useCount = 0;

        if (this.build) {
            this.build();
        }
    };

})();
;(function () {

    "use strict";

    /**
     *  Manages creation, reuse and destruction of {@link XEO.renderer.Chunk}s.
     */
    XEO.renderer.ChunkFactory = function () {
        this.types = XEO.renderer.ChunkFactory.types;
    };

    /**
     * Sub-classes of {@link XEO.renderer.Chunk} provided by this factory
     */
    XEO.renderer.ChunkFactory.types = {};   // Supported chunk classes, installed by #createChunkType

    /**
     * Creates a chunk type.
     *
     * @param params Members to augment the chunk class prototype with
     * @param params.type Type name for the new chunk class
     * @param params.draw Method to render the chunk in draw render
     * @param params.pickObject
     * @param params.pickPrimitive
     */
    XEO.renderer.ChunkFactory.createChunkType = function (params) {

        if (!params.type) {
            throw "'type' expected in params";
        }

        var supa = XEO.renderer.Chunk;

        var chunkClass = function () { // Create the class
            this.useCount = 0;
            this.init.apply(this, arguments);
        };

        chunkClass.prototype = new supa();              // Inherit from base class
        chunkClass.prototype.constructor = chunkClass;

        XEO._apply(params, chunkClass.prototype);   // Augment subclass

        XEO.renderer.ChunkFactory.types[params.type] = {
            constructor: chunkClass,
            chunks: {},
            freeChunks: [],
            freeChunksLen: 0
        };

        return chunkClass;
    };

    /**
     * Gets a chunk from this factory.
     */
    XEO.renderer.ChunkFactory.prototype.getChunk = function (id, type, program, state) {

        var chunkType = this.types[type];

        if (!chunkType) {
            throw "chunk type not supported: '" + type + "'";
        }

        var chunk = chunkType.chunks[id];

        if (chunk) {
            chunk.useCount++;
            return chunk;
        }

        // Try to recycle a free chunk

        if (chunkType.freeChunksLen > 0) {
            chunk = chunkType.freeChunks[--chunkType.freeChunksLen];
        }

        if (chunk) {

            // Reinitialise the free chunk

            chunk.init(id, program, state);

        } else {

            // No free chunk, create a new one

            chunk = new chunkType.constructor(id, program, state);
        }

        chunk.useCount = 1;

        chunkType.chunks[id] = chunk;

        return chunk;
    };

    /**
     * Releases a chunk back to this factory.
     *
     * @param {XEO.renderer.Chunk} chunk Chunk to release
     */
    XEO.renderer.ChunkFactory.prototype.putChunk = function (chunk) {

        if (chunk.useCount === 0) { // In case of excess puts
            return;
        }

        // Free the chunk if use count now zero

        if (--chunk.useCount <= 0) {

            var chunkType = this.types[chunk.type];

            delete chunkType.chunks[chunk.id];

            chunkType.freeChunks[chunkType.freeChunksLen++] = chunk;
        }
    };

    /**
     * Restores the chunks in this factory after a WebGL context recovery.
     */
    XEO.renderer.ChunkFactory.prototype.webglRestored = function () {

        var types = this.types;
        var chunkType;
        var chunks;
        var chunk;

        for (var type in types) {

            if (types.hasOwnProperty(type)) {

                chunkType = types[type];

                chunks = chunkType.chunks;

                for (var id in chunks) {

                    if (chunks.hasOwnProperty(id)) {

                        chunk = chunks[id];

                        if (chunk.build) {
                            chunk.build();
                        }
                    }
                }
            }
        }
    };

})();
;(function () {

    "use strict";

    /**
     * Create display state chunk type for draw and pick render of user clipping planes
     */
    XEO.renderer.ChunkFactory.createChunkType({

        type: "clips",

        build: function () {

            this._uClipModeDraw = this._uClipModeDraw || [];
            this._uClipPlaneDraw = this._uClipPlaneDraw || [];

            var draw = this.program.draw;

            for (var i = 0, len = this.state.clips.length; i < len; i++) {
                this._uClipModeDraw[i] = draw.getUniform("xeo_uClipMode" + i);
                this._uClipPlaneDraw[i] = draw.getUniform("xeo_uClipPlane" + i)
            }

            this._uClipModePick = this._uClipModePick || [];
            this._uClipPlanePick = this._uClipPlanePick || [];

            var pick = this.program.pick;

            for (var i = 0, len = this.state.clips.length; i < len; i++) {
                this._uClipModePick[i] = pick.getUniform("xeo_uClipMode" + i);
                this._uClipPlanePick[i] = pick.getUniform("xeo_uClipPlane" + i)
            }
        },

        drawPick: function (frameCtx) {

            return;

            var uClipMode = (frameCtx.pick) ? this._uClipModePick : this._uClipModeDraw;
            var uClipPlane = (frameCtx.pick) ? this._uClipPlanePick : this._uClipPlaneDraw;

            var mode;
            var plane;
            var clips = this.state.clips;
            var clip;

            for (var i = 0, len = clips.length; i < len; i++) {

                mode = uClipMode[i];
                plane = uClipPlane[i];

                if (mode && plane) {

                    clip = clips[i];

                    if (clip.mode === "inside") {

                        mode.setValue(2);
                        plane.setValue(clip.plane);

                    } else if (clip.mode === "outside") {

                        mode.setValue(1);
                        plane.setValue(clip.plane);

                    } else {

                        // Disabled

                        mode.setValue(0);
                    }
                }
            }
        }
    });

})();;(function () {

    "use strict";

    /**
     *
     */
    XEO.renderer.ChunkFactory.createChunkType({

        type: "colorBuf",

        // Avoid re-application of this chunk after a program switch.

        programGlobal: true,

        draw: function (frameCtx) {

            if (!frameCtx.transparent) {

                // Blending forced while rendering a transparent bin

                var state = this.state;
                var blendEnabled = state.blendEnabled;

                var gl = this.program.gl;

                if (frameCtx.blendEnabled !== blendEnabled) {

                    if (blendEnabled) {
                        gl.enable(gl.BLEND);

                    } else {
                        gl.disable(gl.BLEND);
                    }

                    frameCtx.blendEnabled = blendEnabled;
                }

                var colorMask = state.colorMask;

                gl.colorMask(colorMask[0], colorMask[1], colorMask[2], colorMask[3]);
            }
        }
    });

})();
;(function () {

    "use strict";

    XEO.renderer.ChunkFactory.createChunkType({

        type: "cubemap",

        build: function () {
//            this._uCubeMapSampler = this._uCubeMapSampler || [];
//            this._uCubeMapIntensity = this._uCubeMapIntensity || [];
//            var layers = this.state.layers;
//            if (layers) {
//                var layer;
//                var draw = this.program.draw;
//                for (var i = 0, len = layers.length; i < len; i++) {
//                    layer = layers[i];
//                    this._uCubeMapSampler[i] = "xeo_uCubeMapSampler" + i;
//                    this._uCubeMapIntensity[i] = draw.getUniform("xeo_uCubeMapIntensity" + i);
//                }
//            }
        },

        draw: function (frameCtx) {
//            var layers = this.state.layers;
//            if (layers) {
//                var layer;
//                var draw = this.program.draw;
//                for (var i = 0, len = layers.length; i < len; i++) {
//                    layer = layers[i];
//                    if (this._uCubeMapSampler[i] && layer.texture) {
//                        draw.bindTexture(this._uCubeMapSampler[i], layer.texture, frameCtx.textureUnit++);
//                        if (this._uCubeMapIntensity[i]) {
//                            this._uCubeMapIntensity[i].setValue(layer.intensity);
//                        }
//                    }
//                }
//            }
//
//            if (frameCtx.textureUnit > 10) { // TODO: Find how many textures allowed
//                frameCtx.textureUnit = 0;
//            }
        }
    });

})();;(function () {

    "use strict";

    /**
     *
     */
    XEO.renderer.ChunkFactory.createChunkType({

        type: "depthBuf",

        // Avoid reapplication of this chunk after a program switch.

        programGlobal: true,

        draw: function (frameCtx) {

            var gl = this.program.gl;

            var state = this.state;
            var active = state.active;

            if (frameCtx.depthbufEnabled !== active) {

                if (!active) {
                    gl.enable(gl.DEPTH_TEST);

                } else {
                    gl.disable(gl.DEPTH_TEST);
                }

                frameCtx.depthbufEnabled = active;
            }

            var clearDepth = state.clearDepth;

            if (frameCtx.clearDepth !== clearDepth) {
                gl.clearDepth(clearDepth);
                frameCtx.clearDepth = clearDepth;
            }

            var depthFunc = state.depthFunc;

            if (frameCtx.depthFunc !== depthFunc) {
                gl.depthFunc(depthFunc);
                frameCtx.depthFunc = depthFunc;
            }

            if (state.clear) {
                gl.clear(gl.DEPTH_BUFFER_BIT);
            }
        }
    });

})();
;(function () {

    "use strict";

    XEO.renderer.ChunkFactory.createChunkType({

        type: "draw",

        // As we apply a list of state chunks in a {@link XEO.renderer.Renderer},
        // we track the ID of each chunk in order to avoid redundantly re-applying
        // the same chunk. We don't want that for draw chunks however, because
        // they contain drawElements calls, which we need to do for each object.

        unique: true,

        build: function () {
            this._uPickColorObject = this.program.pickObject.getUniform("xeo_uPickColor");
        },

        draw: function (frameCtx) {
            var state = this.state;
            var gl = this.program.gl;

            if (state.indices) {
                gl.drawElements(state.primitive, state.indices.numItems, state.indices.itemType, 0);
                frameCtx.drawElements++;
            }
        },

        pickObject: function (frameCtx) {

            var state = this.state;
            var gl = this.program.gl;

            if (this._uPickColorObject) {

                frameCtx.pickObjects[frameCtx.pickIndex++] = this.object;

                var b = frameCtx.pickIndex >> 16 & 0xFF;
                var g = frameCtx.pickIndex >> 8 & 0xFF;
                var r = frameCtx.pickIndex & 0xFF;

                this._uPickColorObject.setValue([r / 255, g / 255, b / 255, 1]);

                //frameCtx.pickIndex++
            }

            if (state.indices) {
                gl.drawElements(state.primitive, state.indices.numItems, state.indices.itemType, 0);
                frameCtx.drawElements++;
            }
        },

        pickPrimitive: function () {

            var state = this.state;
            var gl= this.program.gl;

            var pickIndices = state.getPickIndices();

            if (pickIndices) {
                gl.drawElements(state.primitive, pickIndices.numItems, pickIndices.itemType, 0);
            }
        }
    });

})();
;(function () {

    "use strict";

    /**
     *  Create display state chunk type for draw and pick render of geometry
     */
    XEO.renderer.ChunkFactory.createChunkType({

        type: "geometry",

        build: function () {

            var draw = this.program.draw;
            this._aPositionDraw = draw.getAttribute("xeo_aPosition");
            this._aNormalDraw = draw.getAttribute("xeo_aNormal");
            this._aUVDraw = draw.getAttribute("xeo_aUV");
            this._aTangentDraw = draw.getAttribute("xeo_aTangent");
            this._aColorDraw = draw.getAttribute("xeo_aColor");

            var pickObject = this.program.pickObject;
            this._aPositionPickObject = pickObject.getAttribute("xeo_aPosition");

            var pickPrimitive = this.program.pickPrimitive;
            this._aPositionPickPrimitive = pickPrimitive.getAttribute("xeo_aPosition");
            this._aColorPickPrimitive = pickPrimitive.getAttribute("xeo_aColor");
        },

        draw: function (frameCtx) {

            var state = this.state;

            if (this._aPositionDraw) {
                this._aPositionDraw.bindFloatArrayBuffer(state.positions);
                frameCtx.bindArray++;
            }

            if (this._aNormalDraw) {
                this._aNormalDraw.bindFloatArrayBuffer(state.normals);
                frameCtx.bindArray++;
            }

            if (this._aUVDraw) {
                this._aUVDraw.bindFloatArrayBuffer(state.uv);
                frameCtx.bindArray++;
            }

            if (this._aColorDraw) {
                this._aColorDraw.bindFloatArrayBuffer(state.colors);
                frameCtx.bindArray++;
            }

            if (this._aTangentDraw) {

                // Tangents array is lazy-built from UVs and normals,
                // now that we know that we need it

                this._aTangentDraw.bindFloatArrayBuffer(state.getTangents());
                frameCtx.bindArray++;
            }

            if (state.indices) {
                state.indices.bind();
                frameCtx.bindArray++;
            }
        },

        pickObject: function () {

            var state = this.state;

            if (this._aPositionPickObject) {
                this._aPositionPickObject.bindFloatArrayBuffer(state.positions);
            }

            if (state.indices) {
                state.indices.bind();
            }
        },

        pickPrimitive: function () {

            var state = this.state;

            // Arrays for primitive-picking are lazy-built
            // now that we know we need them

            if (this._aPositionPickPrimitive) {
                this._aPositionPickPrimitive.bindFloatArrayBuffer(state.getPickPositions());
            }

            if (this._aColorPickPrimitive) {
                this._aColorPickPrimitive.bindFloatArrayBuffer(state.getPickColors());
            }

            var pickIndices = state.getPickIndices();

            if (pickIndices) {
                pickIndices.bind();
            }
        }
    });

})();;(function () {

    "use strict";

    XEO.renderer.ChunkFactory.createChunkType({

        type: "lights",

        build: function () {

            this._uLightAmbientColor = this._uLightAmbientColor || [];
            this._uLightAmbientIntensity = this._uLightAmbientIntensity || [];

            this._uLightColor = this._uLightColor || [];
            this._uLightIntensity = this._uLightIntensity || [];

            this._uLightDir = this._uLightDir || [];
            this._uLightPos = this._uLightPos || [];

            this._uLightAttenuation = this._uLightAttenuation || [];

            var lights = this.state.lights;
            var program = this.program;

            for (var i = 0, len = lights.length; i < len; i++) {

                switch (lights[i].type) {

                    case "ambient":
                        this._uLightAmbientColor[i] = program.draw.getUniform("xeo_uLightAmbientColor");
                        this._uLightAmbientIntensity[i] = program.draw.getUniform("xeo_uLightAmbientIntensity");
                        break;

                    case "dir":
                        this._uLightColor[i] = program.draw.getUniform("xeo_uLightColor" + i);
                        this._uLightIntensity[i] = program.draw.getUniform("xeo_uLightIntensity" + i);
                        this._uLightPos[i] = null;
                        this._uLightDir[i] = program.draw.getUniform("xeo_uLightDir" + i);
                        break;

                    case "point":
                        this._uLightColor[i] = program.draw.getUniform("xeo_uLightColor" + i);
                        this._uLightIntensity[i] = program.draw.getUniform("xeo_uLightIntensity" + i);
                        this._uLightPos[i] = program.draw.getUniform("xeo_uLightPos" + i);
                        this._uLightDir[i] = null;
                        this._uLightAttenuation[i] = program.draw.getUniform("xeo_uLightAttenuation" + i);
                        break;
                }
            }
        },

        draw: function () {

            var lights = this.state.lights;
            var light;

            var gl = this.program.gl;

            for (var i = 0, len = lights.length; i < len; i++) {

                light = lights[i];

                // Ambient color

                if (this._uLightAmbientColor[i]) {
                    this._uLightAmbientColor[i].setValue(light.color);

                    if (this._uLightAmbientIntensity[i]) {
                        this._uLightAmbientIntensity[i].setValue(light.intensity);
                    }

                } else {

                    // Color and intensity

                    if (this._uLightColor[i]) {
                        this._uLightColor[i].setValue(light.color);
                    }

                    if (this._uLightIntensity[i]) {
                        this._uLightIntensity[i].setValue(light.intensity);
                    }

                    if (this._uLightPos[i]) {

                        // Position

                        this._uLightPos[i].setValue(light.pos);

                        // Attenuation

                        if (this._uLightAttenuation[i]) {
                            this._uLightAttenuation[i].setValue(light.attenuation);
                        }
                    }

                    // Direction

                    if (this._uLightDir[i]) {
                        this._uLightDir[i].setValue(light.dir);
                    }
                }
            }
        }
    });

})();
;(function () {

    "use strict";

    XEO.renderer.ChunkFactory.createChunkType({

        type: "modelTransform",

        build: function () {
            this._uModelMatrixDraw = this.program.draw.getUniform("xeo_uModelMatrix");
            this._uModelNormalMatrixDraw = this.program.draw.getUniform("xeo_uModelNormalMatrix");
            this._uModelMatrixPickObject = this.program.pickObject.getUniform("xeo_uModelMatrix");
            this._uModelMatrixPickPrimitive = this.program.pickPrimitive.getUniform("xeo_uModelMatrix");
        },

        draw: function () {
            if (this._uModelMatrixDraw) {
                this._uModelMatrixDraw.setValue(this.state.matrix);
            }
            if (this._uModelNormalMatrixDraw) {
                this._uModelNormalMatrixDraw.setValue(this.state.normalMatrix);
            }
        },

        pickObject: function () {
            if (this._uModelMatrixPickObject) {
                this._uModelMatrixPickObject.setValue(this.state.matrix);
            }
        },

        pickPrimitive: function () {
            if (this._uModelMatrixPickPrimitive) {
                this._uModelMatrixPickPrimitive.setValue(this.state.matrix);
            }
        }
    });

})();;(function () {

    "use strict";

    XEO.renderer.ChunkFactory.createChunkType({

        type: "modes",

        build: function () {
        },

        draw: function (frameCtx) {

            var state = this.state;
            var gl = this.program.gl;

            var backfaces = state.backfaces;

            if (frameCtx.backfaces !== backfaces) {
                if (backfaces) {
                    gl.disable(gl.CULL_FACE);
                } else {
                    gl.enable(gl.CULL_FACE);
                }
                frameCtx.backfaces = backfaces;
            }

            var frontface = state.frontface;

            if (frameCtx.frontface !== frontface) {

                // frontface is boolean for speed,
                // true == "ccw", false == "cw"

                if (frontface) {
                    gl.frontFace(gl.CCW);
                } else {
                    gl.frontFace(gl.CW);
                }
                frameCtx.frontface = frontface;
            }

            var transparent = state.transparent;

            if (frameCtx.transparent !== transparent) {
                if (!frameCtx.pick) {
                    if (transparent) {

                        // Entering a transparency bin

                        gl.enable(gl.BLEND);
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                        frameCtx.blendEnabled = true;
                    } else {

                        // Leaving a transparency bin

                        gl.disable(gl.BLEND);
                        frameCtx.blendEnabled = false;
                    }
                }
                frameCtx.transparent = transparent;
            }
        },

        pickObject: function (frameCtx) {

            var state = this.state;
            var gl = this.program.gl;

            var backfaces = state.backfaces;
            if (frameCtx.backfaces !== backfaces) {
                if (backfaces) {
                    gl.disable(gl.CULL_FACE);
                } else {
                    gl.enable(gl.CULL_FACE);
                }
                frameCtx.backfaces = backfaces;
            }

            var frontface = state.frontface;
            if (frameCtx.frontface !== frontface) {

                // frontface is boolean for speed,
                // true == "ccw", false == "cw"

                if (frontface) {
                    gl.frontFace(gl.CCW);
                } else {
                    gl.frontFace(gl.CW);
                }
                frameCtx.frontface = frontface;
            }
        },

        pickPrimitive: function (frameCtx) {

            var state = this.state;
            var gl = this.program.gl;

            var backfaces = state.backfaces;
            if (frameCtx.backfaces !== backfaces) {
                if (backfaces) {
                    gl.disable(gl.CULL_FACE);
                } else {
                    gl.enable(gl.CULL_FACE);
                }
                frameCtx.backfaces = backfaces;
            }

            var frontface = state.frontface;
            if (frameCtx.frontface !== frontface) {

                // frontface is boolean for speed,
                // true == "ccw", false == "cw"

                if (frontface) {
                    gl.frontFace(gl.CCW);
                } else {
                    gl.frontFace(gl.CW);
                }
                frameCtx.frontface = frontface;
            }
        }
    });
})();
;(function () {

    "use strict";

    XEO.renderer.ChunkFactory.createChunkType({

        type: "pbrMaterial",

        build: function () {

            var state = this.state;

            var draw = this.program.draw;

            this._uMetallic = draw.getUniform("xeo_uMetallic");

            this._uMaterialColor = draw.getUniform("xeo_uMaterialColor");

            if (state.colorMap) {
                this._uMaterialColorMap = draw.getUniform("xeo_uMaterialColorMap");
                this._uMaterialColorMapMatrix = draw.getUniform("xeo_uMaterialColorMapMatrix");
            }

            this._uMaterialEmissive = draw.getUniform("xeo_uEmissive");

            if (state.emissiveMap) {
                this._uEmissiveMap = draw.getUniform("xeo_uMaterialEmissiveMap");
                this._uMaterialEmissiveMapMatrix = draw.getUniform("xeo_uMaterialEmissiveMapMatrix");
            }

            this._uOpacity = draw.getUniform("xeo_uOpacity");

            if (state.opacityMap) {
                this._uMaterialOpacityMap = draw.getUniform("xeo_uMaterialOpacityMap");
                this._uMaterialOpacityMapMatrix = draw.getUniform("xeo_uMaterialOpacityMapMatrix");
            }

            this._uMaterialRoughness = draw.getUniform("xeo_uMaterialRoughness");

            if (state.roughnessMap) {
                this._uMaterialRoughnessMap = draw.getUniform("xeo_uMaterialRoughnessMap");
                this._uMaterialRoughnessMapMatrix = draw.getUniform("xeo_uMaterialRoughnessMapMatrix");
            }

            if (state.normalMap) {
                this._uMaterialNormalMap = draw.getUniform("xeo_uMaterialNormalMap");
                this._uMaterialNormalMapMatrix = draw.getUniform("xeo_uMaterialNormalMapMatrix");
            }

            this._uMaterialSpecular = draw.getUniform("xeo_uSpecular");

            if (state.specularMap) {
                this._uMaterialSpecularMap = draw.getUniform("xeo_uMaterialSpecularMap");
                this._uMaterialSpecularMapMatrix = draw.getUniform("xeo_uMaterialSpecularMapMatrix");
            }
        },

        draw: function (frameCtx) {

            //     frameCtx.textureUnit = 0;

            var draw = this.program.draw;
            var state = this.state;

            if (this._uMetallic) {
                this._uMetallic.setValue(state.metallic);
            }

            // Base color

            if (this._uMaterialColor) {
                this._uMaterialColor.setValue(state.color);
            }

            if ( this._uMaterialColorMap) {

                draw.bindTexture(this._uMaterialColorMap, state.colorMap.texture, frameCtx.textureUnit++);

                if (this._uMaterialColorMapMatrix) {
                    this._uMaterialColorMapMatrix.setValue(state.colorMap.matrix);
                }
            }

            // Emissive color

            if (this._uMaterialEmissive) {
                this._uMaterialEmissive.setValue(state.emissive);
            }

            if (this._uEmissiveMap) {

                draw.bindTexture(this._uEmissiveMap, state.emissiveMap.texture, frameCtx.textureUnit++);

                if (this._uMaterialEmissiveMapMatrix) {
                    this._uMaterialEmissiveMapMatrix.setValue(state.emissiveMap.matrix);
                }
            }

            // Opacity 

            if (this._uOpacity) {
                this._uOpacity.setValue(state.opacity);
            }

            if (this._uMaterialOpacityMap) {

                draw.bindTexture(this._uMaterialOpacityMap, state.opacityMap.texture, frameCtx.textureUnit++);

                if (this._uMaterialOpacityMapMatrix) {
                    this._uMaterialOpacityMapMatrix.setValue(state.opacityMap.matrix);
                }
            }

            // Roughness

            if (this._uMaterialRoughness) {
                this._uMaterialRoughness.setValue(state.roughness);
            }

            if (this._uMaterialRoughnessMap) {

                draw.bindTexture(this._uMaterialRoughnessMap, state.roughnessMap.texture, frameCtx.textureUnit++);

                if (this._uMaterialRoughnessMapMatrix) {
                    this._uMaterialRoughnessMapMatrix.setValue(state.roughnessMap.matrix);
                }
            }

            // Normal map

            if (this._uMaterialNormalMap) {

                draw.bindTexture(this._uMaterialNormalMap, state.normalMap.texture, frameCtx.textureUnit++);

                if (this._uMaterialNormalMapMatrix) {
                    this._uMaterialNormalMapMatrix.setValue(state.normalMap.matrix);
                }
            }

            // Specular 

            if (this._uMaterialSpecular) {
                this._uMaterialSpecular.setValue(state.specular);
            }

            if (this._uMaterialSpecularMap) {

                draw.bindTexture(this._uMaterialSpecularMap, state.specularMap.texture, frameCtx.textureUnit++);

                if (this._uMaterialSpecularMapMatrix) {
                    this._uMaterialSpecularMapMatrix.setValue(state.specularMap.matrix);
                }
            }


            //if (frameCtx.textureUnit > 10) { // TODO: Find how many textures allowed
            //    frameCtx.textureUnit = 0;
            //}
        }
    });

})();
;(function () {

    "use strict";

    XEO.renderer.ChunkFactory.createChunkType({

        type: "phongMaterial",

        build: function () {

            var state = this.state;

            var draw = this.program.draw;

            // Blinn-Phong base material

            this._uDiffuse = draw.getUniform("xeo_uDiffuse");
            this._uSpecular = draw.getUniform("xeo_uSpecular");
            this._uEmissive = draw.getUniform("xeo_uEmissive");
            this._uOpacity = draw.getUniform("xeo_uOpacity");
            this._uShininess = draw.getUniform("xeo_uShininess");

            this._uPointSize = draw.getUniform("xeo_uPointSize");

            // Textures

            if (state.ambientMap) {
                this._uAmbientMap = "xeo_uAmbientMap";
                this._uAmbientMapMatrix = draw.getUniform("xeo_uAmbientMapMatrix");
            }

            if (state.diffuseMap) {
                this._uDiffuseMap = "xeo_uDiffuseMap";
                this._uDiffuseMapMatrix = draw.getUniform("xeo_uDiffuseMapMatrix");
            }

            if (state.specularMap) {
                this._uSpecularMap = "xeo_uSpecularMap";
                this._uSpecularMapMatrix = draw.getUniform("xeo_uSpecularMapMatrix");
            }

            if (state.emissiveMap) {
                this._uEmissiveMap = "xeo_uEmissiveMap";
                this._uEmissiveMapMatrix = draw.getUniform("xeo_uEmissiveMapMatrix");
            }

            if (state.opacityMap) {
                this._uOpacityMap = "xeo_uOpacityMap";
                this._uOpacityMapMatrix = draw.getUniform("xeo_uOpacityMapMatrix");
            }

            if (state.reflectivityMap) {
                this._uReflectivityMap = "xeo_uReflectivityMap";
                this._uReflectivityMapMatrix = draw.getUniform("xeo_uReflectivityMapMatrix");
            }

            if (state.normalMap) {
                this._uBumpMap = "xeo_uNormalMap";
                this._uBumpMapMatrix = draw.getUniform("xeo_uNormalMapMatrix");
            }

            // Fresnel effects

            if (state.diffuseFresnel) {
                this._uDiffuseFresnelEdgeBias = draw.getUniform("xeo_uDiffuseFresnelEdgeBias");
                this._uDiffuseFresnelCenterBias = draw.getUniform("xeo_uDiffuseFresnelCenterBias");
                this._uDiffuseFresnelEdgeColor = draw.getUniform("xeo_uDiffuseFresnelEdgeColor");
                this._uDiffuseFresnelCenterColor = draw.getUniform("xeo_uDiffuseFresnelCenterColor");
                this._uDiffuseFresnelPower = draw.getUniform("xeo_uDiffuseFresnelPower");
            }

            if (state.specularFresnel) {
                this._uSpecularFresnelEdgeBias = draw.getUniform("xeo_uSpecularFresnelEdgeBias");
                this._uSpecularFresnelCenterBias = draw.getUniform("xeo_uSpecularFresnelCenterBias");
                this._uSpecularFresnelEdgeColor = draw.getUniform("xeo_uSpecularFresnelEdgeColor");
                this._uSpecularFresnelCenterColor = draw.getUniform("xeo_uSpecularFresnelCenterColor");
                this._uSpecularFresnelPower = draw.getUniform("xeo_uSpecularFresnelPower");
            }

            if (state.opacityFresnel) {
                this._uOpacityFresnelEdgeBias = draw.getUniform("xeo_uOpacityFresnelEdgeBias");
                this._uOpacityFresnelCenterBias = draw.getUniform("xeo_uOpacityFresnelCenterBias");
                this._uOpacityFresnelEdgeColor = draw.getUniform("xeo_uOpacityFresnelEdgeColor");
                this._uOpacityFresnelCenterColor = draw.getUniform("xeo_uOpacityFresnelCenterColor");
                this._uOpacityFresnelPower = draw.getUniform("xeo_uOpacityFresnelPower");
            }

            if (state.reflectivityFresnel) {
                this._uReflectivityFresnelEdgeBias = draw.getUniform("xeo_uReflectivityFresnelEdgeBias");
                this._uReflectivityFresnelCenterBias = draw.getUniform("xeo_uReflectivityFresnelCenterBias");
                this._uReflectivityFresnelEdgeColor = draw.getUniform("xeo_uReflectivityFresnelEdgeColor");
                this._uReflectivityFresnelCenterColor = draw.getUniform("xeo_uReflectivityFresnelCenterColor");
                this._uReflectivityFresnelPower = draw.getUniform("xeo_uReflectivityFresnelPower");
            }

            if (state.emissiveFresnel) {
                this._uEmissiveFresnelEdgeBias = draw.getUniform("xeo_uEmissiveFresnelEdgeBias");
                this._uEmissiveFresnelCenterBias = draw.getUniform("xeo_uEmissiveFresnelCenterBias");
                this._uEmissiveFresnelEdgeColor = draw.getUniform("xeo_uEmissiveFresnelEdgeColor");
                this._uEmissiveFresnelCenterColor = draw.getUniform("xeo_uEmissiveFresnelCenterColor");
                this._uEmissiveFresnelPower = draw.getUniform("xeo_uEmissiveFresnelPower");
            }
        },

        draw: function (frameCtx) {

            var draw = this.program.draw;
            var state = this.state;
            var gl = this.program.gl;


            if (this._uShininess) {
                this._uShininess.setValue(state.shininess);
            }

            if (frameCtx.lineWidth != state.lineWidth) {
                gl.lineWidth(state.lineWidth);
                frameCtx.lineWidth = state.lineWidth;
            }

            if (this._uPointSize) {
                this._uPointSize.setValue(state.pointSize);
            }

            // Ambient map

            if (state.ambientMap && state.ambientMap.texture) {

                draw.bindTexture(this._uAmbientMap, state.ambientMap.texture, (frameCtx.textureUnit < 8 ? frameCtx.textureUnit++ : frameCtx.textureUnit = 0));
                frameCtx.bindTexture++;

                if (this._uAmbientMapMatrix) {
                    this._uAmbientMapMatrix.setValue(state.ambientMap.matrix);
                }
            }

            // Diffuse map

            if (state.diffuseMap && state.diffuseMap.texture) {

                draw.bindTexture(this._uDiffuseMap, state.diffuseMap.texture, (frameCtx.textureUnit < 8 ? frameCtx.textureUnit++ : frameCtx.textureUnit = 0));
                frameCtx.bindTexture++;

                if (this._uDiffuseMapMatrix) {
                    this._uDiffuseMapMatrix.setValue(state.diffuseMap.matrix);
                }

            } else if (this._uDiffuse) {
                this._uDiffuse.setValue(state.diffuse);
            }

            // Specular map

            if (state.specularMap && state.specularMap.texture) {

                draw.bindTexture(this._uSpecularMap, state.specularMap.texture, (frameCtx.textureUnit < 8 ? frameCtx.textureUnit++ : frameCtx.textureUnit = 0));
                frameCtx.bindTexture++;

                if (this._uSpecularMapMatrix) {
                    this._uSpecularMapMatrix.setValue(state.specularMap.matrix);
                }

            } else if (this._uSpecular) {
                this._uSpecular.setValue(state.specular);
            }

            // Emissive map

            if (state.emissiveMap && state.emissiveMap.texture) {

                draw.bindTexture(this._uEmissiveMap, state.emissiveMap.texture, (frameCtx.textureUnit < 8 ? frameCtx.textureUnit++ : frameCtx.textureUnit = 0));
                frameCtx.bindTexture++;

                if (this._uEmissiveMapMatrix) {
                    this._uEmissiveMapMatrix.setValue(state.emissiveMap.matrix);
                }

            } else if (this._uEmissive) {
                this._uEmissive.setValue(state.emissive);
            }

            // Opacity map

            if (state.opacityMap && state.opacityMap.texture) {

                draw.bindTexture(this._uOpacityMap, state.opacityMap.texture, (frameCtx.textureUnit < 8 ? frameCtx.textureUnit++ : frameCtx.textureUnit = 0));
                frameCtx.bindTexture++;

                if (this._uOpacityMapMatrix) {
                    this._uOpacityMapMatrix.setValue(state.opacityMap.matrix);
                }

            } else if (this._uOpacity) {
                this._uOpacity.setValue(state.opacity);
            }

            // Reflectivity map

            if (state.reflectivityMap && state.reflectivityMap.texture) {

                draw.bindTexture(this._uReflectivityMap, state.reflectivityMap.texture, (frameCtx.textureUnit < 8 ? frameCtx.textureUnit++ : frameCtx.textureUnit = 0));

                if (this._uReflectivityMapMatrix) {
                    this._uReflectivityMapMatrix.setValue(state.reflectivityMap.matrix);
                }
            }

            // Bump map

            if (state.bumpMap && state.bumpMap.texture) {

                draw.bindTexture(this._uBumpMap, state.normalMap.texture, (frameCtx.textureUnit < 8 ? frameCtx.textureUnit++ : frameCtx.textureUnit = 0));
                frameCtx.bindTexture++;

                if (this._uBumpMapMatrix) {
                    this._uBumpMapMatrix.setValue(state.normalMap.matrix);
                }
            }

            // Fresnel effects

            if (state.diffuseFresnel) {

                if (this._uDiffuseFresnelEdgeBias) {
                    this._uDiffuseFresnelEdgeBias.setValue(state.diffuseFresnel.edgeBias);
                }

                if (this._uDiffuseFresnelCenterBias) {
                    this._uDiffuseFresnelCenterBias.setValue(state.diffuseFresnel.centerBias);
                }

                if (this._uDiffuseFresnelEdgeColor) {
                    this._uDiffuseFresnelEdgeColor.setValue(state.diffuseFresnel.edgeColor);
                }

                if (this._uDiffuseFresnelCenterColor) {
                    this._uDiffuseFresnelCenterColor.setValue(state.diffuseFresnel.centerColor);
                }

                if (this._uDiffuseFresnelPower) {
                    this._uDiffuseFresnelPower.setValue(state.diffuseFresnel.power);
                }
            }

            if (state.specularFresnel) {

                if (this._uSpecularFresnelEdgeBias) {
                    this._uSpecularFresnelEdgeBias.setValue(state.specularFresnel.edgeBias);
                }

                if (this._uSpecularFresnelCenterBias) {
                    this._uSpecularFresnelCenterBias.setValue(state.specularFresnel.centerBias);
                }

                if (this._uSpecularFresnelEdgeColor) {
                    this._uSpecularFresnelEdgeColor.setValue(state.specularFresnel.edgeColor);
                }

                if (this._uSpecularFresnelCenterColor) {
                    this._uSpecularFresnelCenterColor.setValue(state.specularFresnel.centerColor);
                }

                if (this._uSpecularFresnelPower) {
                    this._uSpecularFresnelPower.setValue(state.specularFresnel.power);
                }
            }

            if (state.opacityFresnel) {

                if (this._uOpacityFresnelEdgeBias) {
                    this._uOpacityFresnelEdgeBias.setValue(state.opacityFresnel.edgeBias);
                }

                if (this._uOpacityFresnelCenterBias) {
                    this._uOpacityFresnelCenterBias.setValue(state.opacityFresnel.centerBias);
                }

                if (this._uOpacityFresnelEdgeColor) {
                    this._uOpacityFresnelEdgeColor.setValue(state.opacityFresnel.edgeColor);
                }

                if (this._uOpacityFresnelCenterColor) {
                    this._uOpacityFresnelCenterColor.setValue(state.opacityFresnel.centerColor);
                }

                if (this._uOpacityFresnelPower) {
                    this._uOpacityFresnelPower.setValue(state.opacityFresnel.power);
                }
            }

            if (state.reflectivityFresnel) {

                if (this._uReflectivityFresnelEdgeBias) {
                    this._uReflectivityFresnelEdgeBias.setValue(state.reflectivityFresnel.edgeBias);
                }

                if (this._uReflectivityFresnelCenterBias) {
                    this._uReflectivityFresnelCenterBias.setValue(state.reflectivityFresnel.centerBias);
                }

                if (this._uReflectivityFresnelEdgeColor) {
                    this._uReflectivityFresnelEdgeColor.setValue(state.reflectivityFresnel.edgeColor);
                }

                if (this._uReflectivityFresnelCenterColor) {
                    this._uReflectivityFresnelCenterColor.setValue(state.reflectivityFresnel.centerColor);
                }

                if (this._uReflectivityFresnelPower) {
                    this._uReflectivityFresnelPower.setValue(state.reflectivityFresnel.power);
                }
            }

            if (state.emissiveFresnel) {

                if (this._uEmissiveFresnelEdgeBias) {
                    this._uEmissiveFresnelEdgeBias.setValue(state.emissiveFresnel.edgeBias);
                }

                if (this._uEmissiveFresnelCenterBias) {
                    this._uEmissiveFresnelCenterBias.setValue(state.emissiveFresnel.centerBias);
                }

                if (this._uEmissiveFresnelEdgeColor) {
                    this._uEmissiveFresnelEdgeColor.setValue(state.emissiveFresnel.edgeColor);
                }

                if (this._uEmissiveFresnelCenterColor) {
                    this._uEmissiveFresnelCenterColor.setValue(state.emissiveFresnel.centerColor);
                }

                if (this._uEmissiveFresnelPower) {
                    this._uEmissiveFresnelPower.setValue(state.emissiveFresnel.power);
                }
            }
        }
    });

})();
;(function () {

    "use strict";

    XEO.renderer.ChunkFactory.createChunkType({

        type: "program",

        build: function () {
        },

        draw: function (frameCtx) {
            this.program.draw.bind();
            frameCtx.useProgram++;
        },

        pickObject: function () {
            this.program.pickObject.bind();
        },

        pickPrimitive: function () {
            this.program.pickPrimitive.bind();
        }
    });
})();



;(function () {

    "use strict";

    XEO.renderer.ChunkFactory.createChunkType({

        type: "projTransform",

        build: function () {
            this._uProjMatrixDraw = this.program.draw.getUniform("xeo_uProjMatrix");
            this._uProjMatrixPickObject = this.program.pickObject.getUniform("xeo_uProjMatrix");
            this._uProjMatrixPickPrimitive = this.program.pickPrimitive.getUniform("xeo_uProjMatrix");
        },

        draw: function () {
            if (this._uProjMatrixDraw) {
                this._uProjMatrixDraw.setValue(this.state.matrix);
            }
        },

        pickObject: function () {
            if (this._uProjMatrixPickObject) {
                this._uProjMatrixPickObject.setValue(this.state.matrix);
            }
        },

        pickPrimitive: function () {
            if (this._uProjMatrixPickPrimitive) {
                this._uProjMatrixPickPrimitive.setValue(this.state.matrix);
            }
        }
    });

})();;(function () {

    "use strict";

    /**
     *   Create display state chunk type for draw and pick render of renderTarget
     */
    XEO.renderer.ChunkFactory.createChunkType({

        type: "renderTarget",

        // Avoid reapplication of this chunk type after a program switch.

        programGlobal: true,

        draw: function (frameCtx) {

            var gl = this.program.gl;
            var state = this.state;

            // Flush and unbind any render buffer already bound

            if (frameCtx.renderBuf) {
                gl.flush();
                frameCtx.renderBuf.unbind();
                frameCtx.renderBuf = null;
            }

            // Set depthMode false and bail if no render buffer for this chunk
            var renderBuf = state.renderBuf;
            if (!renderBuf) {
                frameCtx.depthMode = false;
                return;
            }

            // Bind this chunk's render buffer, set depthMode, enable blend if depthMode false, clear buffer
            renderBuf.bind();

            frameCtx.depthMode = (state.type === state.DEPTH);

            if (frameCtx.blendEnabled && !frameCtx.depthMode) {
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            }

            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.clearColor(frameCtx.ambientColor[0], frameCtx.ambientColor[1], frameCtx.ambientColor[2], 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

            frameCtx.renderBuf = renderBuf;
        }
    });

})();;(function () {

    "use strict";

    XEO.renderer.ChunkFactory.createChunkType({

        type: "shader",

        draw: function () {

            var params = this.state.params;

            if (params) {

                var program = this.program.draw;
                var name;

                for (name in params) {
                    if (params.hasOwnProperty(name)) {
                        program.setUniform(name, params[name]);
                    }
                }
            }
        }
    });
})();;(function () {

    "use strict";

    XEO.renderer.ChunkFactory.createChunkType({

        type: "shaderParams",

        draw: function (frameCtx) {

            var params = this.state.params;

            if (params) {

                var program = this.program.draw;
                var name;

                for (name in params) {
                    if (params.hasOwnProperty(name)) {
                        program.setUniform(name, params[name]);
                    }
                }
            }
        }
    });

})();;(function () {

    "use strict";

    XEO.renderer.ChunkFactory.createChunkType({

        type: "viewTransform",

        build: function () {
            this._uViewMatrixDraw = this.program.draw.getUniform("xeo_uViewMatrix");
            this._uViewNormalMatrixDraw = this.program.draw.getUniform("xeo_uViewNormalMatrix");
            this._uViewMatrixPickObject = this.program.pickObject.getUniform("xeo_uViewMatrix");
            this._uViewMatrixPickPrimitive = this.program.pickPrimitive.getUniform("xeo_uViewMatrix");
        },

        draw: function () {
            if (this._uViewMatrixDraw) {
                this._uViewMatrixDraw.setValue(this.state.matrix);
            }
            if (this._uViewNormalMatrixDraw) {
                this._uViewNormalMatrixDraw.setValue(this.state.normalMatrix);
            }
        },

        pickObject: function () {
            if (this._uViewMatrixPickObject) {
                this._uViewMatrixPickObject.setValue(this.state.matrix);
            }
        },

        pickPrimitive: function () {
            if (this._uViewMatrixPickPrimitive) {
                this._uViewMatrixPickPrimitive.setValue(this.state.matrix);
            }
        }
    });

})();;/**
 * Math utilities.
 *
 * @module XEO
 * @submodule math
 */;(function () {

    "use strict";

    // Some temporary vars to help avoid garbage collection

    var tempMat1 = new Float32Array(16);
    var tempMat2 = new Float32Array(16);
    var tempVec3 = new Float32Array(3);

    var tempVec3a = new Float32Array(3);
    var tempVec3b = new Float32Array(3);
    var tempVec3c = new Float32Array(3);
    var tempVec3d = new Float32Array(3);
    var tempVec3e = new Float32Array(3);
    var tempVec3f = new Float32Array(3);

    var tempVec4 = new Float32Array(4);

    var tempAABB2 = {
        min: new Float32Array(2),
        max: new Float32Array(2)
    };

    var tempAABB2b = {
        min: new Float32Array(2),
        max: new Float32Array(2)
    };

    /*
     * Optimizations made based on glMatrix by Brandon Jones
     */

    /*
     * Copyright (c) 2010 Brandon Jones
     *
     * This software is provided 'as-is', without any express or implied
     * warranty. In no event will the authors be held liable for any damages
     * arising from the use of this software.
     *
     * Permission is granted to anyone to use this software for any purpose,
     * including commercial applications, and to alter it and redistribute it
     * freely, subject to the following restrictions:
     *
     *    1. The origin of this software must not be misrepresented; you must not
     *    claim that you wrote the original software. If you use this software
     *    in a product, an acknowledgment in the product documentation would be
     *    appreciated but is not required.
     *
     *    2. Altered source versions must be plainly marked as such, and must not
     *    be misrepresented as being the original software.
     *
     *    3. This notice may not be removed or altered from any source
     *    distribution.
     */


    /**
     * This utility object provides math functions that are used within xeoEngine. These functions are also part xeoEngine's
     * public API and are therefore available for you to use within your application code.
     * @module XEO
     * @submodule math
     * @class math
     * @static
     */
    XEO.math = {

        /**
         * The number of radiians in a degree (0.0174532925).
         * @property DEGTORAD
         * @namespace XEO.math
         * @type {Number}
         */
        DEGTORAD: 0.0174532925,

        /**
         * Returns a new, uninitialized two-element vector.
         * @method vec2
         * @static
         * @returns {Float32Array}
         */
        vec2: function () {
            return new Float32Array(2);
        },

        /**
         * Returns a new, uninitialized three-element vector.
         * @method vec3
         * @static
         * @returns {Float32Array}
         */
        vec3: function () {
            return new Float32Array(3);
        },

        /**
         * Returns a new, uninitialized four-element vector.
         * @method vec4
         * @static
         * @returns {Float32Array}
         */
        vec4: function () {
            return new Float32Array(4);
        },

        /**
         * Returns a new, uninitialized 3x3 matrix.
         * @method mat3
         * @static
         * @returns {Float32Array}
         */
        mat3: function () {
            return new Float32Array(9);
        },

        /**
         * Returns a new, uninitialized 4x4 matrix.
         * @method mat4
         * @static
         * @returns {Float32Array}
         */
        mat4: function () {
            return new Float32Array(16);
        },

        /**
         * Returns a new, uninitialized 3D axis-aligned bounding box.
         * @method AABB3
         * @static
         * @returns {*} The bounding box.
         */
        AABB3: function () {
            return {
                min: new Float32Array(3),
                max: new Float32Array(3)
            }
        },

        /**
         * Returns a new, uninitialized 2D axis-aligned bounding box.
         * @method AABB2
         * @static
         * @returns {*} The bounding box.
         */
        AABB2: function () {
            return {
                min: new Float32Array(2),
                max: new Float32Array(2)
            }
        },

        /**
         * Returns a new UUID.
         * @method createUUID
         * @static
         * @return string The new UUID
         */
        createUUID: function () {
            // http://www.broofa.com/Tools/Math.uuid.htm
            var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
            var uuid = new Array(36);
            var rnd = 0, r;
            return function () {
                for (var i = 0; i < 36; i++) {
                    if (i === 8 || i === 13 || i === 18 || i === 23) {
                        uuid[i] = '-';
                    } else if (i === 14) {
                        uuid[i] = '4';
                    } else {
                        if (rnd <= 0x02) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
                        r = rnd & 0xf;
                        rnd = rnd >> 4;
                        uuid[i] = chars[( i === 19 ) ? ( r & 0x3 ) | 0x8 : r];
                    }
                }
                return uuid.join('');
            };
        }(),

        /**
         * Floating-point modulus
         * @method fmod
         * @static
         * @param {Number} a
         * @param {Number} b
         * @returns {*}
         */
        fmod: function (a, b) {
            if (a < b) {
                console.error("XEO.math.fmod : Attempting to find modulus within negative range - would be infinite loop - ignoring");
                return a;
            }
            while (b <= a) {
                a -= b;
            }
            return a;
        },

        /**
         * Negates a four-element vector.
         * @method negateVec4
         * @static
         * @param {Array(Number)} v Vector to negate
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        negateVec4: function (v, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = -v[0];
            dest[1] = -v[1];
            dest[2] = -v[2];
            dest[3] = -v[3];
            return dest;
        },

        /**
         * Adds one four-element vector to another.
         * @method addVec4
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        addVec4: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] + v[0];
            dest[1] = u[1] + v[1];
            dest[2] = u[2] + v[2];
            dest[3] = u[3] + v[3];
            return dest;
        },

        /**
         * Adds a scalar value to each element of a four-element vector.
         * @method addVec4Scalar
         * @static
         * @param {Array(Number)} v The vector
         * @param {Number} s The scalar
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        addVec4Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] + s;
            dest[1] = v[1] + s;
            dest[2] = v[2] + s;
            dest[3] = v[3] + s;
            return dest;
        },

        /**
         * Adds one three-element vector to another.
         * @method addVec3
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        addVec3: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] + v[0];
            dest[1] = u[1] + v[1];
            dest[2] = u[2] + v[2];
            return dest;
        },

        /**
         * Adds a scalar value to each element of a three-element vector.
         * @method addVec4Scalar
         * @static
         * @param {Array(Number)} v The vector
         * @param {Number} s The scalar
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        addVec3Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] + s;
            dest[1] = v[1] + s;
            dest[2] = v[2] + s;
            return dest;
        },

        /**
         * Subtracts one four-element vector from another.
         * @method subVec4
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Vector to subtract
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        subVec4: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] - v[0];
            dest[1] = u[1] - v[1];
            dest[2] = u[2] - v[2];
            dest[3] = u[3] - v[3];
            return dest;
        },

        /**
         * Subtracts one three-element vector from another.
         * @method subVec3
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Vector to subtract
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        subVec3: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] - v[0];
            dest[1] = u[1] - v[1];
            dest[2] = u[2] - v[2];
            return dest;
        },

        /**
         * Subtracts one two-element vector from another.
         * @method subVec2
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Vector to subtract
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        subVec2: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] - v[0];
            dest[1] = u[1] - v[1];
            return dest;
        },

        /**
         * Subtracts a scalar value from each element of a four-element vector.
         * @method subVec4Scalar
         * @static
         * @param {Array(Number)} v The vector
         * @param {Number} s The scalar
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        subVec4Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] - s;
            dest[1] = v[1] - s;
            dest[2] = v[2] - s;
            dest[3] = v[3] - s;
            return dest;
        },

        /**
         * Sets each element of a 4-element vector to a scalar value minus the value of that element.
         * @method subScalarVec4
         * @static
         * @param {Array(Number)} v The vector
         * @param {Number} s The scalar
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        subScalarVec4: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = s - v[0];
            dest[1] = s - v[1];
            dest[2] = s - v[2];
            dest[3] = s - v[3];
            return dest;
        },

        /**
         * Multiplies one three-element vector by another.
         * @method mulVec3
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        mulVec4: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] * v[0];
            dest[1] = u[1] * v[1];
            dest[2] = u[2] * v[2];
            dest[3] = u[3] * v[3];
            return dest;
        },

        /**
         * Multiplies each element of a four-element vector by a scalar.
         * @method mulVec34calar
         * @static
         * @param {Array(Number)} v The vector
         * @param {Number} s The scalar
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        mulVec4Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] * s;
            dest[1] = v[1] * s;
            dest[2] = v[2] * s;
            dest[3] = v[3] * s;
            return dest;
        },

        /**
         * Multiplies each element of a three-element vector by a scalar.
         * @method mulVec3Scalar
         * @static
         * @param {Array(Number)} v The vector
         * @param {Number} s The scalar
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        mulVec3Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] * s;
            dest[1] = v[1] * s;
            dest[2] = v[2] * s;
            return dest;
        },

        /**
         * Multiplies each element of a two-element vector by a scalar.
         * @method mulVec2Scalar
         * @static
         * @param {Array(Number)} v The vector
         * @param {Number} s The scalar
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        mulVec2Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] * s;
            dest[1] = v[1] * s;
            return dest;
        },

        /**
         * Divides one three-element vector by another.
         * @method divVec3
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        divVec3: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] / v[0];
            dest[1] = u[1] / v[1];
            dest[2] = u[2] / v[2];
            return dest;
        },

        /**
         * Divides one four-element vector by another.
         * @method divVec4
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        divVec4: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] / v[0];
            dest[1] = u[1] / v[1];
            dest[2] = u[2] / v[2];
            dest[3] = u[3] / v[3];
            return dest;
        },

        /**
         * Divides a scalar by a three-element vector, returning a new vector.
         * @method divScalarVec3
         * @static
         * @param v vec3
         * @param s scalar
         * @param dest vec3 - optional destination
         * @return [] dest if specified, v otherwise
         */
        divScalarVec3: function (s, v, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = s / v[0];
            dest[1] = s / v[1];
            dest[2] = s / v[2];
            return dest;
        },

        /**
         * Divides a three-element vector by a scalar.
         * @method divVec3Scalar
         * @static
         * @param v vec3
         * @param s scalar
         * @param dest vec3 - optional destination
         * @return [] dest if specified, v otherwise
         */
        divVec3Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] / s;
            dest[1] = v[1] / s;
            dest[2] = v[2] / s;
            return dest;
        },

        /**
         * Divides a four-element vector by a scalar.
         * @method divVec4Scalar
         * @static
         * @param v vec4
         * @param s scalar
         * @param dest vec4 - optional destination
         * @return [] dest if specified, v otherwise
         */
        divVec4Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] / s;
            dest[1] = v[1] / s;
            dest[2] = v[2] / s;
            dest[3] = v[3] / s;
            return dest;
        },


        /**
         * Divides a scalar by a four-element vector, returning a new vector.
         * @method divScalarVec4
         * @static
         * @param s scalar
         * @param v vec4
         * @param dest vec4 - optional destination
         * @return [] dest if specified, v otherwise
         */
        divScalarVec4: function (s, v, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = s / v[0];
            dest[1] = s / v[1];
            dest[2] = s / v[2];
            dest[3] = s / v[3];
            return dest;
        },

        /**
         * Returns the dot product of two four-element vectors.
         * @method dotVec4
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @return The dot product
         */
        dotVec4: function (u, v) {
            return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3]);
        },

        /**
         * Returns the cross product of two four-element vectors.
         * @method cross3Vec4
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @return The cross product
         */
        cross3Vec4: function (u, v) {
            var u0 = u[0], u1 = u[1], u2 = u[2];
            var v0 = v[0], v1 = v[1], v2 = v[2];
            return [
                u1 * v2 - u2 * v1,
                u2 * v0 - u0 * v2,
                u0 * v1 - u1 * v0,
                0.0];
        },

        /**
         * Returns the cross product of two three-element vectors.
         * @method cross3Vec3
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @return The cross product
         */
        cross3Vec3: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            var x = u[0], y = u[1], z = u[2];
            var x2 = v[0], y2 = v[1], z2 = v[2];
            dest[0] = y * z2 - z * y2;
            dest[1] = z * x2 - x * z2;
            dest[2] = x * y2 - y * x2;
            return dest;
        },


        sqLenVec4: function (v) { // TODO
            return XEO.math.dotVec4(v, v);
        },

        /**
         * Returns the length of a four-element vector.
         * @method lenVec4
         * @static
         * @param {Array(Number)} v The vector
         * @return The length
         */
        lenVec4: function (v) {
            return Math.sqrt(XEO.math.sqLenVec4(v));
        },

        /**
         * Returns the dot product of two three-element vectors.
         * @method dotVec4
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @return The dot product
         */
        dotVec3: function (u, v) {
            return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);
        },

        /**
         * Returns the dot product of two two-element vectors.
         * @method dotVec4
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @return The dot product
         */
        dotVec2: function (u, v) {
            return (u[0] * v[0] + u[1] * v[1]);
        },


        sqLenVec3: function (v) {
            return XEO.math.dotVec3(v, v);
        },


        sqLenVec2: function (v) {
            return XEO.math.dotVec2(v, v);
        },

        /**
         * Returns the length of a three-element vector.
         * @method lenVec3
         * @static
         * @param {Array(Number)} v The vector
         * @return The length
         */
        lenVec3: function (v) {
            return Math.sqrt(XEO.math.sqLenVec3(v));
        },

        /**
         * Returns the length of a two-element vector.
         * @method lenVec2
         * @static
         * @param {Array(Number)} v The vector
         * @return The length
         */
        lenVec2: function (v) {
            return Math.sqrt(XEO.math.sqLenVec2(v));
        },

        /**
         * @method rcpVec3
         * @static
         * @param v vec3
         * @param dest vec3 - optional destination
         * @return [] dest if specified, v otherwise
         *
         */
        rcpVec3: function (v, dest) {
            return XEO.math.divScalarVec3(1.0, v, dest);
        },

        /**
         * Normalizes a four-element vector
         * @method normalizeVec4
         * @static
         * @param v vec4
         * @param dest vec4 - optional destination
         * @return [] dest if specified, v otherwise
         *
         */
        normalizeVec4: function (v, dest) {
            var f = 1.0 / XEO.math.lenVec4(v);
            return XEO.math.mulVec4Scalar(v, f, dest);
        },

        /**
         * Normalizes a three-element vector
         * @method normalizeVec4
         * @static
         */
        normalizeVec3: function (v, dest) {
            var f = 1.0 / XEO.math.lenVec3(v);
            return XEO.math.mulVec3Scalar(v, f, dest);
        },

        /**
         * Normalizes a two-element vector
         * @method normalizeVec2
         * @static
         */
        normalizeVec2: function (v, dest) {
            var f = 1.0 / XEO.math.lenVec2(v);
            return XEO.math.mulVec2Scalar(v, f, dest);
        },

        /**
         * Duplicates a 4x4 identity matrix.
         * @method dupMat4
         * @static
         */
        dupMat4: function (m) {
            return m.slice(0, 16);
        },

        /**
         * Extracts a 3x3 matrix from a 4x4 matrix.
         * @method mat4To3
         * @static
         */
        mat4To3: function (m) {
            return [
                m[0], m[1], m[2],
                m[4], m[5], m[6],
                m[8], m[9], m[10]
            ];
        },

        /**
         * Returns a 4x4 matrix with each element set to the given scalar value.
         * @method m4s
         * @static
         */
        m4s: function (s) {
            return [
                s, s, s, s,
                s, s, s, s,
                s, s, s, s,
                s, s, s, s
            ];
        },

        /**
         * Returns a 4x4 matrix with each element set to zero.
         * @method setMat4ToZeroes
         * @static
         */
        setMat4ToZeroes: function () {
            return XEO.math.m4s(0.0);
        },

        /**
         * Returns a 4x4 matrix with each element set to 1.0.
         * @method setMat4ToOnes
         * @static
         */
        setMat4ToOnes: function () {
            return XEO.math.m4s(1.0);
        },

        /**
         * Returns a 4x4 matrix with each element set to 1.0.
         * @method setMat4ToOnes
         * @static
         */
        diagonalMat4v: function (v) {
            return new Float32Array([
                v[0], 0.0, 0.0, 0.0,
                0.0, v[1], 0.0, 0.0,
                0.0, 0.0, v[2], 0.0,
                0.0, 0.0, 0.0, v[3]
            ]);
        },

        /**
         * Returns a 4x4 matrix with diagonal elements set to the given vector.
         * @method diagonalMat4c
         * @static
         */
        diagonalMat4c: function (x, y, z, w) {
            return XEO.math.diagonalMat4v([x, y, z, w]);
        },

        /**
         * Returns a 4x4 matrix with diagonal elements set to the given scalar.
         * @method diagonalMat4s
         * @static
         */
        diagonalMat4s: function (s) {
            return XEO.math.diagonalMat4c(s, s, s, s);
        },

        /**
         * Returns a 4x4 identity matrix.
         * @method identityMat4
         * @static
         */
        identityMat4: function (mat) {

            mat = mat || new Float32Array(16);

            mat[0] = 1.0;
            mat[1] = 0.0;
            mat[2] = 0.0;
            mat[3] = 0.0;

            mat[4] = 0.0;
            mat[5] = 1.0;
            mat[6] = 0.0;
            mat[7] = 0.0;

            mat[8] = 0.0;
            mat[9] = 0.0;
            mat[10] = 1.0;
            mat[11] = 0.0;

            mat[12] = 0.0;
            mat[13] = 0.0;
            mat[14] = 0.0;
            mat[15] = 1.0;

            return mat;
        },

        /**
         * Tests if the given 4x4 matrix is the identity matrix.
         * @method isIdentityMat4
         * @static
         */
        isIdentityMat4: function (m) {
            if (m[0] !== 1.0 || m[1] !== 0.0 || m[2] !== 0.0 || m[3] !== 0.0 ||
                m[4] !== 0.0 || m[5] !== 1.0 || m[6] !== 0.0 || m[7] !== 0.0 ||
                m[8] !== 0.0 || m[9] !== 0.0 || m[10] !== 1.0 || m[11] !== 0.0 ||
                m[12] !== 0.0 || m[13] !== 0.0 || m[14] !== 0.0 || m[15] !== 1.0) {
                return false;
            }
            return true;
        },

        /**
         * Negates the given 4x4 matrix.
         * @method negateMat4
         * @static
         */
        negateMat4: function (m, dest) {
            if (!dest) {
                dest = m;
            }
            dest[0] = -m[0];
            dest[1] = -m[1];
            dest[2] = -m[2];
            dest[3] = -m[3];
            dest[4] = -m[4];
            dest[5] = -m[5];
            dest[6] = -m[6];
            dest[7] = -m[7];
            dest[8] = -m[8];
            dest[9] = -m[9];
            dest[10] = -m[10];
            dest[11] = -m[11];
            dest[12] = -m[12];
            dest[13] = -m[13];
            dest[14] = -m[14];
            dest[15] = -m[15];
            return dest;
        },

        /**
         * Adds the given 4x4 matrices together.
         * @method addMat4
         * @static
         */
        addMat4: function (a, b, dest) {
            if (!dest) {
                dest = a;
            }
            dest[0] = a[0] + b[0];
            dest[1] = a[1] + b[1];
            dest[2] = a[2] + b[2];
            dest[3] = a[3] + b[3];
            dest[4] = a[4] + b[4];
            dest[5] = a[5] + b[5];
            dest[6] = a[6] + b[6];
            dest[7] = a[7] + b[7];
            dest[8] = a[8] + b[8];
            dest[9] = a[9] + b[9];
            dest[10] = a[10] + b[10];
            dest[11] = a[11] + b[11];
            dest[12] = a[12] + b[12];
            dest[13] = a[13] + b[13];
            dest[14] = a[14] + b[14];
            dest[15] = a[15] + b[15];
            return dest;
        },

        /**
         * Adds the given scalar to each element of the given 4x4 matrix.
         * @method addMat4Scalar
         * @static
         */
        addMat4Scalar: function (m, s, dest) {
            if (!dest) {
                dest = m;
            }
            dest[0] = m[0] + s;
            dest[1] = m[1] + s;
            dest[2] = m[2] + s;
            dest[3] = m[3] + s;
            dest[4] = m[4] + s;
            dest[5] = m[5] + s;
            dest[6] = m[6] + s;
            dest[7] = m[7] + s;
            dest[8] = m[8] + s;
            dest[9] = m[9] + s;
            dest[10] = m[10] + s;
            dest[11] = m[11] + s;
            dest[12] = m[12] + s;
            dest[13] = m[13] + s;
            dest[14] = m[14] + s;
            dest[15] = m[15] + s;
            return dest;
        },

        /**
         * Adds the given scalar to each element of the given 4x4 matrix.
         * @method addScalarMat4
         * @static
         */
        addScalarMat4: function (s, m, dest) {
            return XEO.math.addMat4Scalar(m, s, dest);
        },

        /**
         * Subtracts the second 4x4 matrix from the first.
         * @method subMat4
         * @static
         */
        subMat4: function (a, b, dest) {
            if (!dest) {
                dest = a;
            }
            dest[0] = a[0] - b[0];
            dest[1] = a[1] - b[1];
            dest[2] = a[2] - b[2];
            dest[3] = a[3] - b[3];
            dest[4] = a[4] - b[4];
            dest[5] = a[5] - b[5];
            dest[6] = a[6] - b[6];
            dest[7] = a[7] - b[7];
            dest[8] = a[8] - b[8];
            dest[9] = a[9] - b[9];
            dest[10] = a[10] - b[10];
            dest[11] = a[11] - b[11];
            dest[12] = a[12] - b[12];
            dest[13] = a[13] - b[13];
            dest[14] = a[14] - b[14];
            dest[15] = a[15] - b[15];
            return dest;
        },

        /**
         * Subtracts the given scalar from each element of the given 4x4 matrix.
         * @method subMat4Scalar
         * @static
         */
        subMat4Scalar: function (m, s, dest) {
            if (!dest) {
                dest = m;
            }
            dest[0] = m[0] - s;
            dest[1] = m[1] - s;
            dest[2] = m[2] - s;
            dest[3] = m[3] - s;
            dest[4] = m[4] - s;
            dest[5] = m[5] - s;
            dest[6] = m[6] - s;
            dest[7] = m[7] - s;
            dest[8] = m[8] - s;
            dest[9] = m[9] - s;
            dest[10] = m[10] - s;
            dest[11] = m[11] - s;
            dest[12] = m[12] - s;
            dest[13] = m[13] - s;
            dest[14] = m[14] - s;
            dest[15] = m[15] - s;
            return dest;
        },

        /**
         * Subtracts the given scalar from each element of the given 4x4 matrix.
         * @method subScalarMat4
         * @static
         */
        subScalarMat4: function (s, m, dest) {
            if (!dest) {
                dest = m;
            }
            dest[0] = s - m[0];
            dest[1] = s - m[1];
            dest[2] = s - m[2];
            dest[3] = s - m[3];
            dest[4] = s - m[4];
            dest[5] = s - m[5];
            dest[6] = s - m[6];
            dest[7] = s - m[7];
            dest[8] = s - m[8];
            dest[9] = s - m[9];
            dest[10] = s - m[10];
            dest[11] = s - m[11];
            dest[12] = s - m[12];
            dest[13] = s - m[13];
            dest[14] = s - m[14];
            dest[15] = s - m[15];
            return dest;
        },

        /**
         * Multiplies the two given 4x4 matrix by each other.
         * @method mulMat4
         * @static
         */
        mulMat4: function (a, b, dest) {
            if (!dest) {
                dest = a;
            }

            // Cache the matrix values (makes for huge speed increases!)
            var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

            var b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
            var b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
            var b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
            var b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];

            dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
            dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
            dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
            dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
            dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
            dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
            dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
            dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
            dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
            dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
            dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
            dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
            dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
            dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
            dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
            dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;

            return dest;
        },

        /**
         * Multiplies each element of the given 4x4 matrix by the given scalar.
         * @method mulMat4Scalar
         * @static
         */
        mulMat4Scalar: function (m, s, dest) {
            if (!dest) {
                dest = m;
            }
            dest[0] = m[0] * s;
            dest[1] = m[1] * s;
            dest[2] = m[2] * s;
            dest[3] = m[3] * s;
            dest[4] = m[4] * s;
            dest[5] = m[5] * s;
            dest[6] = m[6] * s;
            dest[7] = m[7] * s;
            dest[8] = m[8] * s;
            dest[9] = m[9] * s;
            dest[10] = m[10] * s;
            dest[11] = m[11] * s;
            dest[12] = m[12] * s;
            dest[13] = m[13] * s;
            dest[14] = m[14] * s;
            dest[15] = m[15] * s;
            return dest;
        },

        /**
         * Multiplies the given 4x4 matrix by the given four-element vector.
         * @method mulMat4v4
         * @static
         */
        mulMat4v4: function (m, v) {
            var v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];
            return [
                m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3,
                m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3,
                m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3,
                m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3
            ];
        },

        /**
         * Transposes the given 4x4 matrix.
         * @method transposeMat4
         * @static
         */
        transposeMat4: function (mat, dest) {
            // If we are transposing ourselves we can skip a few steps but have to cache some values
            var m4 = mat[4], m14 = mat[14], m8 = mat[8];
            var m13 = mat[13], m12 = mat[12], m9 = mat[9];
            if (!dest || mat === dest) {
                var a01 = mat[1], a02 = mat[2], a03 = mat[3];
                var a12 = mat[6], a13 = mat[7];
                var a23 = mat[11];
                mat[1] = m4;
                mat[2] = m8;
                mat[3] = m12;
                mat[4] = a01;
                mat[6] = m9;
                mat[7] = m13;
                mat[8] = a02;
                mat[9] = a12;
                mat[11] = m14;
                mat[12] = a03;
                mat[13] = a13;
                mat[14] = a23;
                return mat;
            }
            dest[0] = mat[0];
            dest[1] = m4;
            dest[2] = m8;
            dest[3] = m12;
            dest[4] = mat[1];
            dest[5] = mat[5];
            dest[6] = m9;
            dest[7] = m13;
            dest[8] = mat[2];
            dest[9] = mat[6];
            dest[10] = mat[10];
            dest[11] = m14;
            dest[12] = mat[3];
            dest[13] = mat[7];
            dest[14] = mat[11];
            dest[15] = mat[15];
            return dest;
        },

        /**
         * Returns the determinant of the given 4x4 matrix.
         * @method determinantMat4
         * @static
         */
        determinantMat4: function (mat) {
            // Cache the matrix values (makes for huge speed increases!)
            var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
            var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
            var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
            var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];
            return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +
                a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +
                a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +
                a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +
                a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +
                a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;
        },

        /**
         * Returns the inverse of the given 4x4 matrix.
         * @method inverseMat4
         * @static
         */
        inverseMat4: function (mat, dest) {
            if (!dest) {
                dest = mat;
            }
            // Cache the matrix values (makes for huge speed increases!)
            var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
            var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
            var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
            var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];
            var b00 = a00 * a11 - a01 * a10;
            var b01 = a00 * a12 - a02 * a10;
            var b02 = a00 * a13 - a03 * a10;
            var b03 = a01 * a12 - a02 * a11;
            var b04 = a01 * a13 - a03 * a11;
            var b05 = a02 * a13 - a03 * a12;
            var b06 = a20 * a31 - a21 * a30;
            var b07 = a20 * a32 - a22 * a30;
            var b08 = a20 * a33 - a23 * a30;
            var b09 = a21 * a32 - a22 * a31;
            var b10 = a21 * a33 - a23 * a31;
            var b11 = a22 * a33 - a23 * a32;

            // Calculate the determinant (inlined to avoid double-caching)
            var invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);

            dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
            dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
            dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
            dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
            dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
            dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
            dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
            dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
            dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
            dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
            dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
            dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
            dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
            dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
            dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
            dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

            return dest;
        },

        /**
         * Returns the trace of the given 4x4 matrix.
         * @method traceMat4
         * @static
         */
        traceMat4: function (m) {
            return (m[0] + m[5] + m[10] + m[15]);
        },

        /**
         * Returns 4x4 translation matrix.
         * @method translationMat4
         * @static
         */
        translationMat4v: function (v, dest) {
            var m = dest || XEO.math.identityMat4();
            m[12] = v[0];
            m[13] = v[1];
            m[14] = v[2];
            return m;
        },

        /**
         * Returns 4x4 translation matrix.
         * @method translationMat4c
         * @static
         */
        translationMat4c: function (x, y, z, dest) {
            return XEO.math.translationMat4v([x, y, z], dest);
        },

        /**
         * Returns 4x4 translation matrix.
         * @method translationMat4s
         * @static
         */
        translationMat4s: function (s, dest) {
            return XEO.math.translationMat4c(s, s, s, dest);
        },

        /**
         * Returns 4x4 rotation matrix.
         * @method rotationMat4v
         * @static
         */
        rotationMat4v: function (anglerad, axis, m) {
            var ax = XEO.math.normalizeVec4([axis[0], axis[1], axis[2], 0.0], []);
            var s = Math.sin(anglerad);
            var c = Math.cos(anglerad);
            var q = 1.0 - c;

            var x = ax[0];
            var y = ax[1];
            var z = ax[2];

            var xy, yz, zx, xs, ys, zs;

            //xx = x * x; used once
            //yy = y * y; used once
            //zz = z * z; used once
            xy = x * y;
            yz = y * z;
            zx = z * x;
            xs = x * s;
            ys = y * s;
            zs = z * s;

            m = m || XEO.math.mat4();

            m[0] = (q * x * x) + c;
            m[1] = (q * xy) + zs;
            m[2] = (q * zx) - ys;
            m[3] = 0.0;

            m[4] = (q * xy) - zs;
            m[5] = (q * y * y) + c;
            m[6] = (q * yz) + xs;
            m[7] = 0.0;

            m[8] = (q * zx) + ys;
            m[9] = (q * yz) - xs;
            m[10] = (q * z * z) + c;
            m[11] = 0.0;

            m[12] = 0.0;
            m[13] = 0.0;
            m[14] = 0.0;
            m[15] = 1.0;

            return m;
        },

        /**
         * Returns 4x4 rotation matrix.
         * @method rotationMat4c
         * @static
         */
        rotationMat4c: function (anglerad, x, y, z) {
            return XEO.math.rotationMat4v(anglerad, [x, y, z]);
        },

        /**
         * Returns 4x4 scale matrix.
         * @method scalingMat4v
         * @static
         */
        scalingMat4v: function (v, m) {
            m = m || XEO.math.identityMat4();
            m[0] = v[0];
            m[5] = v[1];
            m[10] = v[2];
            return m;
        },

        /**
         * Returns 4x4 scale matrix.
         * @method scalingMat4c
         * @static
         */
        scalingMat4c: function (x, y, z) {
            return XEO.math.scalingMat4v([x, y, z]);
        },

        /**
         * Returns 4x4 scale matrix.
         * @method scalingMat4s
         * @static
         */
        scalingMat4s: function (s) {
            return XEO.math.scalingMat4c(s, s, s);
        },

        /**
         * Returns a 4x4 'lookat' viewing transform matrix.
         * @method lookAtMat4v
         * @param pos vec3 position of the viewer
         * @param target vec3 point the viewer is looking at
         * @param up vec3 pointing "up"
         * @param dest mat4 Optional, mat4 frustum matrix will be written into
         *
         * @return {mat4} dest if specified, a new mat4 otherwise
         */
        lookAtMat4v: function (pos, target, up, dest) {
            if (!dest) {
                dest = XEO.math.mat4();
            }

            var posx = pos[0],
                posy = pos[1],
                posz = pos[2],
                upx = up[0],
                upy = up[1],
                upz = up[2],
                targetx = target[0],
                targety = target[1],
                targetz = target[2];

            if (posx === targetx && posy === targety && posz === targetz) {
                return XEO.math.identityMat4();
            }

            var z0, z1, z2, x0, x1, x2, y0, y1, y2, len;

            //vec3.direction(eye, center, z);
            z0 = posx - targetx;
            z1 = posy - targety;
            z2 = posz - targetz;

            // normalize (no check needed for 0 because of early return)
            len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
            z0 *= len;
            z1 *= len;
            z2 *= len;

            //vec3.normalize(vec3.cross(up, z, x));
            x0 = upy * z2 - upz * z1;
            x1 = upz * z0 - upx * z2;
            x2 = upx * z1 - upy * z0;
            len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
            if (!len) {
                x0 = 0;
                x1 = 0;
                x2 = 0;
            } else {
                len = 1 / len;
                x0 *= len;
                x1 *= len;
                x2 *= len;
            }

            //vec3.normalize(vec3.cross(z, x, y));
            y0 = z1 * x2 - z2 * x1;
            y1 = z2 * x0 - z0 * x2;
            y2 = z0 * x1 - z1 * x0;

            len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
            if (!len) {
                y0 = 0;
                y1 = 0;
                y2 = 0;
            } else {
                len = 1 / len;
                y0 *= len;
                y1 *= len;
                y2 *= len;
            }

            dest[0] = x0;
            dest[1] = y0;
            dest[2] = z0;
            dest[3] = 0;
            dest[4] = x1;
            dest[5] = y1;
            dest[6] = z1;
            dest[7] = 0;
            dest[8] = x2;
            dest[9] = y2;
            dest[10] = z2;
            dest[11] = 0;
            dest[12] = -(x0 * posx + x1 * posy + x2 * posz);
            dest[13] = -(y0 * posx + y1 * posy + y2 * posz);
            dest[14] = -(z0 * posx + z1 * posy + z2 * posz);
            dest[15] = 1;

            return dest;
        },

        /**
         * Returns a 4x4 'lookat' viewing transform matrix.
         * @method lookAtMat4c
         * @static
         */
        lookAtMat4c: function (posx, posy, posz, targetx, targety, targetz, upx, upy, upz) {
            return XEO.math.lookAtMat4v([posx, posy, posz], [targetx, targety, targetz], [upx, upy, upz], []);
        },

        /**
         * Returns a 4x4 orthographic projection matrix.
         * @method orthoMat4c
         * @static
         */
        orthoMat4c: function (left, right, bottom, top, near, far, dest) {
            if (!dest) {
                dest = XEO.math.mat4();
            }
            var rl = (right - left);
            var tb = (top - bottom);
            var fn = (far - near);

            dest[0] = 2.0 / rl;
            dest[1] = 0.0;
            dest[2] = 0.0;
            dest[3] = 0.0;

            dest[4] = 0.0;
            dest[5] = 2.0 / tb;
            dest[6] = 0.0;
            dest[7] = 0.0;

            dest[8] = 0.0;
            dest[9] = 0.0;
            dest[10] = -2.0 / fn;
            dest[11] = 0.0;

            dest[12] = -(left + right) / rl;
            dest[13] = -(top + bottom) / tb;
            dest[14] = -(far + near) / fn;
            dest[15] = 1.0;

            return dest;
        },

        /**
         * Returns a 4x4 perspective projection matrix.
         * @method frustumMat4v
         * @static
         */
        frustumMat4v: function (fmin, fmax, m) {

            if (!m) {
                m = XEO.math.mat4();
            }

            var fmin4 = [fmin[0], fmin[1], fmin[2], 0.0];
            var fmax4 = [fmax[0], fmax[1], fmax[2], 0.0];

            XEO.math.addVec4(fmax4, fmin4, tempMat1);
            XEO.math.subVec4(fmax4, fmin4, tempMat2);

            var t = 2.0 * fmin4[2];

            var tempMat20 = tempMat2[0], tempMat21 = tempMat2[1], tempMat22 = tempMat2[2];

            m[0] = t / tempMat20;
            m[1] = 0.0;
            m[2] = 0.0;
            m[3] = 0.0;

            m[4] = 0.0;
            m[5] = t / tempMat21;
            m[6] = 0.0;
            m[7] = 0.0;

            m[8] = tempMat1[0] / tempMat20;
            m[9] = tempMat1[1] / tempMat21;
            m[10] = -tempMat1[2] / tempMat22;
            m[11] = -1.0;

            m[12] = 0.0;
            m[13] = 0.0;
            m[14] = -t * fmax4[2] / tempMat22;
            m[15] = 0.0;

            return m;
        },

        /**
         * Returns a 4x4 perspective projection matrix.
         * @method frustumMat4v
         * @static
         */
        frustumMat4: function (left, right, bottom, top, near, far, dest) {
            if (!dest) {
                dest = XEO.math.mat4();
            }
            var rl = (right - left);
            var tb = (top - bottom);
            var fn = (far - near);
            dest[0] = (near * 2) / rl;
            dest[1] = 0;
            dest[2] = 0;
            dest[3] = 0;
            dest[4] = 0;
            dest[5] = (near * 2) / tb;
            dest[6] = 0;
            dest[7] = 0;
            dest[8] = (right + left) / rl;
            dest[9] = (top + bottom) / tb;
            dest[10] = -(far + near) / fn;
            dest[11] = -1;
            dest[12] = 0;
            dest[13] = 0;
            dest[14] = -(far * near * 2) / fn;
            dest[15] = 0;
            return dest;
        },

        /**
         * Returns a 4x4 perspective projection matrix.
         * @method perspectiveMatrix4v
         * @static
         */
        perspectiveMatrix4: function (fovyrad, aspectratio, znear, zfar, m) {
            var pmin = [];
            var pmax = [];

            pmin[2] = znear;
            pmax[2] = zfar;

            pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);
            pmin[1] = -pmax[1];

            pmax[0] = pmax[1] * aspectratio;
            pmin[0] = -pmax[0];

            return XEO.math.frustumMat4v(pmin, pmax, m);
        },

        /**
         * Transforms a three-element position by a 4x4 matrix.
         * @method transformPoint3
         * @static
         */
        transformPoint3: function (m, p, dest) {

            var r = dest || XEO.math.vec4();

            r[0] = (m[0] * p[0]) + (m[4] * p[1]) + (m[8] * p[2]) + m[12];
            r[1] = (m[1] * p[0]) + (m[5] * p[1]) + (m[9] * p[2]) + m[13];
            r[2] = (m[2] * p[0]) + (m[6] * p[1]) + (m[10] * p[2]) + m[14];
            r[3] = 1.0;

            return r;
        },

        /**
         * Transforms a homogeneous coordinate by a 4x4 matrix.
         * @method transformPoint3
         * @static
         */
        transformPoint4: function (m, v, dest) {
            var r = dest || XEO.math.vec4();

            r[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];
            r[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];
            r[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];
            r[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];

            return r;
        },


        /**
         * Transforms an array of three-element positions by a 4x4 matrix.
         * @method transformPoints3
         * @static
         */
        transformPoints3: function (m, points, points2) {
            var result = points2 || [];
            var len = points.length;
            var p0, p1, p2;
            var pi;

            // cache values
            var m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3];
            var m4 = m[4], m5 = m[5], m6 = m[6], m7 = m[7];
            var m8 = m[8], m9 = m[9], m10 = m[10], m11 = m[11];
            var m12 = m[12], m13 = m[13], m14 = m[14], m15 = m[15];

            var r;

            for (var i = 0; i < len; ++i) {

                // cache values
                pi = points[i];

                p0 = pi[0];
                p1 = pi[1];
                p2 = pi[2];

                r = result[i] || (result[i] = [0, 0, 0]);

                r[0] = (m0 * p0) + (m4 * p1) + (m8 * p2) + m12;
                r[1] = (m1 * p0) + (m5 * p1) + (m9 * p2) + m13;
                r[2] = (m2 * p0) + (m6 * p1) + (m10 * p2) + m14;
                r[3] = (m3 * p0) + (m7 * p1) + (m11 * p2) + m15;
            }

            result.length = len;

            return result;
        },

        /**
         * Transforms a three-element vector by a 4x4 matrix.
         * @method transformVec3
         * @static
         */
        transformVec3: function (m, v, dest) {
            var v0 = v[0], v1 = v[1], v2 = v[2];
            dest = dest || this.vec3();
            dest[0] = (m[0] * v0) + (m[4] * v1) + (m[8] * v2);
            dest[1] = (m[1] * v0) + (m[5] * v1) + (m[9] * v2);
            dest[2] = (m[2] * v0) + (m[6] * v1) + (m[10] * v2);
            return dest;
        },

        /**
         * Transforms a four-element vector by a 4x4 matrix.
         * @method transformVec4
         * @static
         */
        transformVec4: function (m, v, dest) {
            var v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];
            dest = dest || this.vec4();
            dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;
            dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;
            dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;
            dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;
            return dest;
        },

        /**
         * Transforms a four-element vector by a 4x4 projection matrix.
         * @method projectVec4
         * @static
         */
        projectVec4: function (v) {
            var f = 1.0 / v[3];
            return [v[0] * f, v[1] * f, v[2] * f, 1.0];
        },

        /**
         * Linearly interpolates between two 3D vectors.
         * @method lerpVec3
         * @static
         */
        lerpVec3: function (t, t1, t2, p1, p2, dest) {
            var result = dest || this.vec3();
            var f = (t - t1) / (t2 - t1);
            result[0] = p1[0] + (f * (p2[0] - p1[0]));
            result[1] = p1[1] + (f * (p2[1] - p1[1]));
            result[2] = p1[2] + (f * (p2[2] - p1[2]));
            return result;
        },

        /**
         * Gets the diagonal size of a boundary given as minima and maxima.
         * @method getAABBDiag
         * @static
         */
        getAABBDiag: function (boundary) {
            this.subVec3(boundary.max, boundary.min, tempVec3c);
            return Math.abs(this.lenVec3(tempVec3c));
        },

        /**
         * Gets the center of a boundary given as minima and maxima.
         * @method getAABBCenter
         * @static
         */
        getAABBCenter: function (boundary, dest) {
            var r = dest || this.vec3();

            r[0] = (boundary.max[0] + boundary.min[0] ) * 0.5;
            r[1] = (boundary.max[1] + boundary.min[1] ) * 0.5;
            r[2] = (boundary.max[2] + boundary.min[2] ) * 0.5;

            return r;
        },

        /**
         * Gets the center of a 2D boundary given as minima and maxima.
         * @method getAABB2Center
         * @static
         */
        getAABB2Center: function (boundary, dest) {
            var r = dest || this.vec2();

            r[0] = (boundary.max[0] + boundary.min[0] ) / 2;
            r[1] = (boundary.max[1] + boundary.min[1] ) / 2;

            return r;
        },

        /**
         * Collapses a 3D axis-aligned boundary, ready to expand to fit 2D points.
         * Creates new AABB if none supplied.
         *
         * @method collapseAABB3
         * @static
         * @param {*} [aabb] 3D axis-aligned bounding box.
         * @returns {*} 3D axis-aligned bounding box.
         */
        collapseAABB3: function (aabb) {

            aabb = aabb || XEO.math.AABB2();

            aabb.min[0] = 10000000;
            aabb.min[1] = 10000000;
            aabb.min[2] = 10000000;
            aabb.max[0] = -10000000;
            aabb.max[1] = -10000000;
            aabb.max[2] = -10000000;

            return aabb;
        },

        /**
         * Converts an axis-aligned 3D boundary into an oriented boundary consisting of
         * an array of eight 3D positions, one for each corner of the boundary.
         *
         * @method AABB3ToOBB3
         * @static
         * @param {*} aabb Axis-aligned boundary.
         * @param {Array} [obb] Oriented bounding box.
         * @returns {*} Oriented bounding box.
         */
        AABB3ToOBB3: function (aabb, obb) {

            obb = obb || [];

            if (!obb[0]) {
                obb[0] = [];
            }

            obb[0][0] = aabb.min[0];
            obb[0][1] = aabb.min[1];
            obb[0][2] = aabb.min[2];
            obb[0][3] = 1;

            if (!obb[1]) {
                obb[1] = [];
            }

            obb[1][0] = aabb.max[0];
            obb[1][1] = aabb.min[1];
            obb[1][2] = aabb.min[2];
            obb[1][3] = 1;

            if (!obb[2]) {
                obb[2] = [];
            }

            obb[2][0] = aabb.max[0];
            obb[2][1] = aabb.max[1];
            obb[2][2] = aabb.min[2];
            obb[2][3] = 1;

            if (!obb[3]) {
                obb[3] = [];
            }

            obb[3][0] = aabb.min[0];
            obb[3][1] = aabb.max[1];
            obb[3][2] = aabb.min[2];
            obb[3][3] = 1;

            if (!obb[4]) {
                obb[4] = [];
            }

            obb[4][0] = aabb.min[0];
            obb[4][1] = aabb.min[1];
            obb[4][2] = aabb.max[2];
            obb[4][3] = 1;

            if (!obb[5]) {
                obb[5] = [];
            }

            obb[5][0] = aabb.max[0];
            obb[5][1] = aabb.min[1];
            obb[5][2] = aabb.max[2];
            obb[5][3] = 1;

            if (!obb[6]) {
                obb[6] = [];
            }

            obb[6][0] = aabb.max[0];
            obb[6][1] = aabb.max[1];
            obb[6][2] = aabb.max[2];
            obb[6][3] = 1;

            if (!obb[7]) {
                obb[7] = [];
            }

            obb[7][0] = aabb.min[0];
            obb[7][1] = aabb.max[1];
            obb[7][2] = aabb.max[2];
            obb[7][3] = 1;

            return obb;
        },

        /**
         * Finds the minimum axis-aligned 3D boundary enclosing the 3D points given in a flattened,  1-dimensional array.
         *
         * @method positions3ToAABB3
         * @static
         * @param {Array} positions Flattened 3D positions array
         * @param {*} [aabb] Axis-aligned bounding box.
         * @returns {*} Axis-aligned bounding box.
         */
        positions3ToAABB3: function (positions, aabb) {

            aabb = aabb || XEO.math.AABB3();

            var xmin = 100000;
            var ymin = 100000;
            var zmin = 100000;
            var xmax = -100000;
            var ymax = -100000;
            var zmax = -100000;

            var x, y, z;

            for (var i = 0, len = positions.length - 2; i < len; i += 3) {

                x = positions[i + 0];
                y = positions[i + 1];
                z = positions[i + 2];

                if (x < xmin) {
                    xmin = x;
                }

                if (y < ymin) {
                    ymin = y;
                }

                if (z < zmin) {
                    zmin = z;
                }

                if (x > xmax) {
                    xmax = x;
                }

                if (y > ymax) {
                    ymax = y;
                }

                if (z > zmax) {
                    zmax = z;
                }
            }

            aabb.min[0] = xmin;
            aabb.min[1] = ymin;
            aabb.min[2] = zmin;
            aabb.max[0] = xmax;
            aabb.max[1] = ymax;
            aabb.max[2] = zmax;

            return aabb;
        },

        /**
         * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.
         *
         * @method points3ToAABB3
         * @static
         * @param {Array} points Oriented bounding box.
         * @param {*} [aabb] Axis-aligned bounding box.
         * @returns {*} Axis-aligned bounding box.
         */
        points3ToAABB3: function (points, aabb) {

            aabb = aabb || XEO.math.AABB3();

            var xmin = 100000;
            var ymin = 100000;
            var zmin = 100000;
            var xmax = -100000;
            var ymax = -100000;
            var zmax = -100000;

            var x, y, z;

            for (var i = 0, len = points.length; i < len; i++) {

                x = points[i][0];
                y = points[i][1];
                z = points[i][2];

                if (x < xmin) {
                    xmin = x;
                }

                if (y < ymin) {
                    ymin = y;
                }

                if (z < zmin) {
                    zmin = z;
                }

                if (x > xmax) {
                    xmax = x;
                }

                if (y > ymax) {
                    ymax = y;
                }

                if (z > zmax) {
                    zmax = z;
                }
            }

            aabb.min[0] = xmin;
            aabb.min[1] = ymin;
            aabb.min[2] = zmin;
            aabb.max[0] = xmax;
            aabb.max[1] = ymax;
            aabb.max[2] = zmax;

            return aabb;
        },

        /**
         * Expands the first axis-aligned 3D boundary to enclose the second, if required.
         *
         * @method expandAABB3
         * @static
         * @param {*} aabb1 First AABB
         * @param {*} aabb2 Second AABB
         * @returns {*} The second AABB
         */
        expandAABB3: function (aabb1, aabb2) {

            if (aabb1.min[0] > aabb2.min[0]) {
                aabb1.min[0] = aabb2.min[0];
            }

            if (aabb1.min[1] > aabb2.min[1]) {
                aabb1.min[1] = aabb2.min[1];
            }

            if (aabb1.min[2] > aabb2.min[2]) {
                aabb1.min[2] = aabb2.min[2];
            }

            if (aabb1.max[0] < aabb2.max[0]) {
                aabb1.max[0] = aabb2.max[0];
            }

            if (aabb1.max[1] < aabb2.max[1]) {
                aabb1.max[1] = aabb2.max[1];
            }

            if (aabb1.max[2] < aabb2.max[2]) {
                aabb1.max[2] = aabb2.max[2];
            }

            return aabb2;
        },

        /**
         * Expands an axis-aligned 3D boundary to enclose the given point, if needed.
         *
         * @method expandAABB3Point3
         * @static
         * @param {*} aabb AABB
         * @param {*} p Point
         * @returns {*} The AABB
         */
        expandAABB3Point3: function (aabb, p) {

            if (aabb.min[0] < p[0]) {
                aabb.min[0] = p[0];
            }

            if (aabb.min[1] < p[1]) {
                aabb.min[1] = p[1];
            }

            if (aabb.min[2] < p[2]) {
                aabb.min[2] = p[2];
            }

            if (aabb.max[0] > p[0]) {
                aabb.max[0] = p[0];
            }

            if (aabb.max[1] > p[1]) {
                aabb.max[1] = p[1];
            }

            if (aabb.max[2] > p[2]) {
                aabb.max[2] = p[2];
            }

            return aabb;
        },

        /**
         * Collapses a 2D axis-aligned boundary, ready to expand to fit 2D points.
         * Creates new AABB if none supplied.
         *
         * @method collapseAABB2
         * @static
         * @param {*} [aabb] 2D axis-aligned bounding box.
         * @returns {*} 2D axis-aligned bounding box.
         */
        collapseAABB2: function (aabb) {

            aabb = aabb || XEO.math.AABB2();

            aabb.min[0] = 10000000;
            aabb.min[1] = 10000000;
            aabb.max[0] = -10000000;
            aabb.max[1] = -10000000;

            return aabb;
        },

        /**
         * Finds the minimum 2D projected axis-aligned boundary enclosing the given 3D points.
         *
         * @method points3ToAABB2
         * @static
         * @param {Array} points 3D Points.
         * @param {*} [aabb] 2D axis-aligned bounding box.
         * @returns {*} 2D axis-aligned bounding box.
         */
        points3ToAABB2: function (points, aabb) {

            aabb = aabb || XEO.math.AABB2();

            var xmin = 10000000;
            var ymin = 10000000;
            var xmax = -10000000;
            var ymax = -10000000;

            var x, y, z, w, f;

            for (var i = 0, len = points.length; i < len; i++) {

                x = points[i][0];
                y = points[i][1];
                z = points[i][2];
                w = points[i][3] || 1.0;

                f = 1.0 / w;

                x *= f;
                y *= f;

                if (x < xmin) {
                    xmin = x;
                }

                if (y < ymin) {
                    ymin = y;
                }

                if (x > xmax) {
                    xmax = x;
                }

                if (y > ymax) {
                    ymax = y;
                }
            }

            aabb.min[0] = xmin;
            aabb.min[1] = ymin;
            aabb.max[0] = xmax;
            aabb.max[1] = ymax;

            return aabb;
        },

        /**
         * Expands the first axis-aligned 2D boundary to enclose the second, if required.
         *
         * @method expandAABB3
         * @static
         * @param {*} aabb1 First AABB
         * @param {*} aabb2 Second AABB
         * @returns {*} The second AABB
         */
        expandAABB2: function (aabb1, aabb2) {

            if (aabb1.min[0] > aabb2.min[0]) {
                aabb1.min[0] = aabb2.min[0];
            }

            if (aabb1.min[1] > aabb2.min[1]) {
                aabb1.min[1] = aabb2.min[1];
            }

            if (aabb1.max[0] < aabb2.max[0]) {
                aabb1.max[0] = aabb2.max[0];
            }

            if (aabb1.max[1] < aabb2.max[1]) {
                aabb1.max[1] = aabb2.max[1];
            }

            return aabb2;
        },

        /**
         * Expands an axis-aligned 2D boundary to enclose the given point, if required.
         *
         * @method expandAABB2Point2
         * @static
         * @param {*} aabb AABB
         * @param {*} p Point
         * @returns {*} The AABB
         */
        expandAABB2Point2: function (aabb, p) {

            if (aabb.min[0] > p[0]) {
                aabb.min[0] = p[0];
            }

            if (aabb.min[1] > p[1]) {
                aabb.min[1] = p[1];
            }

            if (aabb.max[0] < p[0]) {
                aabb.max[0] = p[0];
            }

            if (aabb.max[1] < p[1]) {
                aabb.max[1] = p[1];
            }

            return aabb;
        },

        AABB2ToCanvas: function (aabb, canvasWidth, canvasHeight, aabb2) {

            aabb2 = aabb2 || aabb;

            var xmin = (aabb.min[0] + 1.0) * 0.5;
            var ymin = (aabb.min[1] + 1.0) * 0.5;
            var xmax = (aabb.max[0] + 1.0) * 0.5;
            var ymax = (aabb.max[1] + 1.0) * 0.5;

            aabb2.min[0] = Math.floor(xmin * canvasWidth);
            aabb2.min[1] = canvasHeight - Math.floor(ymax * canvasHeight);
            aabb2.max[0] = Math.floor(xmax * canvasWidth);
            aabb2.max[1] = canvasHeight -Math.floor(ymin * canvasHeight);

            return aabb;
        },

        /**
         * Builds normal vectors from positions and indices.
         *
         * @method buildTangents
         * @static
         * @param {Array of Number} positions One-dimensional flattened array of positions.
         * @param {Array of Number} indices One-dimensional flattened array of indices.*
         * @returns {Array of Number} One-dimensional flattened array of normal vectors.
         */
        buildNormals: function (positions, indices) {

            var nvecs = new Array(positions.length / 3);
            var j0;
            var j1;
            var j2;
            var v1;
            var v2;
            var v3;

            for (var i = 0, len = indices.length; i < len; i += 3) {
                j0 = indices[i + 0];
                j1 = indices[i + 1];
                j2 = indices[i + 2];

                v1 = [positions[j0 * 3 + 0], positions[j0 * 3 + 1], positions[j0 * 3 + 2]];
                v2 = [positions[j1 * 3 + 0], positions[j1 * 3 + 1], positions[j1 * 3 + 2]];
                v3 = [positions[j2 * 3 + 0], positions[j2 * 3 + 1], positions[j2 * 3 + 2]];

                v2 = XEO.math.subVec3(v2, v1, [0, 0, 0]);
                v3 = XEO.math.subVec3(v3, v1, [0, 0, 0]);

                var n = XEO.math.normalizeVec3(XEO.math.cross3Vec3(v2, v3, [0, 0, 0]), [0, 0, 0]);

                if (!nvecs[j0]) nvecs[j0] = [];
                if (!nvecs[j1]) nvecs[j1] = [];
                if (!nvecs[j2]) nvecs[j2] = [];

                nvecs[j0].push(n);
                nvecs[j1].push(n);
                nvecs[j2].push(n);
            }

            var normals = new Array(positions.length);

            // now go through and average out everything
            for (var i = 0, len = nvecs.length; i < len; i++) {
                var count = nvecs[i].length;
                var x = 0;
                var y = 0;
                var z = 0;
                for (var j = 0; j < count; j++) {
                    x += nvecs[i][j][0];
                    y += nvecs[i][j][1];
                    z += nvecs[i][j][2];
                }
                normals[i * 3 + 0] = (x / count);
                normals[i * 3 + 1] = (y / count);
                normals[i * 3 + 2] = (z / count);
            }

            return normals;
        },


        /**
         * Builds vertex tangent vectors from positions, UVs and indices
         *
         * @method buildTangents
         * @static
         * @param {Array of Number} positions One-dimensional flattened array of positions.
         * @param {Array of Number} indices One-dimensional flattened array of indices.
         * @param {Array of Number} uv One-dimensional flattened array of UV coordinates.
         * @returns {Array of Number} One-dimensional flattened array of tangents.
         */
        buildTangents: function (positions, indices, uv) {

            var tangents = [];

            // The vertex arrays needs to be calculated
            // before the calculation of the tangents

            for (var location = 0; location < indices.length; location += 3) {

                // Recontructing each vertex and UV coordinate into the respective vectors

                var index = indices[location];

                var v0 = [positions[index * 3], positions[(index * 3) + 1], positions[(index * 3) + 2]];
                var uv0 = [uv[index * 2], uv[(index * 2) + 1]];

                index = indices[location + 1];

                var v1 = [positions[index * 3], positions[(index * 3) + 1], positions[(index * 3) + 2]];
                var uv1 = [uv[index * 2], uv[(index * 2) + 1]];

                index = indices[location + 2];

                var v2 = [positions[index * 3], positions[(index * 3) + 1], positions[(index * 3) + 2]];
                var uv2 = [uv[index * 2], uv[(index * 2) + 1]];

                var deltaPos1 = XEO.math.subVec3(v1, v0, []);
                var deltaPos2 = XEO.math.subVec3(v2, v0, []);

                var deltaUV1 = XEO.math.subVec2(uv1, uv0, []);
                var deltaUV2 = XEO.math.subVec2(uv2, uv0, []);

                var r = 1.0 / ((deltaUV1[0] * deltaUV2[1]) - (deltaUV1[1] * deltaUV2[0]));

                var tangent = XEO.math.mulVec3Scalar(
                    XEO.math.subVec3(
                        XEO.math.mulVec3Scalar(deltaPos1, deltaUV2[1], []),
                        XEO.math.mulVec3Scalar(deltaPos2, deltaUV1[1], []),
                        []
                    ),
                    r,
                    []
                );

                // Average the value of the vectors outs
                for (var v = 0; v < 3; v++) {
                    var addTo = indices[location + v];
                    if (typeof tangents[addTo] !== "undefined") {
                        tangents[addTo] = XEO.math.addVec3(tangents[addTo], tangent, []);
                    } else {
                        tangents[addTo] = tangent;
                    }
                }
            }

            // Deconstruct the vectors back into 1D arrays for WebGL

            var tangents2 = [];

            for (var i = 0; i < tangents.length; i++) {
                tangents2 = tangents2.concat(tangents[i]);
            }

            return tangents2;
        },

        /**
         * Flattens a two-dimensional array into a one-dimensional array.
         *
         * @method flatten
         * @static
         * @param {Array of Arrays} a A 2D array
         * @returns Flattened 1D array
         */
        flatten: function (a) {

            var result = [];

            var i;
            var leni;
            var j;
            var lenj;
            var item;

            for (i = 0, leni = a.length; i < leni; i++) {
                item = a[i];
                for (j = 0, lenj = item.length; j < lenj; j++) {
                    result.push(item[j]);
                }
            }

            return result;
        },

        /**
         * Builds vertex and index arrays needed by color-indexed triangle picking.
         *
         * @method getPickPrimitives
         * @static
         * @param {Array of Number} positions One-dimensional flattened array of positions.
         * @param {Array of Number} indices One-dimensional flattened array of indices.
         * @param {*} [pickTris] Optional object to return the arrays on.
         * @param {Boolean} [debug] Assigns random colors to triangles when true.
         * @returns {*} Object containing the arrays, created by this method or reused from 'pickTris' parameter.
         */
        getPickPrimitives: function (positions, indices, pickTris, debug) {

            pickTris = pickTris || {};

            var pickPositions = [];
            var pickColors = [];
            var pickIndices = [];

            var index2 = 0;
            var primIndex = 0;

            // Triangle indices

            var i;
            var r;
            var g;
            var b;
            var a;

            for (var location = 0; location < indices.length; location += 3) {

                // Primitive-indexed triangle pick color

                primIndex = location + 1;


                if (debug) {
                    r = Math.random();
                    g = Math.random();
                    b = Math.random();
                    a = 1.0;
                } else {
                    b = (primIndex >> 16 & 0xFF) / 255;
                    g = (primIndex >> 8 & 0xFF) / 255;
                    r = (primIndex & 0xFF) / 255;
                    a = 1.0;
                }


                // A

                i = indices[location + 0];

                pickPositions.push(positions[i * 3 + 0]);
                pickPositions.push(positions[i * 3 + 1]);
                pickPositions.push(positions[i * 3 + 2]);

                pickColors.push(r);
                pickColors.push(g);
                pickColors.push(b);
                pickColors.push(a);

                pickIndices.push(index2++);

                // B

                i = indices[location + 1];

                pickPositions.push(positions[i * 3 + 0]);
                pickPositions.push(positions[i * 3 + 1]);
                pickPositions.push(positions[i * 3 + 2]);

                pickColors.push(r);
                pickColors.push(g);
                pickColors.push(b);
                pickColors.push(a);

                pickIndices.push(index2++);

                // C

                i = indices[location + 2];

                pickPositions.push(positions[i * 3 + 0]);
                pickPositions.push(positions[i * 3 + 1]);
                pickPositions.push(positions[i * 3 + 2]);

                pickColors.push(r);
                pickColors.push(g);
                pickColors.push(b);
                pickColors.push(a);

                pickIndices.push(index2++);
            }

            pickTris.pickPositions = pickPositions;
            pickTris.pickColors = pickColors;
            pickTris.pickIndices = pickIndices;

            return pickTris;
        },

        /**
         * Finds the intersection of a 3D ray with a 3D triangle.
         *
         * @method rayTriangleIntersect
         * @static
         * @param {Array of Number} origin Ray origin.
         * @param {Array of Number} dir Ray direction.
         * @param {Array of Number} a First triangle vertex.
         * @param {Array of Number} b Second triangle vertex.
         * @param {Array of Number} c Third triangle vertex.
         * @param {Array of Number} [isect] Intersection point.
         * @returns {Array of Number} The intersection point, or null if no intersection found.
         */
        rayTriangleIntersect: function (origin, dir, a, b, c, isect) {

            isect = isect || XEO.math.vec3();

            var EPSILON = 0.000001;

            var edge1 = XEO.math.subVec3(b, a, tempVec3);
            var edge2 = XEO.math.subVec3(c, a, tempVec3b);

            var pvec = XEO.math.cross3Vec3(dir, edge2, tempVec3c);
            var det = XEO.math.dotVec3(edge1, pvec);
            if (det < EPSILON) {
                return null;
            }

            var tvec = XEO.math.subVec3(origin, a, tempVec3d);
            var u = XEO.math.dotVec3(tvec, pvec);
            if (u < 0 || u > det) {
                return null;
            }

            var qvec = XEO.math.cross3Vec3(tvec, edge1, tempVec3e);
            var v = XEO.math.dotVec3(dir, qvec);
            if (v < 0 || u + v > det) {
                return null;
            }

            var t = XEO.math.dotVec3(edge2, qvec) / det;
            isect[0] = origin[0] + t * dir[0];
            isect[1] = origin[1] + t * dir[1];
            isect[2] = origin[2] + t * dir[2];

            return isect;
        },

        /**
         * Finds the intersection of a 3D ray with a plane defined by 3 points.
         *
         * @method rayPlaneIntersect
         * @static
         * @param {Array of Number} origin Ray origin.
         * @param {Array of Number} dir Ray direction.
         * @param {Array of Number} a First point on plane.
         * @param {Array of Number} b Second point on plane.
         * @param {Array of Number} c Third point on plane.
         * @param {Array of Number} [isect] Intersection point.
         * @returns {Array of Number} The intersection point.
         */
        rayPlaneIntersect: function (origin, dir, a, b, c, isect) {

            var math = XEO.math;

            isect = isect || math.vec3();

            dir = math.normalizeVec3(dir, tempVec3);

            var edge1 = math.subVec3(b, a, tempVec3b);
            var edge2 = math.subVec3(c, a, tempVec3c);

            var n = math.cross3Vec3(edge1, edge2, tempVec3d);
            math.normalizeVec3(n, n);

            var d = -math.dotVec3(a, n);

            var t = -(math.dotVec3(origin, n) + d) / math.dotVec3(dir, n);

            isect[0] = origin[0] + t * dir[0];
            isect[1] = origin[1] + t * dir[1];
            isect[2] = origin[2] + t * dir[2];

            return isect;
        },

        /**
         * Gets barycentric coordinates from cartesian coordinates within a triangle.
         *
         * @method cartesianToBaryCentric
         * @static
         * @param {Array of Number} cartesian Cartesian coordinates.
         * @param {Array of Number} a First triangle vertex.
         * @param {Array of Number} b Second triangle vertex.
         * @param {Array of Number} c Third triangle vertex.
         * @param {Array of Number} [bary] The barycentric coordinates.
         * @returns {Array of Number} The barycentric coordinates, or null if the triangle was invalid.
         * @returns {*}
         */
        cartesianToBarycentric: function (cartesian, a, b, c, bary) {

            var f1 = XEO.math.subVec3(a, cartesian, tempVec3);
            var f2 = XEO.math.subVec3(b, cartesian, tempVec3b);
            var f3 = XEO.math.subVec3(c, cartesian, tempVec3c);

            var t1 = XEO.math.subVec3(a, b, tempVec3d);
            var t2 = XEO.math.subVec3(a, c, tempVec3e);

            var a0 = XEO.math.lenVec3(XEO.math.cross3Vec3(t1, t2, tempVec3f));

            bary[0] = XEO.math.lenVec3(XEO.math.cross3Vec3(f2, f3, tempVec3f)) / a0;
            bary[1] = XEO.math.lenVec3(XEO.math.cross3Vec3(f3, f1, tempVec3f)) / a0;
            bary[2] = XEO.math.lenVec3(XEO.math.cross3Vec3(f1, f2, tempVec3f)) / a0;

            return bary;
        },

        cartesianToBarycentric2: function (cartesian, a, b, c, dest) {
            var math = XEO.math;

            var v0 = math.subVec3(c, a, tempVec3);
            var v1 = math.subVec3(b, a, tempVec3b);
            var v2 = math.subVec3(cartesian, a, tempVec3c);

            var dot00 = math.dotVec3(v0, v0);
            var dot01 = math.dotVec3(v0, v1);
            var dot02 = math.dotVec3(v0, v2);
            var dot11 = math.dotVec3(v1, v1);
            var dot12 = math.dotVec3(v1, v2);

            var denom = ( dot00 * dot11 - dot01 * dot01 );

            // Colinear or singular triangle

            if (denom === 0) {

                // Arbitrary location outside of triangle

                return null;
            }

            var invDenom = 1 / denom;

            var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
            var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

            dest[0] = 1 - u - v;
            dest[1] = v;
            dest[2] = u;

            return dest;
        },

        /**
         * Returns true if the given barycentric coordinates are within their triangle.
         *
         * @method barycentricInsideTriangle
         * @static
         * @param {Array of Number} bary Barycentric coordinates.
         * @returns {Boolean} True if the barycentric coordinates are inside their triangle.
         * @returns {*}
         */
        barycentricInsideTriangle: function (bary) {

            var v = bary[1];
            var u = bary[2];

            return (u >= 0) && (v >= 0) && (u + v < 1);
        },

        /**
         * Gets cartesian coordinates from barycentric coordinates within a triangle.
         *
         * @method barycentricToCartesian
         * @static
         * @param {Array of Number} bary The barycentric coordinate.
         * @param {Array of Number} a First triangle vertex.
         * @param {Array of Number} b Second triangle vertex.
         * @param {Array of Number} c Third triangle vertex.
         * @param {Array of Number} [cartesian] Cartesian coordinates.
         * @returns {Array of Number} The cartesian coordinates, or null if the triangle was invalid.
         * @returns {*}
         */
        barycentricToCartesian2: function (bary, a, b, c, cartesian) {

            cartesian = cartesian || XEO.math.vec3();

            var u = bary[0];
            var v = bary[1];
            var w = bary[2];

            cartesian[0] = a[0] * u + b[0] * v + c[0] * w;
            cartesian[1] = a[1] * u + b[1] * v + c[1] * w;
            cartesian[2] = a[2] * u + b[2] * v + c[2] * w;

            return cartesian;
        },


        identityQuaternion: function (dest) {
            dest = dest || XEO.math.vec4();
            dest[0] = 0.0;
            dest[1] = 0.0;
            dest[2] = 0.0;
            dest[3] = 1.0;
            return dest;
        },

        vec3PairToQuaternion: function (u, v, dest) {

            dest = dest || XEO.math.vec4();

            var math = XEO.math;

            var norm_u_norm_v = Math.sqrt(math.dotVec3(u, u) * math.dotVec3(v, v));
            var real_part = norm_u_norm_v + math.dotVec3(u, v);

            var w;

            if (real_part < 0.00000001 * norm_u_norm_v) {

                // If u and v are exactly opposite, rotate 180 degrees
                // around an arbitrary orthogonal axis. Axis normalisation
                // can happen later, when we normalise the quaternion.

                real_part = 0.0;

                if (Math.abs(u[0]) > Math.abs(u[2])) {

                    dest[0] = -u[1];
                    dest[1] = u[0];
                    dest[2] = 0;

                } else {
                    dest[0] = 0;
                    dest[1] = -u[2];
                    dest[2] = u[1]
                }

            } else {

                // Otherwise, build quaternion the standard way.
                math.cross3Vec3(u, v, dest);
            }

            dest[3] = real_part;

            return math.normalizeQuaternion(dest);
        },

        angleAxisToQuaternion: function (x, y, z, degrees, dest) {
            dest = dest || XEO.math.vec4();
            var angleRad = (degrees / 180.0) * Math.PI;
            var halfAngle = angleRad / 2.0;
            var fsin = Math.sin(halfAngle);
            dest[0] = fsin * x;
            dest[1] = fsin * y;
            dest[2] = fsin * z;
            dest[4] = Math.cos(halfAngle);
            return dest;
        },

        mulQuaternions: function (p, q, dest) {
            dest = dest || XEO.math.vec4();
            var p0 = p[0], p1 = p[1], p2 = p[2], p3 = p[3];
            var q0 = q[0], q1 = q[1], q2 = q[2], q3 = q[3];
            dest[0] = p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1;
            dest[1] = p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2;
            dest[2] = p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0;
            dest[3] = p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2;
            return dest;
        },

        quaternionToMat4: function (q, dest) {

            dest = XEO.math.identityMat4(dest);

            var q0 = q[0];
            var q1 = q[1];
            var q2 = q[2];
            var q3 = q[3];

            var tx = 2.0 * q0;
            var ty = 2.0 * q1;
            var tz = 2.0 * q2;

            var twx = tx * q3;
            var twy = ty * q3;
            var twz = tz * q3;

            var txx = tx * q0;
            var txy = ty * q0;
            var txz = tz * q0;

            var tyy = ty * q1;
            var tyz = tz * q1;
            var tzz = tz * q2;

            dest[0] = 1.0 - (tyy + tzz);
            dest[1] = txy - twz;
            dest[2] = txz + twy;

            dest[4] = txy + twz;
            dest[5] = 1.0 - (txx + tzz);
            dest[6] = tyz - twx;

            dest[8] = txz - twy;
            dest[9] = tyz + twx;
            dest[10] = 1.0 - (txx + tyy);

            return dest;
        },

        normalizeQuaternion: function (q, dest) {
            dest = dest || q;
            var len = XEO.math.lenVec4([q[0], q[1], q[2], q[3]]);
            dest[0] = q[0] / len;
            dest[1] = q[1] / len;
            dest[2] = q[2] / len;
            dest[3] = q[3] / len;
            return dest;
        },

        conjugateQuaternion: function (q, dest) {
            dest = dest || q;
            dest[0] = -q[0];
            dest[1] = -q[1];
            dest[2] = -q[2];
            dest[3] = q[3];
            return dest;
        },

        quaternionToAngleAxis: function (q, angleAxis) {
            angleAxis = angleAxis || XEO.math.vec4();
            q = XEO.math.normalizeQuaternion(q, tempVec4);
            var q3 = q[3];
            var angle = 2 * Math.acos(q3);
            var s = Math.sqrt(1 - q3 * q3);
            if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
                angleAxis[0] = q[0];
                angleAxis[1] = q[1];
                angleAxis[2] = q[2];
            } else {
                angleAxis[0] = q[0] / s;
                angleAxis[0] = q[1] / s;
                angleAxis[0] = q[2] / s;
            }
            angleAxis[3] = angle * 57.295779579;
            return angleAxis;
        }
    };

})();;XEO.math.tangentQuadraticBezier = function (t, p0, p1, p2) {
    return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

};

XEO.math.tangentQuadraticBezier = function (t, p0, p1, p2, p3) {
    return -3 * p0 * (1 - t) * (1 - t) +
        3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +
        6 * t * p2 * (1 - t) - 3 * t * t * p2 +
        3 * t * t * p3;

};

XEO.math.tangentSpline = function (t, p0, p1, p2, p3) {

    var h00 = 6 * t * t - 6 * t;
    var h10 = 3 * t * t - 4 * t + 1;
    var h01 = -6 * t * t + 6 * t;
    var h11 = 3 * t * t - 2 * t;

    return h00 + h10 + h01 + h11;

};

// Catmull-Rom

XEO.math.catmullRomInterpolate = function (p0, p1, p2, p3, t) {
    var v0 = ( p2 - p0 ) * 0.5;
    var v1 = ( p3 - p1 ) * 0.5;
    var t2 = t * t;
    var t3 = t * t2;
    return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( -3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

};

// Bezier Curves formulas obtained from
// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

// Quad Bezier Functions

XEO.math.b2p0 = function (t, p) {
    var k = 1 - t;
    return k * k * p;

};

XEO.math.b2p1 = function (t, p) {
    return 2 * ( 1 - t ) * t * p;
};

XEO.math.b2p2 = function (t, p) {
    return t * t * p;
};

XEO.math.b2 = function (t, p0, p1, p2) {
    return this.b2p0(t, p0) + this.b2p1(t, p1) + this.b2p2(t, p2);
};

// Cubic Bezier Functions

XEO.math.b3p0 = function (t, p) {
    var k = 1 - t;
    return k * k * k * p;
};

XEO.math.b3p1 = function (t, p) {
    var k = 1 - t;
    return 3 * k * k * t * p;
};

XEO.math.b3p2 = function (t, p) {
    var k = 1 - t;
    return 3 * k * t * t * p;
};

XEO.math.b3p3 = function (t, p) {
    return t * t * t * p;
};

XEO.math.b3 = function (t, p0, p1, p2, p3) {
    return this.b3p0(t, p0) + this.b3p1(t, p1) + this.b3p2(t, p2) + this.b3p3(t, p3);
};

;/**

 **Component** is the base class for all xeoEngine components.

 ## Contents

 <Ul>
 <li><a href="#ids">Component IDs</a></li>
 <li><a href="#componentProps">Properties</a></li>
 <li><a href="#metadata">Metadata</a></li>
 <li><a href="#logging">Logging</a></li>
 <li><a href="#destruction">Destruction</a></li>
 </ul>

 ## <a name="ids">Component IDs</a>

 Every Component has an ID that's unique within the parent {{#crossLink "Scene"}}{{/crossLink}}. xeoEngine generates
 the IDs automatically by default, however you can also specify them yourself. In the example below, we're creating a
 scene comprised of {{#crossLink "Scene"}}{{/crossLink}}, {{#crossLink "Material"}}{{/crossLink}}, {{#crossLink "Geometry"}}{{/crossLink}} and
 {{#crossLink "Entity"}}{{/crossLink}} components, while letting xeoEngine generate its own ID for
 the {{#crossLink "Geometry"}}{{/crossLink}}:

 ````javascript
 // The Scene is a Component too
 var scene = new XEO.Scene({
    id: "myScene"
});

 var material = new XEO.PhongMaterial(scene, {
    id: "myMaterial"
});

 var geometry = new XEO.Geometry(scene, {
    id: "myGeometry"
});

 // Let xeoEngine automatically generate the ID for our Entity
 var entity = new XEO.Entity(scene, {
    material: material,
    geometry: geometry
});
 ````

 We can then find those components like this:

 ````javascript
 // Find the Scene
 var theScene = XEO.scenes["myScene"];

 // Find the Material
 var theMaterial = theScene.components["myMaterial"];
 ````

 ## <a name="componentProps">Properties</a>

 Almost every property on a xeoEngine Component fires a change event when you update it. For example, we can subscribe
 to the {{#crossLink "PhongMaterial/diffuse:event"}}{{/crossLink}} event that a
 {{#crossLink "Material"}}{{/crossLink}} fires when its {{#crossLink "PhongMaterial/diffuse:property"}}{{/crossLink}}
 property is updated, like so:

 ````javascript
 // Bind a change callback to a property
 var handle = material.on("diffuse", function(diffuse) {
    console.log("Material diffuse color has changed to: [" + diffuse[0] + ", " + diffuse[1] + "," + diffuse[2] + "]");
});

 // Change the property value, which fires the callback
 material.diffuse = [ 0.0, 0.5, 0.5 ];

 // Unsubscribe from the property change event
 material.off(handle);
 ````

 We can also subscribe to changes in the way components are attached to each other, since components are properties
 of other components. For example, we can subscribe to the '{{#crossLink "Entity/material:event"}}{{/crossLink}}' event that a
 {{#crossLink "Entity"}}Entity{{/crossLink}} fires when its {{#crossLink "Entity/material:property"}}{{/crossLink}}
 property is set to a different {{#crossLink "Material"}}Material{{/crossLink}}:

 ```` javascript
 // Bind a change callback to the Entity's Material
 entity1.on("material", function(material) {
    console.log("Entity's Material has changed to: " + material.id);
});

 // Now replace that Material with another
 entity1.material = new XEO.PhongMaterial({
    id: "myOtherMaterial",
    diffuse: [ 0.3, 0.3, 0.6 ]
    //..
});
 ````

 ## <a name="metadata">Metadata</a>

 You can set optional **metadata** on your Components, which can be anything you like. These are intended
 to help manage your components within your application code or content pipeline. You could use metadata to attach
 authoring or version information, like this:

 ````javascript
 // Scene with authoring metadata
 var scene = new XEO.Scene({
    id: "myScene",
    meta: {
        title: "My awesome 3D scene",
        author: "@xeolabs",
        date: "February 13 2015"
    }
});

 // Material with descriptive metadata
 var material = new XEO.PhongMaterial(scene, {
    id: "myMaterial",
    diffuse: [1, 0, 0],
    meta: {
        description: "Bright red color with no textures",
        version: "0.1",
        foo: "bar"
    }
});
 ````

 As with all properties, you can subscribe and change the metadata like this:

 ````javascript
 // Subscribe to changes to the Material's metadata
 material.on("meta", function(value) {
    console.log("Metadata changed: " + JSON.stringify(value));
});

 // Change the Material's metadata, firing our change handler
 material.meta = {
    description: "Bright red color with no textures",
    version: "0.2",
    foo: "baz"
};
 ````

 ## <a name="logging">Logging</a>

 Components have methods to log ID-prefixed messages to the JavaScript console:

 ````javascript
 material.log("Everything is fine, situation normal.");
 material.warn("Wait, whats that red light?");
 material.error("Aw, snap!");
 ````

 The logged messages will look like this in the console:

 ````text
 [LOG]   myMaterial: Everything is fine, situation normal.
 [WARN]  myMaterial: Wait, whats that red light..
 [ERROR] myMaterial: Aw, snap!
 ````

 ## <a name="destruction">Destruction</a>

 Get notification of destruction directly on the Components:

 ````javascript
 material.on("destroyed", function() {
    this.log("Component was destroyed: " + this.id);
});
 ````

 Or get notification of destruction of any Component within its {{#crossLink "Scene"}}{{/crossLink}}, indiscriminately:

 ````javascript
 scene.on("componentDestroyed", function(component) {
    this.log("Component was destroyed: " + component.id);
});
 ````

 Then destroy a component like this:

 ````javascript
 material.destroy();
 ````

 Other Components that are linked to it will fall back on a default of some sort. For example, any
 {{#crossLink "Entity"}}Entities{{/crossLink}} that were linked to our {{#crossLink "Material"}}{{/crossLink}}
 will then automatically link to the {{#crossLink "Scene"}}Scene's{{/crossLink}} default {{#crossLink "Scene/material:property"}}{{/crossLink}}.

 @class Component
 @module XEO
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Component
 within the default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} DepthBuf configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Component.
 @param [cfg.isDefault] {Boolean} Set true when this is one of xeoEngine's default components.
 */
(function () {

    "use strict";

    XEO.Component = Class.extend({

        __init: function () {


            var cfg = {};

            var arg1 = arguments[0];
            var arg2 = arguments[1];


            /**
             The parent {{#crossLink "Scene"}}{{/crossLink}} that contains this Component.

             @property scene
             @type {Scene}
             @final
             */
            this.scene = null;

            if (this.type === "XEO.Scene") {

                this.scene = this;

                if (arg1) {
                    cfg = arg1;
                }

            } else {

                if (arg1) {

                    if (arg1.type === "XEO.Scene") {

                        this.scene = arg1;

                        if (arg2) {
                            cfg = arg2;
                        }

                    } else {

                        // Create this component within the default XEO Scene

                        this.scene = XEO.scene;

                        cfg = arg1;
                    }
                } else {

                    // Create this component within the default XEO Scene

                    this.scene = XEO.scene;
                }

                this._renderer = this.scene._renderer;
            }

            /**
             Arbitrary, user-defined metadata on this component.

             @property metadata
             @type Object
             */
            this.meta = cfg.meta || {};

            /**
             Indicates whether this is one of the {{#crossLink "Scene"}}Scene{{/crossLink}}'s built-in Components.

             @property isDefault
             @type Boolean
             */
            this.isDefault = cfg.isDefault;

            /**
             Unique ID for this Component within its parent {{#crossLink "Scene"}}Scene{{/crossLink}}.

             @property id
             @type String
             @final
             */
            this.id = cfg.id;

            /**
             True as soon as this Component has been destroyed

             @property destroyed
             @type Boolean
             */
            this.destroyed = false;

            // Child components keyed to arbitrary names
            this._children = {};

            // Subscriptions for child component destructions
            this._childDestroySubs = {};

            // Subscriptions to child components needing recompilation
            this._childDirtySubs = {};

            // Pub/sub
            this._handleMap = new XEO.utils.Map(); // Subscription handle pool
            this._handleEvents = {}; // Subscription handles mapped to event names
            this._eventSubs = {}; // Event names mapped to subscribers

            this._events = {}; // Maps locations to publications

            this._eventCallDepth = 0; // Helps us catch stack overflows from recursive events

            if (this.scene && this.type !== "XEO.Scene") { // HACK: Don't add scene to itself

                // Register this component on its scene
                // Assigns this component an automatic ID if not yet assigned

                this.scene._addComponent(this);
            }

            this._updateScheduled = false;

            // Initialize this component using the configs

            if (this._init) {
                this._init(cfg);
            }
        },

        /**
         JavaScript class name for this Component.

         This is used when <a href="Scene.html#savingAndLoading">loading Scenes from JSON</a>, and is included in the JSON
         representation of this Component, so that this class may be instantiated when loading it from the JSON representation.

         For example: "XEO.AmbientLight", "XEO.ColorTarget", "XEO.Lights" etc.

         @property type
         @type String
         @final
         */
        type: "XEO.Component",

        /**
         * Initializes this component
         * @param cfg
         * @private
         */
        _init: function (cfg) {
        },

        /**
         * Fires an event on this component.
         *
         * Notifies existing subscribers to the event, retains the event to give to
         * any subsequent notifications on that location as they are made.
         *
         * @method fire
         * @param {String} event The event type name
         * @param {Object} value The event parameters
         * @param {Boolean} [forget=false] When true, does not retain for subsequent subscribers
         */
        fire: function (event, value, forget) {

            if (forget !== true) {
                this._events[event] = value; // Save notification
            }

            var subs = this._eventSubs[event];
            var sub;

            if (subs) { // Notify subscriptions

                for (var handle in subs) {
                    if (subs.hasOwnProperty(handle)) {

                        sub = subs[handle];

                        this._eventCallDepth++;

                        if (this._eventCallDepth < 300) {
                            sub.callback.call(sub.scope, value);
                        } else {
                            this.error("fire: potential stack overflow from recursive event '" + event + "' - dropping this event");
                        }

                        this._eventCallDepth--;
                    }
                }
            }
        },

        /**
         * Subscribes to an event on this component.
         *
         * The callback is be called with this component as scope.
         *
         * @method on
         * @param {String} event The event
         * @param {Function} callback Called fired on the event
         * @param {Object} [scope=this] Scope for the callback
         * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
         */
        on: function (event, callback, scope) {
            var subs = this._eventSubs[event];
            if (!subs) {
                subs = {};
                this._eventSubs[event] = subs;
            }
            var handle = this._handleMap.addItem(); // Create unique handle
            subs[handle] = {
                callback: callback,
                scope: scope || this
            };
            this._handleEvents[handle] = event;
            var value = this._events[event];
            if (value) { // A publication exists, notify callback immediately
                callback.call(scope || this, value);
            }
            return handle;
        },

        /**
         * Cancels an event subscription that was previously made with {{#crossLink "Component/on:method"}}{{/crossLink}} or
         * {{#crossLink "Component/once:method"}}{{/crossLink}}.
         *
         * @method off
         * @param {String} handle Publication handle
         */
        off: function (handle) {
            if (handle === undefined || handle === null) {
                return;
            }
            var event = this._handleEvents[handle];
            if (event) {
                delete this._handleEvents[handle];
                var locSubs = this._eventSubs[event];
                if (locSubs) {
                    delete locSubs[handle];
                }
                this._handleMap.removeItem(handle); // Release handle
            }
        },

        /**
         * Subscribes to the next occurrence of the given event, then un-subscribes as soon as the event is handled.
         *
         * This is equivalent to calling {{#crossLink "Component/on:method"}}{{/crossLink}}, and then calling
         * {{#crossLink "Component/off:method"}}{{/crossLink}} inside the callback function.
         *
         * @method once
         * @param {String} event Data event to listen to
         * @param {Function(data)} callback Called when fresh data is available at the event
         * @param {Object} [scope=this] Scope for the callback
         */
        once: function (event, callback, scope) {
            var self = this;
            var handle = this.on(event,
                function (value) {
                    self.off(handle);
                    callback(value);
                },
                scope);
        },

        /**
         * Logs a console debugging message for this component.
         *
         * The console message will have this format: *````[LOG] [<component type> <component id>: <message>````*
         *
         * Also fires the message as a {{#crossLink "Scene/log:event"}}{{/crossLink}} event on the
         * parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
         *
         * @method log
         * @param {String} message The message to log
         */
        log: function (message) {

            message = "[LOG]" + this._message(message);

            window.console.log(message);

            this.scene.fire("log", message);
        },

        _message: function (message) {
            // return " [" + (this.type.indexOf("XEO.") > -1 ? this.type.substring(4) : this.type) + " " + XEO._inQuotes(this.id) + "]: " + message;
            return " [" + this.type + " " + XEO._inQuotes(this.id) + "]: " + message;
        },

        /**
         * Logs a warning for this component to the JavaScript console.
         *
         * The console message will have this format: *````[WARN] [<component type> =<component id>: <message>````*
         *
         * Also fires the message as a {{#crossLink "Scene/warn:event"}}{{/crossLink}} event on the
         * parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
         *
         * @method warn
         * @param {String} message The message to log
         */
        warn: function (message) {

            message = "[WARN]" + this._message(message);

            window.console.warn(message);

            this.scene.fire("warn", message);
        },

        /**
         * Logs an error for this component to the JavaScript console.
         *
         * The console message will have this format: *````[ERROR] [<component type> =<component id>: <message>````*
         *
         * Also fires the message as an {{#crossLink "Scene/error:event"}}{{/crossLink}} event on the
         * parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
         *
         * @method error
         * @param {String} message The message to log
         */
        error: function (message) {

            message = "[ERROR]" + this._message(message);

            window.console.error(message);

            this.scene.fire("error", message);
        },

        /**
         * Creates a clone of this component.
         *
         * The clone will have the same properties as the original, except where
         * overridden in the given optional configs.
         *
         * The clone will share (by reference) the components of the original, unless overridden.
         *
         * For example, if this component is an {{#crossLink "Entity"}}{{/crossLink}}, then the clone
         * will be attached to the **same** instances of {{#crossLink "PhoneMaterial"}}{{/crossLink}},
         * {{#crossLink "Camera"}}{{/crossLink}} etc as this component, unless it supplies its own
         * instances for those via the configs.
         *
         * @param {*} [cfg] Configurations to override.
         * @returns {Component} The shallow clone
         */
        clone: function (cfg) {

            if (this.destroyed) {
                this.error("Clone failed - component has been destroyed");
                return;
            }

            cfg = cfg || {};

            var json = this.json;

            delete json.id;

            return new this.constructor(this.scene, XEO._apply(cfg, json));
        },

        /**
         * Adds a child component to this.
         * When component not given, attaches the scene's default instance for the given name (if any).
         * Publishes the new child component on this component, keyed to the given name.
         *
         * @param {string} name component name
         * @param {Component} child The component
         * @param {Boolean} useDefault
         * @private
         */
        _setChild: function (name, child, useDefault) {

            if (!child && useDefault !== false) {

                // No child given, fall back on default component class for the given name

                child = this.scene[name];

                //if (!child) {
                //    this.error("No default component for name '" + name + "'");
                //    return;
                //}

            } else {

                // Child ID or instance given

                // Both numeric and string IDs are supported

                if (child && XEO._isNumeric(child) || XEO._isString(child)) {

                    // Child ID given

                    var id = child;

                    child = this.scene.components[id];

                    if (!child) {

                        // Quote string IDs in errors

                        this.error("Component not found: " + XEO._inQuotes(id));
                        return;
                    }
                }
            }

            if (child && child.scene.id !== this.scene.id) {
                this.error("Not in same scene: " + child.type + " " + XEO._inQuotes(child.id));
                return;
            }

            var oldChild = this._children[name];

            if (oldChild) {

                // Child of given name already attached

                if (child && oldChild.id === child.id) {

                    // Reject attempt to reattach same child
                    return;
                }

                // Unsubscribe from old child's destruction

                oldChild.off(this._childDestroySubs[name]);
                oldChild.off(this._childDirtySubs[name]);
            }

            if (child) {

                // Set and publish the new child on this component

                this._children[name] = child;

                // Bind destruct listener to new child to remove it
                // from this component when destroyed

                this._childDestroySubs[name] = child.on("destroyed",
                    function () {
                        this._childDestroyed(name, child);
                    }, this);

                this._childDirtySubs[name] = child.on("dirty", this._childDirty, this);

            } else {
                delete this._children[name];
            }

            this.fire("dirty", this);

            this.fire(name, child);

            return child;
        },

        // Callbacks as members to reduce memory churn

        /**
         * @private
         */
        _childDestroyed: function (name, child) {

            // Child destroyed
            delete this._children[name];

            // Try to fall back on default child
            var defaultComponent = this.scene[name];

            if (!defaultComponent || child.id === defaultComponent.id) {

                // Old child was the default,
                // so publish null child and bail

                this.fire(name, null);

                return;
            }

            // Set default child
            this._setChild(name, defaultComponent);
        },

        /**
         * @private
         */
        _childDirty: function () {
            this.fire("dirty", this);
        },

        /**
         * Protected method, called by sub-classes to queue a call to _update().
         * @protected
         */
        _scheduleUpdate: function () {

            if (!this._updateScheduled) {

                this._updateScheduled = true;
                this._buildScheduled = true;

                XEO.scheduleTask(this._doUpdate, this);
            }
        },

        /**
         * @private
         */
        _doUpdate: function () {

            if (this._updateScheduled) {

                if (this._buildScheduled) {

                    if (this._build) {
                        this._build();
                    }

                    this._buildScheduled = false;
                }

                if (this._update) {
                    this._update();
                }

                this._updateScheduled = false;
            }
        },

        /**
         * Optional virtual template method, normally implemented
         * by sub-classes to generate some data before _update gets
         * callled
         *
         * @protected
         */
        _build: null,

        /**
         * Protected virtual template method, optionally implemented
         * by sub-classes to perform a scheduled task.
         *
         * @protected
         */
        _update: null,

        /**
         * Protected template method, implemented by sub-classes to compile
         * their state into their Scene's XEO.renderer.Renderer.
         *
         * @protected
         */
        _compile: function () {
        },

        _props: {

            /**
             * JSON object containing the state of this Component.
             *
             * @property json
             * @type JSON
             * @final
             */
            json: {

                get: function () {

                    // Return component's type-specific properties,
                    // augmented with the base component properties

                    var json = {
                        type: this.type,
                        id: this.id // Only output user-defined IDs
                    };

                    if (!XEO._isEmptyObject(this.meta)) {
                        json.meta = this.meta;
                    }

                    return this._getJSON ? XEO._apply(this._getJSON(), json) : json;
                }
            },

            /**
             * String containing the serialized JSON state of this Component.
             *
             * @property string
             * @type String
             * @final
             */
            string: {

                get: function () {
                    return JSON.stringify(this.json, "\n", 4);
                }
            },

            /**
             * Experimental: string containing a JavaScript expression that would instantiate this Component.
             *
             * @property string
             * @type String
             * @final
             */
            js: {

                get: function () {
                    var json = this.json;
                    delete json.id;
                    var str = JSON.stringify(json, "\n", 4);
                    return "new " + this.type + "(" + str + ");";
                }
            }
        },

        /**
         * Destroys this component.
         *
         * Fires a {{#crossLink "Component/destroyed:event"}}{{/crossLink}} event on this Component.
         *
         * Automatically disassociates this component from other components, causing them to fall back on any
         * defaults that this component overrode on them.
         *
         * @method destroy
         */
        destroy: function () {

            // Unsubscribe from child components

            var child;

            for (var name in this._children) {
                if (this._children.hasOwnProperty(name)) {

                    child = this._children[name];

                    child.off(this._childDestroySubs[name]);
                    child.off(this._childDirtySubs[name]);
                }
            }

            // Execute subclass behaviour

            if (this._destroy) {
                this._destroy();
            }

            /**
             * Fired when this Component is destroyed.
             * @event destroyed
             */

            this.fire("destroyed", this.destroyed = true);
        },

        /**
         * Protected template method, implemented by sub-classes
         * to clean up just before the component is destroyed.
         *
         * @protected
         */
        _destroy: function () {
        }
    });

})();
;/**
 A **Scene** models a 3D scene as a fully-editable and serializable <a href="http://gameprogrammingpatterns.com/component.html" target="_other">component-entity</a> graph.

 ## Contents

 <Ul>
 <li><a href="#sceneStructure">Scene Structure</a></li>
 <li><a href="#sceneCanvas">The Scene Canvas</a></li>
 <li><a href="#findingByID">Finding Scenes and Components by ID</a></li>
 <li><a href="#defaults">The Default Scene</a></li>
 <li><a href="#savingAndLoading">Saving and Loading Scenes</a></li>
 </ul>

 ## <a name="sceneStructure">Scene Structure</a>

 A Scene contains a soup of instances of various {{#crossLink "Component"}}Component{{/crossLink}} subtypes, such as
 {{#crossLink "Entity"}}Entity{{/crossLink}}, {{#crossLink "Camera"}}Camera{{/crossLink}}, {{#crossLink "Material"}}Material{{/crossLink}},
 {{#crossLink "Lights"}}Lights{{/crossLink}} etc.  Each {{#crossLink "Entity"}}Entity{{/crossLink}} has a link to one of each of the other types,
 and the same component instances can be shared among many {{#crossLink "Entity"}}Entities{{/crossLink}}.

 *** Under the hood:*** Within xeoEngine, each {{#crossLink "Entity"}}Entity{{/crossLink}} represents a draw call,
 while its components define all the WebGL state that will be bound for that call. To render a Scene, xeoEngine traverses
 the graph to bind the states and make the draw calls, while using many optimizations for efficiency (eg. draw list caching and GL state sorting).

 <img src="../../../assets/images/Scene.png"></img>

 #### Default Components

 A Scene provides its own default *flyweight* instance of each component type
 (except for {{#crossLink "Entity"}}Entity{{/crossLink}}). Each {{#crossLink "Entity"}}Entity{{/crossLink}} you create
 will implicitly link to a default instance for each type of component that you don't explicitly link it to. For example, when you create an {{#crossLink "Entity"}}Entity{{/crossLink}} without
 a {{#crossLink "Lights"}}Lights{{/crossLink}}, the {{#crossLink "Entity"}}Entity{{/crossLink}} will link to the
 {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/lights:property"}}{{/crossLink}}. This mechanism
 provides ***training wheels*** to help you learn the API, and also helps keep examples simple, where many of the examples in this
 documentation are implicitly using those defaults when they are not central to discussion.

 At the bottom of the diagram above, the blue {{#crossLink "Material"}}Material{{/crossLink}},
 {{#crossLink "Geometry"}}Geometry{{/crossLink}} and {{#crossLink "Camera"}}Camera{{/crossLink}} components
 represent some of the defaults provided by our Scene. For brevity, the diagram only shows those three
 types of component (there are actually around two dozen).

 Note that we did not link the second {{#crossLink "Entity"}}Entity{{/crossLink}} to a
 {{#crossLink "Material"}}Material{{/crossLink}}, causing it to be implicitly linked to our Scene's
 default {{#crossLink "Material"}}Material{{/crossLink}}. That {{#crossLink "Material"}}Material{{/crossLink}}
 is the only default our {{#crossLink "Entity"}}Entities{{/crossLink}} are falling back on in this example, with other
 default component types, such as the {{#crossLink "Geometry"}}Geometry{{/crossLink}} and the {{#crossLink "Camera"}}Camera{{/crossLink}},
 hanging around dormant until an {{#crossLink "Entity"}}Entity{{/crossLink}} is linked to them.

 Note also how the same {{#crossLink "Camera"}}Camera{{/crossLink}} is linked to both of our
 {{#crossLink "Entity"}}Entities{{/crossLink}}. Whenever we update that
 {{#crossLink "Camera"}}Camera{{/crossLink}}, it's going to affect both of those
 {{#crossLink "Entity"}}Entities{{/crossLink}} in one shot. Think of the defaults as the Scene's ***global*** component
 instances, which you may optionally override on a per-{{#crossLink "Entity"}}Entity{{/crossLink}} basis with your own
 component instances. In many Scenes, for example, you might not even bother to create your own {{#crossLink "Camera"}}Camera{{/crossLink}} and just
 let all your {{#crossLink "Entity"}}Entities{{/crossLink}} fall back on the default one.

 ## Example

 Here's the JavaScript for the diagram above. As mentioned earlier, note that we only provide components for our {{#crossLink "Entity"}}Entities{{/crossLink}} when we need to
 override the default components that the Scene would have provided them, and that the same component instances may be shared among multiple Entities.

 ```` javascript
 var scene = new XEO.Scene({
       id: "myScene"   // ID is optional on all components
  });

 var material = new XEO.PhongMaterial(myScene, {
       id: "myMaterial",         // We'll use this ID to show how to find components by ID
       diffuse: [ 0.6, 0.6, 0.7 ],
       specular: [ 1.0, 1.0, 1.0 ]
   });

 var geometry = new XEO.Geometry(myScene, {
       primitive: "triangles",
       positions: [...],
       normals: [...],
       uvs: [...],
       indices: [...]
  });

 var camera = new XEO.Camera(myScene);

 var entity1 = new XEO.Entity(myScene, {
       material: myMaterial,
       geometry: myGeometry,
       camera: myCamera
  });

 // Second entity uses Scene's default Material
 var entity3 = new XEO.Entity(myScene, {
       geometry: myGeometry,
       camera: myCamera
  });
 ````

 ## <a name="sceneCanvas">The Scene Canvas</a>

 See the {{#crossLink "Canvas"}}{{/crossLink}} component.

 ## <a name="findingByID">Finding Scenes and Components by ID</a>

 We can have as many Scenes as we want, and can find them by ID on the {{#crossLink "XEO"}}XEO{{/crossLink}} entity's {{#crossLink "XEO/scenes:property"}}scenes{{/crossLink}} map:

 ````javascript
 var theScene = XEO.scenes["myScene"];
 ````

 Likewise we can find a Scene's components within the Scene itself, such as the {{#crossLink "Material"}}Material{{/crossLink}} we
 created earlier:

 ````javascript
 var theMaterial = myScene.components["myMaterial"];
 ````

 ## <a name="defaults">The Default Scene</a>

 When you create components without specifying a Scene for them, xeoEngine will put them in its default Scene.

 For example:

 ```` javascript
 var material2 = new XEO.PhongMaterial({
    diffuse: { r: 0.6, g: 0.6, b: 0.7 },
    specular: { 1.0, 1.0, 1.0 }
});

 var geometry2 = new XEO.Geometry({
     primitive: "triangles",
     positions: [...],
     normals: [...],
     uvs: [...],
     indices: [...]
});

 var camera = new XEO.Camera();

 var entity1 = new XEO.Entity({
     material: material2,
     geometry: geometry2,
     camera: camera2
});
 ````

 You can then obtain the default Scene from the {{#crossLink "XEO"}}XEO{{/crossLink}} entity's
 {{#crossLink "XEO/scene:property"}}scene{{/crossLink}} property:

 ````javascript
 var theScene = XEO.scene;
 ````

 or from one of the components we just created:
 ````javascript
 var theScene = material2.scene;
 ````

 ***Note:*** xeoEngine creates the default Scene as soon as you either
 create your first Sceneless {{#crossLink "Entity"}}Entity{{/crossLink}} or reference the
 {{#crossLink "XEO"}}XEO{{/crossLink}} entity's {{#crossLink "XEO/scene:property"}}scene{{/crossLink}} property. Expect to
 see the HTML canvas for the default Scene magically appear in the page when you do that.

 ## <a name="savingAndLoading">Saving and Loading Scenes</a>

 The entire runtime state of a Scene can be serialized and deserialized to and from JSON. This means you can create a
 Scene, then save it and restore it again to exactly how it was when you saved it.

 ````javascript
 // Serialize the scene to JSON
 var json = myScene.json;

 // Create another scene from that JSON, in a fresh canvas:
 var myOtherScene = new XEO.Scene({
      json: json
  });

 ````

 ***Note:*** this will save your {{#crossLink "Geometry"}}Geometry{{/crossLink}}s' array properties
 ({{#crossLink "Geometry/positions:property"}}positions{{/crossLink}}, {{#crossLink "Geometry/normals:property"}}normals{{/crossLink}},
 {{#crossLink "Geometry/indices:property"}}indices{{/crossLink}} etc) as JSON arrays, which may stress your browser
 if those arrays are huge.

 @class Scene
 @module XEO
 @constructor
 @param [cfg] Scene parameters
 @param [cfg.id] {String} Optional ID, unique among all Scenes in xeoEngine, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Scene.
 @param [cfg.canvasId] {String} ID of existing HTML5 canvas in the DOM - creates a full-page canvas automatically if this is omitted
 @param [cfg.components] {Array(Object)} JSON array containing parameters for {{#crossLink "Component"}}Component{{/crossLink}} subtypes to immediately create within the Scene.
 @extends Component
 */
(function () {

    "use strict";

    /**
     * Fired whenever a debug message logged on a component within this Scene.
     * @event log
     * @param {String} value The debug message
     */

    /**
     * Fired whenever an error is logged on a component within this Scene.
     * @event error
     * @param {String} value The error message
     */

    /**
     * Fired whenever a warning is logged on a component within this Scene.
     * @event warn
     * @param {String} value The warning message
     */

    /**
     * Fired on each game loop iteration.
     *
     * @event tick
     * @param {String} sceneID The ID of this Scene.
     * @param {Number} startTime The time in seconds since 1970 that this Scene was instantiated.
     * @param {Number} time The time in seconds since 1970 of this "tick" event.
     * @param {Number} prevTime The time of the previous "tick" event from this Scene.
     * @param {Number} deltaTime The time in seconds since the previous "tick" event from this Scene.
     */
    XEO.Scene = XEO.Component.extend({

        type: "XEO.Scene",

        _init: function (cfg) {

            var self = this;

            this._componentIDMap = new XEO.utils.Map();

            /**
             * The epoch time (in milliseconds since 1970) when this Scene was instantiated.
             *
             * @property timeCreated
             * @type {Number}
             */
            this.startTime = (new Date()).getTime();

            /**
             * The {{#crossLink "Component"}}Component{{/crossLink}}s within
             * this Scene, mapped to their IDs.
             *
             * Will also contain the {{#crossLink "Entity"}}{{/crossLink}}s
             * contained in {{#crossLink "Entity/components:property"}}{{/crossLink}}.
             *
             * @property components
             * @type {String:XEO.Component}
             */
            this.components = {};

            /**
             * For each {{#crossLink "Component"}}Component{{/crossLink}} type, a map of
             * IDs to instances.
             *
             * @property types
             * @type {String:{String:XEO.Component}}
             */
            this.types = {};

            /**
             * The {{#crossLink "Entity"}}{{/crossLink}}s within
             * this Scene, mapped to their IDs.
             *
             * The {{#crossLink "Entity"}}{{/crossLink}}s in this map
             * will also be contained in {{#crossLink "Entity/components:property"}}{{/crossLink}}.
             *
             * @property entities
             * @type {String:XEO.Entity}
             */
            this.entities = {};

            // Contains XEO.Entities that need to be recompiled back into this._renderer
            this._dirtyEntities = {};

            /**
             * Configurations for this Scene. Set whatever properties on here
             * that will be useful to the components within the Scene.
             * @final
             * @property configs
             * @type {Configs}
             */
            this.configs = new XEO.Configs(this, cfg.configs);

            /**
             * Manages the HTML5 canvas for this Scene.
             * @final
             * @property canvas
             * @type {Canvas}
             */
            this.canvas = new XEO.Canvas(this, {
                canvas: cfg.canvas, // Can be canvas ID, canvas element, or null
                contextAttr: cfg.contextAttr || {}
            });

            // Redraw as canvas resized
            this.canvas.on("size",
                function () {
                    self._renderer.imageDirty = true;
                    self._renderer.render({
                        force: true,
                        clear: true
                    });
                });

            this.canvas.on("webglContextFailed",
                function () {
                    alert("xeoEngine failed to find WebGL!");
                });

            this._renderer = new XEO.renderer.Renderer(XEO.stats, {
                canvas: this.canvas,
                transparent: cfg.transparent
            });

            /**
             * Publishes input events that occur on this Scene's canvas.
             * @final
             * @property input
             * @type {Input}
             * @final
             */
            this.input = new XEO.Input(this, {
                element: this.canvas.overlay
            });

            /**
             * Tracks any asynchronous tasks that occur within this Scene.
             * @final
             * @property tasks
             * @type {Tasks}
             * @final
             */
            this.tasks = new XEO.Tasks(this);

            // Register Scene on engine
            // Do this BEFORE we add components below
            XEO._addScene(this);

            // Add components specified as JSON
            // This will also add the default components for this Scene,
            // if this JSON was serialized from a XEO.Scene instance.

            var componentJSONs = cfg.components;

            if (componentJSONs) {

                var componentJSON;
                var type;
                var constructor;

                for (var i = 0, len = componentJSONs.length; i < len; i++) {

                    componentJSON = componentJSONs[i];
                    type = componentJSON.type;

                    if (type) {

                        constructor = window[type];

                        if (constructor) {
                            new constructor(this, componentJSON);
                        }
                    }
                }
            }

            // Create the default components if not already created.
            // These may have already been created in the JSON above.

            this._initDefaults();
        },

        _initDefaults: function () {

            // Create this Scene's default components, which every
            // Entity created in this Scene will inherit by default

            this.view;
            this.project;
            this.camera;
            this.clips;
            this.colorTarget;
            this.colorBuf;
            this.depthTarget;
            this.depthBuf;
            this.visibility;
            this.modes;
            this.geometry;
            this.layer;
            this.lights;
            this.material;
            this.morphTargets;
            this.reflect;
            this.shader;
            this.shaderParams;
            this.stage;
            this.transform;
        },

        // Called by each component that is created with this Scene as parent.
        // Registers the component within this scene.
        _addComponent: function (c) {

            if (c.id) {

                // User-supplied ID

                if (this.components[c.id]) {
                    this.error("Component " + XEO._inQuotes(c.id) + " already exists");
                    return;
                }
            } else {

                // Auto-generated ID

                c.id = this._componentIDMap.addItem(c);
            }

            this.components[c.id] = c;

            // Register for class type

            //var type = c.type.indexOf("XEO.") > -1 ? c.type.substring(4) : c.type;
            var type = c.type;

            var types = this.types[c.type];

            if (!types) {
                types = this.types[type] = {};
            }

            types[c.id] = c;


            c.on("destroyed", this._componentDestroyed, this);

            if (c.type === "XEO.Entity") {

                // Component is a XEO.Entity

                c.on("dirty", this._entityDirty, this);

                this.entities[c.id] = c;

                if (this._worldBoundary) {

                    // If we currently have a World-space Scene boundary, then invalidate
                    // it whenever Entity's World-space boundary updates

                    c.worldBoundary.on("updated", this._setWorldBoundaryDirty, this);
                }

                // Update scene statistics

                XEO.stats.components.entities++;
            }

            /**
             * Fired whenever a component has been created within this Scene.
             * @event componentCreated
             * @param {Component} value The component that was created
             */
            this.fire("componentCreated", c, true);

            //self.log("Created " + c.type + " " + XEO._inQuotes(c.id));
        },

        // Callbacks as members to reduce GC churn

        _componentDestroyed: function (c) {

            this._componentIDMap.removeItem(c.id);

            delete this.components[c.id];

            var types = this.types[c.type];

            if (types) {

                delete types[c.id];

                if (XEO._isEmptyObject(types)) {
                    delete this.types[c.type];
                }
            }

            if (c.type === "XEO.Entity") {

                // Component is a XEO.Entity

                // Update scene statistics,
                // Unschedule any pending recompilation of
                // the Entity into the renderer

                XEO.stats.components.entities--;

                delete this.entities[c.id];

                delete this._dirtyEntities[c.id];
            }

            /**
             * Fired whenever a component within this Scene has been destroyed.
             * @event componentDestroyed
             * @param {Component} value The component that was destroyed
             */
            this.fire("componentDestroyed", c, true);

            //this.log("Destroyed " + c.type + " " + XEO._inQuotes(c.id));
        },

        _entityDirty: function (entity) {

            // Whenever the Entity signals dirty,
            // schedule its recompilation into the renderer

            if (!this._dirtyEntities[entity.id]) {
                this._dirtyEntities[entity.id] = entity;
            }
        },

        _props: {

            /**
             * The default projection transform provided by this Scene, which is
             * a {{#crossLink "Perspective"}}Perspective{{/crossLink}}.
             *
             * This {{#crossLink "Perspective"}}Perspective{{/crossLink}} has an
             * {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to
             * "default.project", with all other properties set to their default
             * values.
             *
             * {{#crossLink "Camera"}}Cameras{{/crossLink}} within this Scene
             * are attached to this {{#crossLink "Perspective"}}Perspective{{/crossLink}}
             * by default.
             *
             * @property project
             * @final
             * @type Perspective
             */
            project: {

                get: function () {
                    return this.components["default.project"] ||
                        new XEO.Perspective(this, {
                            id: "default.project",
                            isDefault: true
                        });
                }
            },

            /**
             * The default viewing transform provided by this Scene, which is a {{#crossLink "Lookat"}}Lookat{{/crossLink}}.
             *
             * This {{#crossLink "Lookat"}}Lookat{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.view",
             * with all other properties initialised to their default values.
             *
             * {{#crossLink "Camera"}}Cameras{{/crossLink}} within this Scene are attached to
             * this {{#crossLink "Lookat"}}Lookat{{/crossLink}} by default.
             * @property view
             * @final
             * @type Lookat
             */
            view: {

                get: function () {
                    return this.components["default.view"] ||
                        new XEO.Lookat(this, {
                            id: "default.view",
                            isDefault: true
                        });
                }
            },

            /**
             * The default {{#crossLink "Camera"}}Camera{{/crossLink}} provided by this Scene.
             *
             * This {{#crossLink "Camera"}}Camera{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.camera",
             * with all other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to
             * this {{#crossLink "Camera"}}Camera{{/crossLink}} by default.
             * @property camera
             * @final
             * @type Camera
             */
            camera: {

                get: function () {
                    return this.components["default.camera"] ||
                        new XEO.Camera(this, {
                            id: "default.camera",
                            isDefault: true,
                            project: "default.project",
                            view: "default.view"
                        });
                }
            },

            /**
             * The default modelling {{#crossLink "Transform"}}{{/crossLink}} provided by this Scene.
             *
             * This {{#crossLink "Transform"}}{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.transform",
             * with all other properties initialised to their default values (ie. an identity matrix).
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to
             * this {{#crossLink "Transform"}}{{/crossLink}} by default.
             *
             * @property transform
             * @final
             * @type Transform
             */
            transform: {

                get: function () {
                    return this.components["default.transform"] ||
                        new XEO.Transform(this, {
                            id: "default.transform",
                            isDefault: true
                        });
                }
            },

            /**
             * The default {{#crossLink "Billboard"}}Billboard{{/crossLink}} provided by this Scene.
             *
             * This {{#crossLink "Billboard"}}Billboard{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.billboard"
             * and an {{#crossLink "Billboard/active:property"}}{{/crossLink}} property set to false, to disable it.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "Billboard"}}Billboard{{/crossLink}} by default.
             *
             * @property billboard
             * @final
             * @type Billboard
             */
            billboard: {
                get: function () {
                    return this.components["default.billboard"] ||
                        new XEO.Billboard(this, {
                            id: "default.billboard",
                            active: false,
                            isDefault: true
                        });
                }
            },

            /**
             * The default {{#crossLink "Stationary"}}Stationary{{/crossLink}} provided by this Scene.
             *
             * This {{#crossLink "Stationary"}}Stationary{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.stationary"
             * and an {{#crossLink "Stationary/active:property"}}{{/crossLink}} property set to false, to disable it.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "Stationary"}}Stationary{{/crossLink}} by default.
             *
             * @property stationary
             * @final
             * @type Stationary
             */
            stationary: {
                get: function () {
                    return this.components["default.stationary"] ||
                        new XEO.Stationary(this, {
                            id: "default.stationary",
                            active: false,
                            isDefault: true
                        });
                }
            },

            /**
             * The default {{#crossLink "Clips"}}Clips{{/crossLink}} provided by this Scene.
             *
             * This {{#crossLink "Clips"}}Clips{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.clips",
             * with all other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "Clips"}}Clips{{/crossLink}} by default.
             * @property clips
             * @final
             * @type Clips
             */
            clips: {

                get: function () {
                    return this.components["default.clips"] ||
                        new XEO.Clips(this, {
                            id: "default.clips",
                            isDefault: true
                        });
                }
            },

            /**
             * The default {{#crossLink "ColorBuf"}}ColorBuf{{/crossLink}} provided by this Scene.
             *
             * This {{#crossLink "ColorBuf"}}ColorBuf{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.colorBuf",
             * with all other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "ColorBuf"}}ColorBuf{{/crossLink}} by default.
             * @property colorBuf
             * @final
             * @type ColorBuf
             */
            colorBuf: {

                get: function () {
                    return this.components["default.colorBuf"] ||
                        new XEO.ColorBuf(this, {
                            id: "default.colorBuf",
                            isDefault: true
                        });
                }
            },

            /**
             * The default {{#crossLink "ColorTarget"}}ColorTarget{{/crossLink}} provided by this Scene.
             *
             * The {{#crossLink "ColorTarget"}}DepthTarget{{/crossLink}} is
             * {{#crossLink "ColorTarget/active:property"}}inactive{{/crossLink}} by default and will have an
             * {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.depthTarget".
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "ColorTarget"}}ColorTarget{{/crossLink}} by default.
             * @property colorTarget
             * @final
             * @type ColorTarget
             */
            colorTarget: {
                get: function () {
                    return this.components["default.colorTarget"] ||
                        new XEO.ColorTarget(this, {
                            id: "default.colorTarget",
                            isDefault: true,
                            active: false
                        })
                }
            },

            /**
             * The default {{#crossLink "DepthBuf"}}DepthBuf{{/crossLink}} provided by this Scene.
             *
             * This {{#crossLink "DepthBuf"}}DepthBuf{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.depthBuf",
             * with all other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "DepthBuf"}}DepthBuf{{/crossLink}} by default.
             *
             * @property depthBuf
             * @final
             * @type DepthBuf
             */
            depthBuf: {
                get: function () {
                    return this.components["default.depthBuf"] ||
                        new XEO.DepthBuf(this, {
                            id: "default.depthBuf",
                            isDefault: true,
                            active: false
                        });
                }
            },

            /**
             * The default {{#crossLink "DepthTarget"}}DepthTarget{{/crossLink}} provided by this Scene.
             *
             * The {{#crossLink "DepthTarget"}}DepthTarget{{/crossLink}} is
             * {{#crossLink "DepthTarget/active:property"}}inactive{{/crossLink}} by default and has an
             * {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.depthTarget".
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "DepthTarget"}}DepthTarget{{/crossLink}} by default.
             * @property depthTarget
             * @final
             * @type DepthTarget
             */
            depthTarget: {
                get: function () {
                    return this.components["default.depthTarget"] ||
                        new XEO.DepthTarget(this, {
                            id: "default.depthTarget",
                            isDefault: true,
                            active: false
                        });
                }
            },

            /**
             * The default {{#crossLink "Visibility"}}Visibility{{/crossLink}} provided by this Scene.
             *
             * This {{#crossLink "Visibility"}}Visibility{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.visibility",
             * with all other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "Visibility"}}Visibility{{/crossLink}} by default.
             * @property visibility
             * @final
             * @type Visibility
             */
            visibility: {
                get: function () {
                    return this.components["default.visibility"] ||
                        new XEO.Visibility(this, {
                            id: "default.visibility",
                            isDefault: true,
                            visible: true
                        });
                }
            },

            /**
             * The default {{#crossLink "Modes"}}Modes{{/crossLink}} provided by this Scene.
             *
             * This {{#crossLink "Modes"}}Modes{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.modes",
             * with all other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "Modes"}}Modes{{/crossLink}} by default.
             * @property modes
             * @final
             * @type Modes
             */
            modes: {
                get: function () {
                    return this.components["default.modes"] ||
                        new XEO.Modes(this, {
                            id: "default.modes",
                            isDefault: true
                        });
                }
            },

            /**
             * The default geometry provided by this Scene, which is a {{#crossLink "BoxGeometry"}}BoxGeometry{{/crossLink}}.
             *
             * This {{#crossLink "BoxGeometry"}}BoxGeometry{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.geometry".
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "Geometry"}}Geometry{{/crossLink}} by default.
             * @property geometry
             * @final
             * @type BoxGeometry
             */
            geometry: {
                get: function () {
                    return this.components["default.geometry"] ||
                        new XEO.BoxGeometry(this, {
                            id: "default.geometry",
                            isDefault: true
                        });
                }
            },

            /**
             * The default {{#crossLink "Layer"}}Layer{{/crossLink}} provided by this Scene.
             *
             * This {{#crossLink "Layer"}}Layer{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.layer",
             * with all other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "Layer"}}Layer{{/crossLink}} by default.
             * @property layer
             * @final
             * @type Layer
             */
            layer: {
                get: function () {
                    return this.components["default.layer"] ||
                        new XEO.Layer(this, {
                            id: "default.layer",
                            isDefault: true,
                            priority: 0
                        });
                }
            },

            /**
             * The default {{#crossLink "Lights"}}Lights{{/crossLink}} provided
             * by this Scene.
             *
             * This {{#crossLink "Lights"}}Lights{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to *````"default.lights"````*,
             * with all other properties initialised to their default values (ie. the default set of light sources for a {{#crossLink "Lights"}}Lights{{/crossLink}}).
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "Lights"}}Lights{{/crossLink}} by default.
             *
             * @property lights
             * @final
             * @type Lights
             */
            lights: {
                get: function () {
                    return this.components["default.lights"] ||
                        new XEO.Lights(this, {
                            id: "default.lights",
                            isDefault: true,

                            // By default a XEO.Lights has an empty lights
                            // property, so we must provide some lights

                            lights: [

                                // Ambient light source #0
                                new XEO.AmbientLight(this, {
                                    id: "default.light0",
                                    color: [0.8, 0.8, 0.9],
                                    intensity: 0.6
                                }),

                                // Directional light source #1
                                new XEO.DirLight(this, {
                                    id: "default.light1",
                                    dir: [-0.5, -0.5, 1.0],
                                    color: [1.0, 1.0, 0.9],
                                    intensity: 0.5,
                                    space: "world"
                                }),
                                //
                                // Directional light source #2
                                new XEO.DirLight(this, {
                                    id: "default.light2",
                                    dir: [1.0, -0.9, 0.7],
                                    color: [1.0, 1.0, 1.0],
                                    intensity: 0.5,
                                    space: "world"
                                })
                            ]
                        });
                }
            },

            /**
             * The {{#crossLink "PhongMaterial"}}PhongMaterial{{/crossLink}} provided as the default material by this Scene.
             *
             * This {{#crossLink "PhongMaterial"}}PhongMaterial{{/crossLink}} has
             * an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.material", with all
             * other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "PhongMaterial"}}PhongMaterial{{/crossLink}} by default.
             * @property material
             * @final
             * @type PhongMaterial
             */
            material: {
                get: function () {
                    return this.components["default.material"] ||
                        new XEO.PhongMaterial(this, {
                            id: "default.material",
                            isDefault: true
                        });
                }
            },

            /**
             * The default {{#crossLink "MorphTargets"}}MorphTargets{{/crossLink}} provided by this Scene.
             *
             * This {{#crossLink "MorphTargets"}}MorphTargets{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.morphTargets",
             * with all other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "MorphTargets"}}MorphTargets{{/crossLink}} by default.
             * @property morphTargets
             * @final
             * @type MorphTargets
             */
            morphTargets: {
                get: function () {
                    return this.components["default.morphTargets"] ||
                        new XEO.MorphTargets(this, {
                            id: "default.morphTargets",
                            isDefault: true
                        });
                }
            },

            /**
             * The default {{#crossLink "Reflect"}}Reflect{{/crossLink}} provided by this Scene,
             * (which is initially an empty {{#crossLink "Reflect"}}Reflect{{/crossLink}} that has no effect).
             *
             * This {{#crossLink "Reflect"}}Reflect{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.reflect",
             * with all other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "Reflect"}}Reflect{{/crossLink}} by default.
             * @property reflect
             * @final
             * @type Reflect
             */
            reflect: {
                get: function () {
                    return this.components["default.reflect"] ||
                        new XEO.Reflect(this, {
                            id: "default.reflect",
                            isDefault: true
                        });
                }
            },

            /**
             * The default {{#crossLink "Shader"}}Shader{{/crossLink}} provided by this Scene
             * (which is initially an empty {{#crossLink "Shader"}}Shader{{/crossLink}} that has no effect).
             *
             * This {{#crossLink "Shader"}}Shader{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.shader",
             * with all other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "Shader"}}Shader{{/crossLink}} by default.
             * @property shader
             * @final
             * @type Shader
             */
            shader: {
                get: function () {
                    return this.components["default.shader"] ||
                        this.components["default.shader"] || new XEO.Shader(this, {
                            id: "default.shader",
                            isDefault: true
                        });
                }
            },

            /**
             * The default {{#crossLink "ShaderParams"}}ShaderParams{{/crossLink}} provided by this Scene.
             *
             * This {{#crossLink "ShaderParams"}}ShaderParams{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.shaderParams",
             * with all other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "ShaderParams"}}{{/crossLink}} by default.
             *
             * @property shaderParams
             * @final
             * @type ShaderParams
             */
            shaderParams: {
                get: function () {
                    return this.components["default.shaderParams"] ||
                        new XEO.ShaderParams(this, {
                            id: "default.shaderParams",
                            isDefault: true
                        });
                }
            },

            /**
             * The default {{#crossLink "Stage"}}Stage{{/crossLink}} provided by this Scene.
             *
             * This {{#crossLink "Stage"}}Stage{{/crossLink}} has
             * an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.stage" and
             * a {{#crossLink "Stage/priority:property"}}priority{{/crossLink}} equal to ````0````.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "Stage"}}Stage{{/crossLink}} by default.
             * @property stage
             * @final
             * @type Stage
             */
            stage: {
                get: function () {
                    return this.components["default.stage"] ||
                        new XEO.Stage(this, {
                            id: "default.stage",
                            priority: 0,
                            isDefault: true
                        });
                }
            },

            /**
             * The World-space 3D boundary of this Scene.
             *
             * The {{#crossLink "Boundary3D"}}{{/crossLink}} will be lazy-initialized the first time
             * you reference this property, and will persist on this Scene until you
             * call {{#crossLink "Component/destroy:method"}}{{/crossLink}} on the {{#crossLink "Boundary3D"}}{{/crossLink}}
             * again. The property will then be set to a fresh {{#crossLink "Boundary3D"}}{{/crossLink}} instance
             * next time you reference it.
             *
             * <h4>Performance</h4>
             *
             * To minimize performance overhead, only reference this property if you need it, and destroy
             * the {{#crossLink "Boundary3D"}}{{/crossLink}} as soon as you don't need it anymore.
             *
             * @property worldBoundary
             * @type Boundary3D
             * @final
             */
            worldBoundary: {

                get: function () {

                    if (!this._worldBoundary) {

                        var self = this;
                        var aabb = XEO.math.AABB3();

                        this._worldBoundary = new XEO.Boundary3D(this.scene, {

                            getDirty: function () {
                                return self._worldBoundaryDirty;
                            },

                            getAABB: function () {

                                XEO.math.collapseAABB3(aabb);

                                var entities = self.entities;
                                var entity;

                                for (var entityId in entities) {
                                    if (entities.hasOwnProperty(entityId)) {

                                        entity = entities[entityId];

                                        if (entity.modes.collidable) {

                                            // Only include boundaries of entities that are allowed
                                            // to contribute to the size of an enclosing boundary

                                            XEO.math.expandAABB3(aabb, entity.worldBoundary.aabb);
                                        }
                                    }
                                }

                                return aabb;
                            }
                        });

                        this._worldBoundary.on("destroyed",
                            function () {

                                // Now #._setWorldBoundaryDirty won't fire "update"
                                // events on the #._worldBoundary every time its called

                                self._worldBoundary = null;
                            });

                        this._setWorldBoundaryDirty();
                    }

                    return this._worldBoundary;
                }
            }
        },

        _setWorldBoundaryDirty: function () {
            this._worldBoundaryDirty = true;
            if (this._worldBoundary) {
                this._worldBoundary.fire("updated", true);
            }
        },

        /**
         * Attempts to pick an {{#crossLink "Entity"}}Entity{{/crossLink}} at the given Canvas-space coordinates.
         *
         * Ignores {{#crossLink "Entity"}}Entities{{/crossLink}} that are attached
         * to either a {{#crossLink "Stage"}}Stage{{/crossLink}} with {{#crossLink "Stage/pickable:property"}}pickable{{/crossLink}}
         * set *false* or a {{#crossLink "Modes"}}Modes{{/crossLink}} with {{#crossLink "Modes/pickable:property"}}pickable{{/crossLink}} set *false*.
         *
         * On success, will fire a {{#crossLink "Scene/picked:event"}}{{/crossLink}} event on this Scene, along with
         * a separate {{#crossLink "Entity/picked:event"}}{{/crossLink}} event on the target {{#crossLink "Entity"}}Entity{{/crossLink}}.
         *
         * ````javascript
         *
         * pick({
         *      canvasPos: [23, 131],
         *      rayPick: true
         *      });
         *
         * ````
         * @method pick
         *
         * @param {*} params Picking parameters.
         * @param {Array of Number} [params.canvasPos] Canvas-space coordinates.
         * @param {Boolean} [params.rayPick=false] Whether to ray-pick.
         * @returns {*} Hit record, returned when an {{#crossLink "Entity"}}{{/crossLink}} is picked, else null.
         */
        pick: (function () {

            // Cached vectors to avoid garbage collection

            var origin = XEO.math.vec3();
            var dir = XEO.math.vec3();

            var a = XEO.math.vec3();
            var b = XEO.math.vec3();
            var c = XEO.math.vec3();

            var triangleVertices = XEO.math.vec3();
            var position = XEO.math.vec4();
            var worldPos = XEO.math.vec4();
            var barycentric = XEO.math.vec3();

            var na = XEO.math.vec3();
            var nb = XEO.math.vec3();
            var nc = XEO.math.vec3();

            var uva = XEO.math.vec3();
            var uvb = XEO.math.vec3();
            var uvc = XEO.math.vec3();

            var tempMat4 = XEO.math.mat4();
            var tempMat4b = XEO.math.mat4();

            var tempVec2 = XEO.math.vec2();

            var tempVec4 = XEO.math.vec4();
            var tempVec4b = XEO.math.vec4();

            var tempVec3 = XEO.math.vec3();
            var tempVec3b = XEO.math.vec3();
            var tempVec3c = XEO.math.vec3();
            var tempVec3d = XEO.math.vec3();
            var tempVec3e = XEO.math.vec3();
            var tempVec3f = XEO.math.vec3();
            var tempVec3g = XEO.math.vec3();
            var tempVec3h = XEO.math.vec3();
            var tempVec3i = XEO.math.vec3();
            var tempVec3j = XEO.math.vec3();


            // Given a Entity and camvas coordinates, gets a ray
            // originating at the World-space eye position that passes
            // through the perspective projection plane. The ray is
            // returned via the origin and dir arguments.

            function getLocalRay(entity, canvasCoords, origin, dir) {

                var math = XEO.math;

                var canvas = entity.scene.canvas.canvas;

                var modelMat = entity.transform.matrix;
                var viewMat = entity.camera.view.matrix;
                var projMat = entity.camera.project.matrix;

                var vmMat = math.mulMat4(viewMat, modelMat, tempMat4);
                var pvMat = math.mulMat4(projMat, vmMat, tempMat4b);
                var pvMatInverse = math.inverseMat4(pvMat, tempMat4b);

                //var modelMatInverse = math.inverseMat4(modelMat, tempMat4c);

                // Calculate clip space coordinates, which will be in range
                // of x=[-1..1] and y=[-1..1], with y=(+1) at top

                var canvasWidth = canvas.width;
                var canvasHeight = canvas.height;

                var clipX = (canvasCoords[0] - canvasWidth / 2) / (canvasWidth / 2);  // Calculate clip space coordinates
                var clipY = -(canvasCoords[1] - canvasHeight / 2) / (canvasHeight / 2);

                var local1 = math.transformVec4(pvMatInverse, [clipX, clipY, -1, 1], tempVec4);
                local1 = math.mulVec4Scalar(local1, 1 / local1[3]);

                var local2 = math.transformVec4(pvMatInverse, [clipX, clipY, 1, 1], tempVec4b);
                local2 = math.mulVec4Scalar(local2, 1 / local2[3]);

                origin[0] = local1[0];
                origin[1] = local1[1];
                origin[2] = local1[2];

                math.subVec3(local2, local1, dir);

                math.normalizeVec3(dir);
            }

            return function (params) {

                var math = XEO.math;

                params = params || {};

                params.canvasPos = params.canvasPos || tempVec2;

                var hit = this._renderer.pick(params);

                if (hit) {

                    var entity = this.entities[hit.entity];

                    hit.entity = entity; // Swap string ID for XEO.Entity

                    if (hit.primitiveIndex !== -1) {

                        var geometry = entity.geometry;

                        if (geometry.primitive === "triangles") {

                            // Triangle picked; this only happens when the
                            // Entity has a Geometry that has primitives of type "triangle"

                            hit.primitive = "triangle";

                            // Get the World-space positions of the triangle's vertices

                            var i = hit.primitiveIndex; // Indicates the first triangle index in the indices array

                            var indices = geometry.indices;
                            var positions = geometry.positions;

                            var ia = indices[i];
                            var ib = indices[i + 1];
                            var ic = indices[i + 2];

                            triangleVertices[0] = ia;
                            triangleVertices[1] = ib;
                            triangleVertices[2] = ic;

                            hit.indices = triangleVertices;

                            a[0] = positions[(ia * 3)];
                            a[1] = positions[(ia * 3) + 1];
                            a[2] = positions[(ia * 3) + 2];

                            b[0] = positions[(ib * 3)];
                            b[1] = positions[(ib * 3) + 1];
                            b[2] = positions[(ib * 3) + 2];

                            c[0] = positions[(ic * 3)];
                            c[1] = positions[(ic * 3) + 1];
                            c[2] = positions[(ic * 3) + 2];

                            // Attempt to ray-pick the triangle; in World-space, fire a ray
                            // from the eye position through the mouse position
                            // on the perspective projection plane

                            getLocalRay(entity, params.canvasPos, origin, dir);

                            math.rayPlaneIntersect(origin, dir, a, b, c, position);

                            // Get Local-space cartesian coordinates of the ray-triangle intersection

                            hit.position = position;

                            // Get interpolated World-space coordinates

                            // Need to transform homogeneous coords

                            tempVec4[0] = position[0];
                            tempVec4[1] = position[1];
                            tempVec4[2] = position[2];
                            tempVec4[3] = 1;

                            // Get World-space cartesian coordinates of the ray-triangle intersection

                            math.transformVec4(entity.transform.matrix, tempVec4, tempVec4b);

                            worldPos[0] = tempVec4b[0];
                            worldPos[1] = tempVec4b[1];
                            worldPos[2] = tempVec4b[2];

                            hit.worldPos = worldPos;

                            // Get barycentric coordinates of the ray-triangle intersection

                            math.cartesianToBarycentric2(position, a, b, c, barycentric);

                            hit.barycentric = barycentric;

                            // Get interpolated normal vector

                            var normals = geometry.normals;

                            if (normals) {

                                na[0] = normals[(ia * 3)];
                                na[1] = normals[(ia * 3) + 1];
                                na[2] = normals[(ia * 3) + 2];

                                nb[0] = normals[(ib * 3)];
                                nb[1] = normals[(ib * 3) + 1];
                                nb[2] = normals[(ib * 3) + 2];

                                nc[0] = normals[(ic * 3)];
                                nc[1] = normals[(ic * 3) + 1];
                                nc[2] = normals[(ic * 3) + 2];

                                hit.normal = math.addVec3(math.addVec3(
                                        math.mulVec3Scalar(na, barycentric[0], tempVec3),
                                        math.mulVec3Scalar(nb, barycentric[1], tempVec3b), tempVec3c),
                                    math.mulVec3Scalar(nc, barycentric[2], tempVec3d), tempVec3e);
                            }

                            // Get interpolated UV coordinates

                            var uvs = geometry.uv;

                            if (uvs) {

                                uva[0] = uvs[(ia * 2)];
                                uva[1] = uvs[(ia * 2) + 1];

                                uvb[0] = uvs[(ib * 2)];
                                uvb[1] = uvs[(ib * 2) + 1];

                                uvc[0] = uvs[(ic * 2)];
                                uvc[1] = uvs[(ic * 2) + 1];

                                hit.uv = math.addVec3(
                                    math.addVec3(
                                        math.mulVec2Scalar(uva, barycentric[0], tempVec3f),
                                        math.mulVec2Scalar(uvb, barycentric[1], tempVec3g), tempVec3h),
                                    math.mulVec2Scalar(uvc, barycentric[2], tempVec3i), tempVec3j);
                            }
                        }
                    }

                    return hit;
                }
            };

        })(),

        /**
         * Resets this Scene to its default state.
         *
         * References to any components in this Scene will become invalid.
         *
         * @method clear
         */
        clear: function () {  // FIXME: should only clear user-created components

            for (var id in this.components) {
                if (this.components.hasOwnProperty(id)) {

                    // Each component fires "destroyed" as it is destroyed,
                    // which this Scene handles by removing the component

                    this.components[id].destroy();
                }
            }

            // Reinitialise defaults

            this._initDefaults();

            this._dirtyEntities = {};
        }

        ,

        /**
         * Displays a simple test entity.
         *
         * Clears the Scene first.
         *
         * The test entity is destroyed as soon as anything else is created in this Scene.
         *
         * @method testPattern
         */
        testPattern: function () {

            // Clear the scene

            this.clear();

            // Create spinning test entity

            var rotate = new XEO.Rotate(this, {
                xyz: [0, .5, .5],
                angle: 0
            });

            var entity = new XEO.Entity(this, {
                transform: rotate
            });

            var angle = 0;

            var spin = this.on("tick",
                function () {
                    entity.transform.angle = angle;
                    angle += 0.5;
                });

            var self = this;

            entity.on("destroyed",
                function () {
                    self.off(spin);
                });

            // Destroy spinning test entity as soon as something
            // is created subsequently in the scene

            this.on("componentCreated",
                function () {
                    entity.destroy();
                    rotate.destroy();
                });
        }
        ,

        /**
         * Compiles and renders this Scene
         * @private
         */
        _compile: function () {

            // Compile dirty entities into this._renderer

            var countCompiledEntities = 0;

            var time1 = Date.now();
            var entity;

            for (var id in this._dirtyEntities) {
                if (this._dirtyEntities.hasOwnProperty(id)) {

                    entity = this._dirtyEntities[id];

                    if (entity._valid()) {

                        entity._compile();

                        delete this._dirtyEntities[id];

                        countCompiledEntities++;
                    }
                    //if (Date.now() - time1 > 30) {
                    //
                    //    // Throttle the time we spend (re)compiling Entities each frame
                    //
                    //    break;
                    //}
                }
            }

            if (countCompiledEntities > 0) {
                //    this.log("Compiled " + countCompiledEntities + " XEO.Entity" + (countCompiledEntities > 1 ? "s" : ""));
            }

            // Render a frame
            // Only renders if there was a state update

            this._renderer.render({
                clear: true // Clear buffers
            });
        },

        _getJSON: function () {

            // Get list of component JSONs, in ascending order of component
            // creation. We need them in that order so that any dependencies
            // that exist between them are resolved correctly as the
            // components are instantiawhen when we load the JSON again.

            var components = [];
            var component;
            var priorities = [];

            for (var id in this.components) {
                if (this.components.hasOwnProperty(id)) {

                    component = this.components[id];

                    // Don't serialize service components that
                    // will always be created on this Scene

                    if (!component._getJSON) {
                        continue;
                    }

                    // Serialize in same order as creation
                    // in order to resolve inter-component dependencies

                    components.unshift(component);
                }
            }

            components.sort(function (a, b) {
                return a._componentOrder - b._componentOrder
            });

            var componentJSONs = [];

            for (var i = 0, len = components.length; i < len; i++) {
                componentJSONs.push(components[i].json);
            }

            return {
                components: componentJSONs
            };
        }
        ,

        _destroy: function () {
            this.clear();
        }
    });

})();
;/**
 * Components for animating state within Scenes.
 *
 * @module XEO
 * @submodule animation
 */;(function () {

    "use strict";


    /**
     A **MorphTargets** defines interpolation targets for morphing {{#crossLink "Geometry"}}Geometry{{/crossLink}}s on
     attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

     <img src="../../../assets/images/MorphTargets.png"></img>

     ## Example

     TODO

     @class MorphTargets
     @module XEO
     @submodule animation
     @constructor
     @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this MorphTarget in the default
     {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
     @param [cfg] {*} Configs
     @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
     @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this MorphTarget.
     @param [cfg.targets=[]] {Array} The morph targets.
     @param [cfg.factor=0] {Number} The morph factor.
     @extends Component
     */
    XEO.MorphTargets = XEO.Component.extend({

        type: "XEO.MorphTargets",

        _init: function (cfg) {

            this.scene.on("webglContextRestored",
                function () {

                });

            this.targets = cfg.targets;
            this.factor = cfg.factor;
        },


        _props: {

            /**
             * The morph targets.
             *
             *TODO
             *
             * @property targets
             * @default []
             * @type Array
             */
            targets: {

                set: function (value) {

                    /**
                     * Fired whenever this MorphTarget's  {{#crossLink "MorphTargets/targets:property"}}{{/crossLink}} property changes.
                     * @event targets
                     * @param value The property's new value
                     */
                },

                get: function () {

                }
            },

            /**
             * The morph factor
             *
             * @property factor
             * @default 0
             * @type Number
             */
            factor: {

                set: function (value) {

                    /**
                     * Fired whenever this MorphTarget's  {{#crossLink "MorphTargets/factor:property"}}{{/crossLink}} property changes.
                     * @event factor
                     * @param value The property's new value
                     */
                },

                get: function () {
                    return 0;
                    return this._state.factor;
                }
            },

            _compile: function () {
                this._renderer.MorphTargets = this._state;
            }
        },

        /**
         * JSON representation of this component
         * @property json
         * @type Object
         */

        _getJSON: function () {
            return {
                targets: this.targets,
                factor: this.factor
            };
        }
    });

})();


;/**
 A **CameraFlight** flies a {{#crossLink "Camera"}}{{/crossLink}} to a given target.

 ## Overview

 <ul>
 <li>A CameraFlight animates the {{#crossLink "Lookat"}}{{/crossLink}} attached to the {{#crossLink "Camera"}}{{/crossLink}}.</li>
 <li>A CameraFlight can be attached to a different {{#crossLink "Camera"}}{{/crossLink}} at any time.</li>
 <li>While a CameraFlight is busy flying to a target, it can be stopped, or redirected to fly to a different target.</li>
 </ul>

 A target can be:

 <ul>
 <li>specific ````eye````, ````look```` and ````up```` positions,</li>
 <li>a World-space {{#crossLink "Boundary3D"}}{{/crossLink}},</li>
 <li>an instance or ID of any {{#crossLink "Component"}}{{/crossLink}} subtype that provides a World-space</li>
 {{#crossLink "Boundary3D"}}{{/crossLink}} in a "worldBoundary" property, or</li>
 <li>an axis-aligned World-space bounding box.</li>

 </ul>

 ### Example 1: Flying to a position

 Flying the CameraFlight from the previous example to specified eye, look and up positions:

 ````Javascript
 cameraFlight.flyTo({
    eye: [-5,-5,-5],
    look: [0,0,0]
    up: [0,1,0]
 }, function() {
    // Arrived
 });
 ````
 ### Example 2: Flying to an Entity

 Flying to an {{#crossLink "Entity"}}{{/crossLink}} (which provides a World-space
 {{#crossLink "Boundary3D"}}{{/crossLink}} via its {{#crossLink "Entity/worldBoundary:property"}}{{/crossLink}} property):

 ````Javascript
 var camera = new XEO.Camera();

 // Create a CameraFlight that takes exactly ten seconds to fly
 // the Camera to each specified target
 var cameraFlight = new XEO.CameraFlight({
    camera: camera,
    duration: 20
 });

 // Create a Entity, which gets all the default components
 var entity = new Entity();

 // Fly to the Entity's worldBoundary
 cameraFlight.flyTo(entity);
 ````

 ### Example 3: Flying to a Boundary3D

 Flying the CameraFlight from the previous two examples explicitly to the World-space
 {{#crossLink "Boundary3D"}}{{/crossLink}} of the {{#crossLink "Entity"}}{{/crossLink}} property):

 ````Javascript
 var worldBoundary = entity.worldBoundary;

 cameraFlight.flyTo(worldBoundary);
 ````

 ### Example 4: Flying to an AABB

 Flying the CameraFlight from the previous two examples explicitly to the {{#crossLink "Boundary3D"}}Boundary3D's{{/crossLink}}
 axis-aligned bounding box:

 ````Javascript
 var worldBoundary = entity.worldBoundary;

 var aabb = worldBoundary.aabb;

 cameraFlight.flyTo(aabb);
 ````

 @class CameraFlight
 @author xeolabs / http://xeolabs.org
 @module XEO
 @submodule animation
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg] {String|Component|Boundary3D|Array of Number|*} Target - see class documentation above.
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this CameraFlight.
 @param [cfg.camera] {String|Camera} ID or instance of a {{#crossLink "Camera"}}Camera{{/crossLink}} to control.
 Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this CameraFlight. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/camera:property"}}camera{{/crossLink}}.
 @extends Component
 */
(function () {

    "use strict";

    // Caches to avoid garbage collection

    var tempVec3 = XEO.math.vec3();
    var tempVec3b = XEO.math.vec3();
    var tempVec3c = XEO.math.vec3();

    XEO.CameraFlight = XEO.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.CameraFlight",

        _init: function (cfg) {

            this._look1 = XEO.math.vec3();
            this._eye1 = XEO.math.vec3();
            this._up1 = XEO.math.vec3();

            this._look2 = XEO.math.vec3();
            this._eye2 = XEO.math.vec3();
            this._up2 = XEO.math.vec3();

            this._flying = false;

            this._callback = null;
            this._callbackScope = null;

            this._onTick = null;

            this._stopFOV = 55;

            this._time1 = null;
            this._time2 = null;

            this.easing = cfg.easing !== false;

            this.duration = cfg.duration || 0.5;

            this.camera = cfg.camera;
        },

        /**
         * Begins flying this CameraFlight's {{#crossLink "Camera"}}{{/crossLink}} to the given target.
         *
         * <ul>
         *     <li>When the target is a boundary, the {{#crossLink "Camera"}}{{/crossLink}} will fly towards the target
         *     and stop when the target fills most of the canvas.</li>
         *     <li>When the target is an explicit {{#crossLink "Camera"}}{{/crossLink}} position, given as ````eye````, ````look```` and ````up````
         *      vectors, then this CameraFlight will interpolate the {{#crossLink "Camera"}}{{/crossLink}} to that target and stop there.</li>
         * @method flyTo
         * @param params  {*|Component} Either a parameters object or a {{#crossLink "Component"}}{{/crossLink}} subtype that has a {{#crossLink "WorldBoundary"}}{{/crossLink}}.
         * @param[params.arc=0]  {Number} Factor in range [0..1] indicating how much the
         * {{#crossLink "Camera/eye:property"}}Camera's eye{{/crossLink}} position will
         * swing away from its {{#crossLink "Camera/eye:property"}}look{{/crossLink}} position as it flies to the target.
         * @param [params.component] {String|Component} ID or instance of a component to fly to.
         * @param [params.aabb] {*}  World-space axis-aligned bounding box (AABB) target to fly to.
         * @param [params.eye] {Array of Number} Position to fly the eye position to.
         * @param [params.look] {Array of Number} Position to fly the look position to.
         * @param [params.up] {Array of Number} Position to fly the up vector to.
         * @param [callback] {Function} Callback fired on arrival
         * @param [scope] {Object} Optional scope for callback
         */
        flyTo: function (params, callback, scope) {

            if (this._flying) {
                this.stop();
            }

            var camera = this._children.camera;

            if (!camera) {
                if (callback) {
                    scope ? callback.call(scope) : callback();
                }
                return;
            }

            this._flying = false;

            this._callback = callback;
            this._callbackScope = scope;

            var lookat = camera.view;

            this._eye1[0] = lookat.eye[0];
            this._eye1[1] = lookat.eye[1];
            this._eye1[2] = lookat.eye[2];

            this._look1[0] = lookat.look[0];
            this._look1[1] = lookat.look[1];
            this._look1[2] = lookat.look[2];

            this._up1[0] = lookat.up[0];
            this._up1[1] = lookat.up[1];
            this._up1[2] = lookat.up[2];

            var aabb;
            var eye;
            var look;
            var up;

            if (worldBoundary = params.worldBoundary) {

                // Argument is a Component subtype with a worldBoundary

                aabb = worldBoundary.aabb;

            } else if (aabb = params.aabb) {

                // Argument is a Boundary3D

            } else if (params.min != undefined && params.max != undefined) {

                // Argument is an AABB

                aabb = params;

            } else if (params.eye || params.look || params.up) {

                // Argument is eye, look and up positions

                eye = params.eye;
                look = params.look;
                up = params.up;

            } else {

                // Argument must be an instance or ID of a Component (subtype)

                var component = params;

                if (XEO._isNumeric(component) || XEO._isString(component)) {

                    var componentId = component;

                    component = this.scene.components[componentId];

                    if (!component) {
                        this.error("Component not found: " + XEO._inQuotes(componentId));
                        if (callback) {
                            scope ? callback.call(scope) : callback();
                        }
                        return;
                    }
                }

                var worldBoundary = component.worldBoundary;

                if (!worldBoundary) {
                    this.error("Can't fly to component " + XEO._inQuotes(componentId) + " - does not have a worldBoundary");
                    if (callback) {
                        scope ? callback.call(scope) : callback();
                    }
                    return;
                }

                aabb = worldBoundary.aabb;
            }

            var offset = params.offset;

            if (aabb) {

                if (aabb.max[0] <= aabb.min[0] || aabb.max[1] <= aabb.min[1] || aabb.max[2] <= aabb.min[2]) {

                    // Don't fly to an empty boundary
                    return;
                }

                this._look2 = XEO.math.getAABBCenter(aabb);

                if (offset) {
                    this._look2[0] += offset[0];
                    this._look2[1] += offset[1];
                    this._look2[2] += offset[2];
                }

                var vec = XEO.math.normalizeVec3(XEO.math.subVec3(this._eye1, this._look1, tempVec3));
                var diag = XEO.math.getAABBDiag(aabb);
                var sca = Math.abs((diag) / Math.tan((params.stopFOV || this._stopFOV) / 2));

                this._eye2[0] = this._look2[0] + (vec[0] * sca);
                this._eye2[1] = this._look2[1] + (vec[1] * sca);
                this._eye2[2] = this._look2[2] + (vec[2] * sca);

                this._up2[0] = this._up1[0];
                this._up2[1] = this._up1[1];
                this._up2[2] = this._up1[2];

            } else if (eye || look || up) {

                look = look || this._look1;
                eye = eye || this._eye1;
                up = up || this._up1;

                this._look2[0] = look[0];
                this._look2[1] = look[1];
                this._look2[2] = look[2];

                this._eye2[0] = eye[0];
                this._eye2[1] = eye[1];
                this._eye2[2] = eye[2];

                this._up2[0] = up[0];
                this._up2[1] = up[1];
                this._up2[2] = up[2];
            }

            this.fire("started", params, true);

            this._time1 = Date.now();
            this._time2 = this._time1 + (params.duration ? params.duration * 1000 : this._duration);

            this._flying = true; // False as soon as we stop

            XEO.scheduleTask(this._update, this);
        },

        _update: function () {

            if (!this._flying) {
                return;
            }

            var time = Date.now();

            var t = (time - this._time1) / (this._time2 - this._time1);

            var stopping = (t >= 1);

            if (t > 1) {
                t = 1;
            }

            t = this.easing ? this._ease(t, 0, 1, 1) : t;

            var view = this._children.camera.view;

            view.eye = XEO.math.lerpVec3(t, 0, 1, this._eye1, this._eye2, tempVec3);
            view.look = XEO.math.lerpVec3(t, 0, 1, this._look1, this._look2, tempVec3b);
            view.up = XEO.math.lerpVec3(t, 0, 1, this._up1, this._up2, tempVec3c);

            if (stopping) {
                this.stop();
                return;
            }

            XEO.scheduleTask(this._update, this); // Keep flying
        },

        // Quadratic easing out - decelerating to zero velocity
        // http://gizma.com/easing

        _ease: function (t, b, c, d) {
            t /= d;
            return -c * t * (t - 2) + b;
        },

        stop: function () {

            if (!this._flying) {
                return;
            }

            //this.scene.off(this._tick);

            this._flying = false;

            this._time1 = null;
            this._time2 = null;

            var callback = this._callback;

            if (callback) {
                this._callback = null;
                this._callbackScope ? callback.call(this._callbackScope) : callback();
            }

            this.fire("stopped", true, true);
        },

        _props: {

            camera: {

                set: function (value) {

                    /**
                     * Fired whenever this CameraFlight's {{#crossLink "CameraFlight/camera:property"}}{{/crossLink}}
                     * property changes.
                     *
                     * @event camera
                     * @param value The property's new value
                     */
                    this._setChild("camera", value);

                    this.stop();
                },

                get: function () {
                    return this._children.camera;
                }
            },

            duration: {

                set: function (value) {

                    this._duration = value * 1000.0;

                    this.stop();
                },

                get: function () {
                    return this._duration / 1000.0;
                }
            }
        },

        _getJSON: function () {

            var json = {};

            if (this._children.camera) {
                json.camera = this._children.camera.id;
            }

            return json;
        },

        _destroy: function () {
            this.stop();
        }
    });

})();
;/**
 A **CameraPath** flies a {{#crossLink "Camera"}}{{/crossLink}} along a {{#crossLink "Curve"}}{{/crossLink}}.

 ## Example

 ````Javascript

 var entity = new XEO.Entity();

 var camera = new XEO.Camera();

 var spline = new XEO.SplineCurve({
            points: [
                [0, 0, 100],
                [10, 5, 60],
                [7, 2, 20],
                [2, -1, 10]
            ]
        });

 var cameraPath = new XEO.CameraPath({
    camera: camera,
    path: spline
 });

 XEO.scene.on("tick",
 function(e) {

        var t = (e.time - e.startTime) * 0.01;

        spline.t = t;
    });
 ````

 @class CameraPath
 @module XEO
 @submodule animation
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg] {*} Configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this CameraPath.
 @param [cfg.camera] {String|Camera} ID or instance of a {{#crossLink "Camera"}}Camera{{/crossLink}} to control.
 Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this CameraPath. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/camera:property"}}camera{{/crossLink}}.
 @param [cfg.path] {String|Curve} ID or instance of a {{#crossLink "Curve"}}{{/crossLink}} to move along.
 @extends Component
 */
(function () {

    "use strict";

    XEO.CameraPath = XEO.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.CameraPath",

        _init: function (cfg) {

            this.freeRotate = cfg.freeRotate;
            this.camera = cfg.camera;
            this.path = cfg.path;
        },

        _props: {

            /**
             * Flag which indicates whether the viewing direction is free to move around.
             *
             * Fires a {{#crossLink "MouseRotateCamera/freeRotate:event"}}{{/crossLink}} event on change.
             *
             * @property freeRotate
             * @default false
             * @type Boolean
             */
            freeRotate: {

                set: function (value) {

                    value = !!value;

                    this._freeRotate = value;

                    /**
                     * Fired whenever this MouseRotateCamera's {{#crossLink "MouseRotateCamera/freeRotate:property"}}{{/crossLink}} property changes.
                     * @event freeRotate
                     * @param value The property's new value
                     */
                    this.fire('freeRotate', this._freeRotate);
                },

                get: function () {
                    return this._freeRotate;
                }
            },

            /**
             * The Camera for this CameraPath.
             *
             * When set to a null or undefined value, will default to the parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s
             * default {{#crossLink "Scene/camera:property"}}{{/crossLink}}.
             *
             * Fires a {{#crossLink "CameraPath/camera:event"}}{{/crossLink}} event on change.
             *
             * @property camera
             * @type Camera
             */
            camera: {

                set: function (value) {

                    /**
                     * Fired whenever this CameraPaths's {{#crossLink "CameraPath/camera:property"}}{{/crossLink}} property changes.
                     * @event camera
                     * @param value The property's new value
                     */
                    this._setChild("camera", value);

                    this._update();
                },

                get: function () {
                    return this._children.camera;
                }
            },

            /**
             * The Curve for this CameraPath.
             *
             * Fires a {{#crossLink "CameraPath/path:event"}}{{/crossLink}} event on change.
             *
             * @property path
             * @type {Path}
             */
            path: {

                set: function (value) {

                    // Unsubscribe from old Curves's events

                    var oldPath = this._children.path;

                    if (oldPath && (!value || (value.id !== undefined ? value.id : value) !== oldPath.id)) {
                        oldPath.off(this._onPathT);
                    }

                    /**
                     * Fired whenever this CameraPaths's {{#crossLink "CameraPath/path:property"}}{{/crossLink}} property changes.
                     * @event path
                     * @param value The property's new value
                     */
                    this._setChild("path", value);

                    var newPath = this._children.path;

                    if (newPath) {

                        // Subscribe to new Path's events

                        this._onPathT = newPath.on("t", this._update, this);
                    }
                },

                get: function () {
                    return this._children.path;
                }
            }
        },

        _update: function () {

            var camera = this._children.camera;
            var path = this._children.path;

            if (!camera || !path) {
                return;
            }

            var point = path.point;
            var tangent = path.tangent;

            var view = camera.view;

            view.eye = point;

            if (!this._freeRotate) {
                view.look = [point[0] + tangent[0], point[1] + tangent[1], point[2] + tangent[2]];
            }
        },

        _getJSON: function () {

            var json = {
                freeRotate: this._freeRotate
            };

            if (this._children.camera) {
                json.camera = this._children.camera.id;
            }

            if (this._children.path) {
                json.path = this._children.path.id;
            }

            return json;
        },

        _destroy: function () {
            if (this._children.path) {
                this._children.path.off(this._onPathT);
            }
        }
    });

})();
;

/**
 A **Camera** defines a viewpoint on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>

 <li> A Camera is composed of a viewing transform and a projection transform.</li>

 <li>The viewing transform is usually a {{#crossLink "Lookat"}}Lookat{{/crossLink}}.</li>

 <li>The projection transform may be an {{#crossLink "Ortho"}}Ortho{{/crossLink}}, {{#crossLink "Frustum"}}Frustum{{/crossLink}}
 or {{#crossLink "Perspective"}}Perspective{{/crossLink}}.</li>

 <li> By default, each Camera is composed of its parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/view:property"}}{{/crossLink}} transform,
 (which is a {{#crossLink "Lookat"}}Lookat{{/crossLink}}) and default
 {{#crossLink "Scene/project:property"}}{{/crossLink}} transform (which is a {{#crossLink "Perspective"}}Perspective{{/crossLink}}).
 You would override those with your own transform components as necessary.</li>

 </ul>

 <img src="../../../assets/images/Camera.png"></img>

 ## Example

 In the example below, we have

 <ul>
 <li>a {{#crossLink "Lookat"}}{{/crossLink}} view transform,</li>
 <li>a {{#crossLink "Perspective"}}{{/crossLink}} projection transform,</li>
 <li>a Camera attached to the {{#crossLink "Lookat"}}{{/crossLink}} and {{#crossLink "Perspective"}}{{/crossLink}},</li>
 <li>a {{#crossLink "Geometry"}}{{/crossLink}} that is the default box shape, and
 <li>an {{#crossLink "Entity"}}{{/crossLink}} attached to all of the above.</li>
 </ul>


 ```` javascript
 var scene = new XEO.Scene();

 var lookat = new XEO.Lookat(scene, {
        eye: [0, 0, -10],
        look: [0, 0, 0],
        up: [0, 1, 0]
    });

 var perspective = new XEO.Lookat(scene, {
        fovy: 60,
        near: 0.1,
        far: 1000
    });

 var camera = new XEO.Camera(scene, {
        view: lookat,
        project: perspective
    });

 var geometry = new XEO.Geometry(scene);  // Defaults to a 2x2x2 box

 var entity = new XEO.Entity(scene, {
        camera: camera,
        geometry: geometry
    });

 scene.on("tick", function () {
       camera.view.rotateEyeY(0.5);
       camera.view.rotateEyeX(0.3);
    });
 ````
 @class Camera
 @module XEO
 @submodule camera
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this Camera within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 You only need to supply an ID if you need to be able to find the Camera by ID within its parent {{#crossLink "Scene"}}Scene{{/crossLink}} later.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Camera.
 @param [cfg.view] {String|XEO.Lookat} ID or instance of a view transform within the parent {{#crossLink "Scene"}}Scene{{/crossLink}}. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/view:property"}}{{/crossLink}} transform,
 which is a {{#crossLink "Lookat"}}Lookat{{/crossLink}}.
 @param [cfg.project] {String|XEO.Perspective|XEO.Ortho|XEO.Frustum} ID or instance of a projection transform
 within the parent {{#crossLink "Scene"}}Scene{{/crossLink}}. Defaults to the parent
 {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/project:property"}}{{/crossLink}} transform,
 which is a {{#crossLink "Perspective"}}Perspective{{/crossLink}}.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Camera = XEO.Component.extend({

        type: "XEO.Camera",

        _init: function (cfg) {

            this.project = cfg.project;

            this.view = cfg.view;
        },

        _props: {

            /**
             * The projection transform component for this Camera.
             *
             * When set to a null or undefined value, will default to the parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s
             * default {{#crossLink "Scene/project:property"}}project{{/crossLink}}, which is
             * a {{#crossLink "Perspective"}}Perspective{{/crossLink}}.
             *
             * Fires a {{#crossLink "Camera/project:event"}}{{/crossLink}} event on change.
             *
             * @property project
             * @type Perspective|XEO.Ortho|XEO.Frustum
             */
            project: {

                set: function (value) {

                    // Unsubscribe from old projection's events

                    var oldProject = this._children.project;

                    if (oldProject) {
                        oldProject.off(this._onProjectMatrix);
                    }

                    /**
                     * Fired whenever this Camera's {{#crossLink "Camera/project:property"}}{{/crossLink}} property changes.
                     * @event project
                     * @param value The property's new value
                     */
                    this._setChild("project", value);

                    var newProject = this._children.project;

                    if (newProject) {

                        // Subscribe to new projection's events

                        var self = this;

                        this._onProjectMatrix = newProject.on("matrix",
                            function () {
                                self.fire("projectMatrix");
                            });
                    }
                },

                get: function () {
                    return this._children.project;
                }
            },

            /**
             * The viewing transform component for this Camera.
             *
             * When set to a null or undefined value, will default to the parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s
             * default {{#crossLink "Scene/view:property"}}view{{/crossLink}}, which is
             * a {{#crossLink "Lookat"}}Lookat{{/crossLink}}.
             *
             * Fires a {{#crossLink "Camera/view:event"}}{{/crossLink}} event on change.
             *
             * @property view
             * @type Lookat
             */
            view: {

                set: function (value) {

                    // Unsubscribe from old view transform's events

                    var oldView = this._children.project;

                    if (oldView) {
                        oldView.off(this._onViewMatrix);
                    }

                    /**
                     * Fired whenever this Camera's {{#crossLink "Camera/view:property"}}{{/crossLink}} property changes.
                     *
                     * @event view
                     * @param value The property's new value
                     */
                    this._setChild("view", value);

                    var newView = this._children.view;

                    if (newView) {

                        // Subscribe to new projection's events

                        var self = this;

                        this._onViewMatrix = newView.on("matrix",
                            function () {
                                self.fire("viewMatrix");
                            });
                    }
                },

                get: function () {
                    return this._children.view;
                }
            }
        },

        _compile: function () {
            this._children.project._compile();
            this._children.view._compile();
        },

        _getJSON: function () {

            var json = {};

            if (this._children.project) {
                json.project = this._children.project.id;
            }

            if (this._children.view) {
                json.view = this._children.view.id;
            }

            return json;
        }
    });

})();
;/**
 A **Frustum** defines a perspective projection as a frustum-shaped view volume.

 ## Overview

 <ul>
 <li>{{#crossLink "Camera"}}Camera{{/crossLink}} components pair these with viewing transform components, such as
 {{#crossLink "Lookat"}}Lookat{{/crossLink}}, to define viewpoints for attached {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>
 <li>See <a href="Shader.html#inputs">Shader Inputs</a> for the variables that Ortho components create within xeoEngine's shaders.</li>
 </ul>

 <img src="../../../assets/images/Frustum.png"></img>

 ## Example

 In this example we have an {{#crossLink "Entity"}}Entity{{/crossLink}} that's attached to a
 {{#crossLink "Camera"}}Camera{{/crossLink}} that has a {{#crossLink "Lookat"}}Lookat{{/crossLink}} view transform and a Frustum
 projection transform.

 ````Javascript

 var scene = new XEO.Scene();

 var lookat = new XEO.Lookat(scene, {
        eye: [0, 0, -4],
        look: [0, 0, 0],
        up: [0, 1, 0]
    });

 var frustum = new XEO.Frustum(scene, {
        left: -0.1,
        right: 0.1,
        bottom: -0.1,
        top: 0.1,
        near: 0.15,
        far: 1000
    });

 var camera = new XEO.Camera(scene, {
        view: lookat,
        project: frustum
    });

 var geometry = new XEO.Geometry(scene);  // Defaults to a 2x2x2 box

 var entity = new XEO.Entity(scene, {
        camera: camera,
        geometry: geometry
    });

 scene.on("tick", function () {
       camera.view.rotateEyeY(0.5);
       camera.view.rotateEyeX(0.3);
    });
 ````

 @class Frustum
 @module XEO
 @submodule camera
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this Frustum within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Frustum.
 @param [cfg.left=-1] {Number} Position of the Frustum's left plane on the View-space X-axis.
 @param [cfg.right=1] {Number} Position of the Frustum's right plane on the View-space X-axis.
 @param [cfg.bottom=-1] {Number} Position of the Frustum's bottom plane on the View-space Y-axis.
 @param [cfg.top=1] {Number} Position of the Frustum's top plane on the View-space Y-axis.
 @param [cfg.near=0.1] {Number} Position of the Frustum's near plane on the View-space Z-axis.
 @param [cfg.far=1000] {Number} Position of the Frustum's far plane on the positive View-space Z-axis.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Frustum = XEO.Component.extend({

        type: "XEO.Frustum",

        _init: function (cfg) {

            this._state = new XEO.renderer.ProjTransform({
                matrix: XEO.math.identityMat4()
            });

            this._left = -1.0;
            this._right = 1.0;
            this._bottom = -1.0;
            this._top = 1.0;
            this._near = 0.1;
            this._far = 10000.0;

            // Set component properties

            this.left = cfg.left;
            this.right = cfg.right;
            this.bottom = cfg.bottom;
            this.top = cfg.top;
            this.near = cfg.near;
            this.far = cfg.far;
        },

        _props: {

            /**
             Position of this Frustum's left plane on the View-space X-axis.

             Fires a {{#crossLink "Frustum/left:event"}}{{/crossLink}} event on change.

             @property left
             @default -1.0
             @type Number
             */
            left: {

                set: function (value) {

                    this._left = (value !== undefined && value !== null) ? value : -1.0;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Frustum's {{#crossLink "Frustum/left:property"}}{{/crossLink}} property changes.
                     *
                     * @event left
                     * @param value The property's new value
                     */
                    this.fire("left", this._left);
                },

                get: function () {
                    return this._left;
                }
            },

            /**
             * Position of this Frustum's right plane on the View-space X-axis.
             *
             * Fires a {{#crossLink "Frustum/right:event"}}{{/crossLink}} event on change.
             *
             * @property right
             * @default 1.0
             * @type Number
             */
            right: {

                set: function (value) {

                    this._right = (value !== undefined && value !== null) ? value : 1.0;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Frustum's {{#crossLink "Frustum/right:property"}}{{/crossLink}} property changes.
                     *
                     * @event right
                     * @param value The property's new value
                     */
                    this.fire("right", this._right);
                },

                get: function () {
                    return this._right;
                }
            },

            /**
             * Position of this Frustum's top plane on the View-space Y-axis.
             *
             * Fires a {{#crossLink "Frustum/top:event"}}{{/crossLink}} event on change.
             *
             * @property top
             * @default 1.0
             * @type Number
             */
            top: {

                set: function (value) {

                    this._top = (value !== undefined && value !== null) ? value : 1.0;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Frustum's   {{#crossLink "Frustum/top:property"}}{{/crossLink}} property changes.
                     *
                     * @event top
                     * @param value The property's new value
                     */
                    this.fire("top", this._top);
                },

                get: function () {
                    return this._top;
                }
            },

            /**
             * Position of this Frustum's bottom plane on the View-space Y-axis.
             *
             * Fires a {{#crossLink "Frustum/bottom:event"}}{{/crossLink}} event on change.
             *
             * @property bottom
             * @default -1.0
             * @type Number
             */
            bottom: {

                set: function (value) {

                    this._bottom = (value !== undefined && value !== null) ? value : -1.0;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Frustum's   {{#crossLink "Frustum/bottom:property"}}{{/crossLink}} property changes.
                     *
                     * @event bottom
                     * @param value The property's new value
                     */
                    this.fire("bottom", this._bottom);
                },

                get: function () {
                    return this._bottom;
                }
            },

            /**
             * Position of this Frustum's near plane on the positive View-space Z-axis.
             *
             * Fires a {{#crossLink "Frustum/near:event"}}{{/crossLink}} event on change.
             *
             * @property near
             * @default 0.1
             * @type Number
             */
            near: {

                set: function (value) {

                    this._near = (value !== undefined && value !== null) ? value : 0.1;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Frustum's {{#crossLink "Frustum/near:property"}}{{/crossLink}} property changes.
                     *
                     * @event near
                     * @param value The property's new value
                     */
                    this.fire("near", this._near);
                },

                get: function () {
                    return this._near;
                }
            },

            /**
             * Position of this Frustum's far plane on the positive View-space Z-axis.
             *
             * Fires a {{#crossLink "Frustum/far:event"}}{{/crossLink}} event on change.
             *
             * @property far
             * @default 10000.0
             * @type Number
             */
            far: {

                set: function (value) {

                    this._far = (value !== undefined && value !== null) ? value : 10000.0;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Frustum's  {{#crossLink "Frustum/far:property"}}{{/crossLink}} property changes.
                     *
                     * @event far
                     * @param value The property's new value
                     */
                    this.fire("far", this._far);
                },

                get: function () {
                    return this._far;
                }
            },

            /**
             * The elements of this Frustum's projection transform matrix.
             *
             * Fires a {{#crossLink "Frustum/matrix:event"}}{{/crossLink}} event on change.
             *
             * @property matrix
             * @type {Float64Array}
             */
            matrix: {

                get: function () {

                    if (this._buildScheduled) {

                        // Matrix update is scheduled for next frame.
                        // Lazy-build the matrix now, while leaving the update
                        // scheduled. The update task will fire a "matrix" event,
                        // without needlessly rebuilding the matrix again.

                        this._build();

                        this._buildScheduled = false;
                    }

                    return this._state.matrix;
                }
            }
        },

        _build: function () {

            XEO.math.frustumMat4(
                this._left,
                this._right,
                this._bottom,
                this._top,
                this._near,
                this._far,
                this._state.matrix);
        },

        _update: function () {

            this._renderer.imageDirty = true;

            /**
             * Fired whenever this Frustum's  {{#crossLink "Lookat/matrix:property"}}{{/crossLink}} property is regenerated.
             * @event matrix
             * @param value The property's new value
             */
            this.fire("matrix", this._state.matrix);
        },

        _compile: function () {
            this._renderer.projTransform = this._state;
        },

        _getJSON: function () {
            return {
                left: this._left,
                right: this._right,
                top: this._top,
                bottom: this._bottom,
                near: this._near,
                far: this._far
            };
        },

        _destroy: function () {
            this._state.destroy();
        }
    });

})();
;/**
 A **Lookat** defines a viewing transform as an {{#crossLink "Lookat/eye:property"}}eye{{/crossLink}} position, a
 {{#crossLink "Lookat/look:property"}}look{{/crossLink}} position and an {{#crossLink "Lookat/up:property"}}up{{/crossLink}}
 vector.

 ## Overview

 <ul>
 <li>{{#crossLink "Camera"}}Camera{{/crossLink}} components pair these with projection transforms such as
 {{#crossLink "Perspective"}}Perspective{{/crossLink}}, to define viewpoints on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>
 <li>See <a href="Shader.html#inputs">Shader Inputs</a> for the variables that Lookat components create within xeoEngine's shaders.</li>
 </ul>

 <img src="../../../assets/images/Lookat.png"></img>

 ## Example

 In this example we have a Lookat that positions the eye at -4 on the World-space Z-axis, while looking at the origin.
 Then we attach our Lookat to a {{#crossLink "Camera"}}{{/crossLink}}. which we attach to an {{#crossLink "Entity"}}{{/crossLink}}.

 ````Javascript
 var scene = new XEO.Scene();

 var lookat = new XEO.Lookat(scene, {
        eye: [0, 0, -4],
        look: [0, 0, 0],
        up: [0, 1, 0],
        gimbalLockY: true // Rotate about world-space Y-axis (default is false)
    });

 var perspective = new XEO.Perspective(scene, {
        fovy: 60,
        near: 0.1,
        far: 1000
    });

 var camera = new XEO.Camera(scene, {
        view: lookat,
        project: perspective
    });

 var geometry = new XEO.Geometry(scene);  // Defaults to a 2x2x2 box

 var entity = new XEO.Entity(scene, {
        camera: camera,
        geometry: geometry
    });

 scene.on("tick", function () {
       camera.view.rotateEyeY(0.5);
       camera.view.rotateEyeX(0.3);
    });
 ````

 @class Lookat
 @module XEO
 @submodule camera
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Lookat in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Lookat.
 @param [cfg.eye=[0,0,-10]] {Array of Number} Eye position.
 @param [cfg.look=[0,0,0]] {Array of Number} The position of the point-of-interest we're looking at.
 @param [cfg.up=[0,1,0]] {Array of Number} The "up" vector.
 @param [cfg.gimbalLockY=false] {Boolean} Whether Y-axis rotation is about the World-space Y-axis or the View-space Y-axis.
 @extends Component
 @author xeolabs / http://xeolabs.com/
 */
(function () {

    "use strict";

    XEO.Lookat = XEO.Component.extend({

        type: "XEO.Lookat",

        _init: function (cfg) {

            var mat = XEO.math.identityMat4(XEO.math.mat4());
            var invMat = XEO.math.inverseMat4(mat, XEO.math.mat4());

            this._state = new XEO.renderer.ViewTransform({
                matrix: mat,
                normalMatrix: invMat,
                eye: [0, 0, -10.0],
                look: [0, 0, 0],
                up: [0, 1, 0]
            });

            this._buildScheduled = false;

            this.eye = cfg.eye;
            this.look = cfg.look;
            this.up = cfg.up;
            this.gimbalLockY = cfg.gimbalLockY;
        },

        /**
         * Rotate 'eye' about 'look', around the 'up' vector
         *
         * @param {Number} angle Angle of rotation in degrees
         */
        rotateEyeY: function (angle) {

            // Get 'look' -> 'eye' vector
            var eye2 = XEO.math.subVec3(this._state.eye, this._state.look, []);

            var mat = XEO.math.rotationMat4v(angle * 0.0174532925, this._gimbalLockY ? [0, 1, 0] : this._state.up);
            eye2 = XEO.math.transformPoint3(mat, eye2, []);

            // Set eye position as 'look' plus 'eye' vector
            this.eye = XEO.math.addVec3(eye2, this._state.look, []);

            if (this._gimbalLockY) {

                // Rotate 'up' vector about orthogonal vector
                this.up = XEO.math.transformPoint3(mat, this._state.up, []);
            }
        },

        /**
         * Rotate 'eye' about 'look' around the X-axis
         *
         * @param {Number} angle Angle of rotation in degrees
         */
        rotateEyeX: function (angle) {

            // Get 'look' -> 'eye' vector
            var eye2 = XEO.math.subVec3(this._state.eye, this._state.look, []);

            // Get orthogonal vector from 'eye' and 'up'
            var left = XEO.math.cross3Vec3(XEO.math.normalizeVec3(eye2, []), XEO.math.normalizeVec3(this._state.up, []));

            // Rotate 'eye' vector about orthogonal vector
            var mat = XEO.math.rotationMat4v(angle * 0.0174532925, left);
            eye2 = XEO.math.transformPoint3(mat, eye2, []);

            // Set eye position as 'look' plus 'eye' vector
            this.eye = XEO.math.addVec3(eye2, this._state.look, []);

            // Rotate 'up' vector about orthogonal vector
            this.up = XEO.math.transformPoint3(mat, this._state.up, []);
        },

        /**
         * Rotate 'look' about 'eye', around the 'up' vector
         *
         * <p>Applies constraints added with {@link #addConstraint}.</p>
         *
         * @param {Number} angle Angle of rotation in degrees
         */
        rotateLookY: function (angle) {

            // Get 'look' -> 'eye' vector
            var look2 = XEO.math.subVec3(this._state.look, this._state.eye, []);

            // Rotate 'look' vector about 'up' vector
            var mat = XEO.math.rotationMat4v(angle * 0.0174532925, this._state.up);
            look2 = XEO.math.transformPoint3(mat, look2, []);

            // Set look position as 'look' plus 'eye' vector
            this.look = XEO.math.addVec3(look2, this._state.eye, []);
        },

        /**
         * Rotate 'eye' about 'look' around the X-axis
         *
         * @param {Number} angle Angle of rotation in degrees
         */
        rotateLookX: function (angle) {

            // Get 'look' -> 'eye' vector
            var look2 = XEO.math.subVec3(this._state.look, this._state.eye, []);

            // Get orthogonal vector from 'eye' and 'up'
            var left = XEO.math.cross3Vec3(XEO.math.normalizeVec3(look2, []), XEO.math.normalizeVec3(this._state.up, []));

            // Rotate 'look' vector about orthogonal vector
            var mat = XEO.math.rotationMat4v(angle * 0.0174532925, left);
            look2 = XEO.math.transformPoint3(mat, look2, []);

            // Set eye position as 'look' plus 'eye' vector
            this.look = XEO.math.addVec3(look2, this._state.eye, []);

            // Rotate 'up' vector about orthogonal vector
            this.up = XEO.math.transformPoint3(mat, this._state.up, []);
        },

        /**
         * Pans the camera along X and Y axis.
         * @param pan The pan vector
         */
        pan: function (pan) {

            // Get 'look' -> 'eye' vector
            var eye2 = XEO.math.subVec3(this._state.eye, this._state.look, []);

            // Building this pan vector
            var vec = [0, 0, 0];
            var v;

            if (pan[0] !== 0) {

                // Pan along orthogonal vector to 'look' and 'up'

                var left = XEO.math.cross3Vec3(XEO.math.normalizeVec3(eye2, []), XEO.math.normalizeVec3(this._state.up, []));

                v = XEO.math.mulVec3Scalar(left, pan[0]);

                vec[0] += v[0];
                vec[1] += v[1];
                vec[2] += v[2];
            }

            if (pan[1] !== 0) {

                // Pan along 'up' vector

                v = XEO.math.mulVec3Scalar(XEO.math.normalizeVec3(this._state.up, []), pan[1]);

                vec[0] += v[0];
                vec[1] += v[1];
                vec[2] += v[2];
            }

            if (pan[2] !== 0) {

                // Pan along 'eye'- -> 'look' vector

                v = XEO.math.mulVec3Scalar(XEO.math.normalizeVec3(eye2, []), pan[2]);

                vec[0] += v[0];
                vec[1] += v[1];
                vec[2] += v[2];
            }

            this.eye = XEO.math.addVec3(this._state.eye, vec, []);
            this.look = XEO.math.addVec3(this._state.look, vec, []);
        },

        /**
         * Increments/decrements zoom factor, ie. distance between eye and look.
         * @param delta
         */
        zoom: function (delta) {

            var vec = XEO.math.subVec3(this._state.eye, this._state.look, []); // Get vector from eye to look
            var lenLook = Math.abs(XEO.math.lenVec3(vec, []));    // Get len of that vector
            var newLenLook = Math.abs(lenLook + delta);         // Get new len after zoom

            var dir = XEO.math.normalizeVec3(vec, []);  // Get normalised vector

            this.eye = XEO.math.addVec3(this._state.look, XEO.math.mulVec3Scalar(dir, newLenLook), []);
        },

        _props: {

            /**
             * Whether Y-axis rotation is about the World-space Y-axis or the View-space Y-axis.
             *
             * Fires a {{#crossLink "Lookat/gimbalLockY:event"}}{{/crossLink}} event on change.
             *
             * @property gimbalLockY
             * @default false
             * @type Boolean
             */
            gimbalLockY: {

                set: function (value) {

                    value = value !== false;

                    this._gimbalLockY = value;
                    /**
                     * Fired whenever this Lookat's  {{#crossLink "Lookat/gimbalLockY:property"}}{{/crossLink}} property changes.
                     *
                     * @event gimbalLockY
                     * @param value The property's new value
                     */
                    this.fire("gimbalLockY", this._state.gimbalLockY);
                },

                get: function () {
                    return this._gimbalLockY;
                }
            },

            /**
             * Position of this Lookat's eye.
             *
             * Fires an {{#crossLink "Lookat/eye:event"}}{{/crossLink}} event on change.
             *
             * @property eye
             * @default [0,0,-10]
             * @type Array(Number)
             */
            eye: {

                set: function (value) {

                    value = value || [0, 0, -10];

                    var eye = this._state.eye;

                    eye[0] = value[0];
                    eye[1] = value[1];
                    eye[2] = value[2];

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Lookat's  {{#crossLink "Lookat/eye:property"}}{{/crossLink}} property changes.
                     *
                     * @event eye
                     * @param value The property's new value
                     */
                    this.fire("eye", this._state.eye);
                },

                get: function () {
                    return this._state.eye;
                }
            },

            /**
             * Position of this Lookat's point-of-interest.
             *
             * Fires a {{#crossLink "Lookat/look:event"}}{{/crossLink}} event on change.
             *
             * @property look
             * @default [0,0,0]
             * @type Array(Number)
             */
            look: {

                set: function (value) {

                    value = value || [0, 0, 0];

                    var look = this._state.look;

                    look[0] = value[0];
                    look[1] = value[1];
                    look[2] = value[2];

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Lookat's  {{#crossLink "Lookat/look:property"}}{{/crossLink}} property changes.
                     *
                     * @event look
                     * @param value The property's new value
                     */
                    this.fire("look", this._state.look);
                },

                get: function () {
                    return this._state.look;
                }
            },

            /**
             * Direction of the "up" vector.
             * Fires an {{#crossLink "Lookat/up:event"}}{{/crossLink}} event on change.
             * @property up
             * @default [0,1,0]
             * @type Array(Number)
             */
            up: {

                set: function (value) {

                    value = value || [0, 1, 0];

                    var up = this._state.up;

                    up[0] = value[0];
                    up[1] = value[1];
                    up[2] = value[2];

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Lookat's  {{#crossLink "Lookat/up:property"}}{{/crossLink}} property changes.
                     *
                     * @event up
                     * @param value The property's new value
                     */
                    this.fire("up", this._state.up);
                },

                get: function () {
                    return this._state.up;
                }
            },

            /**
             * The elements of this Lookat's view transform matrix.
             *
             * Fires a {{#crossLink "Lookat/matrix:event"}}{{/crossLink}} event on change.
             *
             * @property matrix
             * @type {Float64Array}
             */
            matrix: {

                get: function () {

                    if (this._buildScheduled) {

                        // Matrix update is scheduled for next frame.
                        // Lazy-build the matrix now, while leaving the update
                        // scheduled. The update task will fire a "matrix" event,
                        // without needlessly rebuilding the matrix again.

                        this._build();

                        this._buildScheduled = false;
                    }

                    return this._state.matrix;
                }
            }
        },

        _build: function () {

            this._state.matrix = new Float32Array(XEO.math.lookAtMat4c(
                this._state.eye[0], this._state.eye[1], this._state.eye[2],
                this._state.look[0], this._state.look[1], this._state.look[2],
                this._state.up[0], this._state.up[1], this._state.up[2],
                this._state.matrix));

            this._state.normalMatrix = new Float32Array(XEO.math.transposeMat4(new Float32Array(XEO.math.inverseMat4(this._state.matrix, this._state.normalMatrix), this._state.normalMatrix)));
        },

        _update: function () {

            this._renderer.imageDirty = true;

            /**
             * Fired whenever this Lookat's  {{#crossLink "Lookat/matrix:property"}}{{/crossLink}} property is updated.
             *
             * @event matrix
             * @param value The property's new value
             */
            this.fire("matrix", this._state.matrix);
        },

        _compile: function () {
            this._renderer.viewTransform = this._state;
        },

        _getJSON: function () {
            return {
                eye: this._state.eye,
                look: this._state.look,
                up: this._state.up
            };
        },

        _destroy: function () {
            this._state.destroy();
        }
    });

})();
;/**
 An **Ortho** component defines an orthographic projection transform.

 ## Overview

 <ul>
 <li>{{#crossLink "Camera"}}Camera{{/crossLink}} components pair these with viewing transform components, such as
 {{#crossLink "Lookat"}}Lookat{{/crossLink}}, to define viewpoints on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>
 <li>Alternatively, use {{#crossLink "Perspective"}}{{/crossLink}} if you need perspective projection.</li>
 <li>See <a href="Shader.html#inputs">Shader Inputs</a> for the variables that Ortho components create within xeoEngine's shaders.</li>
 </ul>

 <img src="../../../assets/images/Ortho.png"></img>

 ## Example

 In this example we have an {{#crossLink "Entity"}}Entity{{/crossLink}} that's attached to a
 {{#crossLink "Camera"}}Camera{{/crossLink}} that has a {{#crossLink "Lookat"}}Lookat{{/crossLink}} view transform and an Ortho
 projection transform.

 ````Javascript
 var scene = new XEO.Scene();

 var lookat = new XEO.Lookat(scene, {
        eye: [0, 0, -4],
        look: [0, 0, 0],
        up: [0, 1, 0]
    });

 var ortho = new XEO.Ortho(scene, {
        left: -3.0,
        right: 3.0,
        bottom: -3.0,
        top: 3.0,
        near: 0.1,
        far: 1000
    });

 var camera = new XEO.Camera(scene, {
        view: lookat,
        project: ortho
    });

 var geometry = new XEO.Geometry(scene);  // Defaults to a 2x2x2 box

 var entity = new XEO.Entity(scene, {
        camera: camera,
        geometry: geometry
    });

 scene.on("tick",
 function () {
                camera.view.rotateEyeY(0.5);
                camera.view.rotateEyeX(0.3);
            });
 ````

 @class Ortho
 @module XEO
 @submodule camera
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this Ortho within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Ortho.
 @param [cfg.left=-1.0] {Number} Position of the left plane on the View-space X-xyz.
 @param [cfg.right=1.0] {Number} Position of the right plane on the View-space X-axis.
 @param [cfg.top=1.0] {Number} Position of the top plane on the View-space Y-axis.
 @param [cfg.bottom=-1.0] {Number} Position of the bottom plane on the View-space Y-axis.
 @param [cfg.near=0.1] {Number} Position of the near plane on the View-space Z-axis.
 @param [cfg.far=10000] {Number} Position of the far plane on the positive View-space Z-axis.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Ortho = XEO.Component.extend({

        type: "XEO.Ortho",

        _init: function (cfg) {

            this._state = new XEO.renderer.ProjTransform({
                matrix: XEO.math.identityMat4(XEO.math.mat4())
            });

            // Ortho view volume
            this._left = -1.0;
            this._right = 1.0;
            this._top = 1.0;
            this._bottom = -1.0;
            this._near = 0.1;
            this._far = 10000.0;

            // Set properties on this component
            this.left = cfg.left;
            this.right = cfg.right;
            this.top = cfg.top;
            this.bottom = cfg.bottom;
            this.near = cfg.near;
            this.far = cfg.far;
        },

        _props: {

            /**
             * Position of this Ortho's left plane on the View-space X-axis.
             *
             * Fires a {{#crossLink "Ortho/left:event"}}{{/crossLink}} event on change.
             *
             * @property left
             * @default -1.0
             * @type Number
             */
            left: {

                set: function (value) {

                    this._left = (value !== undefined && value !== null) ? value : -1.0;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Ortho's  {{#crossLink "Ortho/left:property"}}{{/crossLink}} property changes.
                     *
                     * @event left
                     * @param value The property's new value
                     */
                    this.fire("left", this._left);
                },

                get: function () {
                    return this._left;
                }
            },

            /**
             * Position of this Ortho's right plane on the View-space X-axis.
             *
             * Fires a {{#crossLink "Ortho/right:event"}}{{/crossLink}} event on change.
             *
             * @property right
             * @default 1.0
             * @type Number
             */
            right: {

                set: function (value) {

                    this._right = (value !== undefined && value !== null) ? value : 1.0;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Ortho's  {{#crossLink "Ortho/right:property"}}{{/crossLink}} property changes.
                     *
                     * @event right
                     * @param value The property's new value
                     */
                    this.fire("right", this._right);
                },

                get: function () {
                    return this._right;
                }
            },

            /**
             * Position of this Ortho's top plane on the View-space Y-axis.
             *
             * Fires a {{#crossLink "Ortho/top:event"}}{{/crossLink}} event on change.
             *
             * @property top
             * @default 1.0
             * @type Number
             */
            top: {

                set: function (value) {

                    this._top = (value !== undefined && value !== null) ? value : 1.0;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Ortho's  {{#crossLink "Ortho/top:property"}}{{/crossLink}} property changes.
                     *
                     * @event top
                     * @param value The property's new value
                     */
                    this.fire("top", this._top);
                },

                get: function () {
                    return this._top;
                }
            },

            /**
             * Position of this Ortho's bottom plane on the View-space Y-axis.
             *
             * Fires a {{#crossLink "Ortho/bottom:event"}}{{/crossLink}} event on change.
             *
             * @property bottom
             * @default -1.0
             * @type Number
             */
            bottom: {

                set: function (value) {

                    this._bottom = (value !== undefined && value !== null) ? value : -1.0;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Ortho's  {{#crossLink "Ortho/bottom:property"}}{{/crossLink}} property changes.
                     *
                     * @event bottom
                     * @param value The property's new value
                     */
                    this.fire("bottom", this._bottom);
                },

                get: function () {
                    return this._bottom;
                }
            },

            /**
             * Position of this Ortho's near plane on the positive View-space Z-axis.
             *
             * Fires a {{#crossLink "Ortho/near:event"}}{{/crossLink}} event on change.
             *
             * @property near
             * @default 0.1
             * @type Number
             */
            near: {

                set: function (value) {

                    this._near = (value !== undefined && value !== null) ? value :  0.1;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Ortho's  {{#crossLink "Ortho/near:property"}}{{/crossLink}} property changes.
                     *
                     * @event near
                     * @param value The property's new value
                     */
                    this.fire("near", this._near);
                },

                get: function () {
                    return this._near;
                }
            },

            /**
             * Position of this Ortho's far plane on the positive View-space Z-axis.
             *
             * Fires a {{#crossLink "Ortho/far:event"}}{{/crossLink}} event on change.
             *
             * @property far
             * @default 10000.0
             * @type Number
             */
            far: {

                set: function (value) {

                    this._far = (value !== undefined && value !== null) ? value :  10000.0;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Ortho's {{#crossLink "Ortho/far:property"}}{{/crossLink}} property changes.
                     *
                     * @event far
                     * @param value The property's new value
                     */
                    this.fire("far", this._far);
                },

                get: function () {
                    return this._far;
                }
            },

            /**
             * The elements of this Ortho's projection transform matrix.
             *
             * Fires a {{#crossLink "Ortho/matrix:event"}}{{/crossLink}} event on change.
             *
             * @property matrix
             * @type {Float64Array}
             */
            matrix: {

                get: function () {

                    if (this._buildScheduled) {

                        // Matrix update is scheduled for next frame.
                        // Lazy-build the matrix now, while leaving the update
                        // scheduled. The update task will fire a "matrix" event,
                        // without needlessly rebuilding the matrix again.

                        this._build();

                        this._buildScheduled = false;
                    }

                    return this._state.matrix;
                }
            }
        },

        _build: function () {

            XEO.math.orthoMat4c(this._left, this._right, this._bottom, this._top, this._near, this._far, this._state.matrix);

            this._renderer.imageDirty = true;
        },

        _update: function () {

            this._renderer.imageDirty = true;

            /**
             * Fired whenever this Frustum's  {{#crossLink "Lookat/matrix:property"}}{{/crossLink}} property is regenerated.
             * @event matrix
             * @param value The property's new value
             */
            this.fire("matrix", this._state.matrix);
        },

        _compile: function () {
            this._renderer.projTransform = this._state;
        },

        _getJSON: function () {
            return {
                left: this._left,
                right: this._right,
                top: this._top,
                bottom: this._bottom,
                near: this._near,
                far: this._far
            };
        },

        _destroy: function () {
            this._state.destroy();
        }
    });

})();
;/**
 A **Perspective** component defines a perspective projection transform.

 ## Overview

 <ul>

 <li>{{#crossLink "Camera"}}Camera{{/crossLink}} components pair these with viewing transform components, such as
 {{#crossLink "Lookat"}}Lookat{{/crossLink}}, to define viewpoints on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>
 <li>Alternatively, use {{#crossLink "Ortho"}}{{/crossLink}} if you need a orthographic projection.</li>
 <li>See <a href="Shader.html#inputs">Shader Inputs</a> for the variables that Perspective components create within xeoEngine's shaders.</li>
 </ul>

 <img src="../../../assets/images/Perspective.png"></img>

 ## Example

 In this example we have an {{#crossLink "Entity"}}Entity{{/crossLink}} that's attached to a
 {{#crossLink "Camera"}}Camera{{/crossLink}} that has a {{#crossLink "Lookat"}}Lookat{{/crossLink}} view transform and a Perspective
 projection transform.

 ````Javascript
 var scene = new XEO.Scene();

 var lookat = new XEO.Lookat(scene, {
        eye: [0, 0, -4],
        look: [0, 0, 0],
        up: [0, 1, 0]
    });

 var perspective = new XEO.Perspective(scene, {
        fovy: 60,
        near: 0.1,
        far: 1000
    });

 var camera = new XEO.Camera(scene, {
        view: lookat,
        project: perspective
    });

 var geometry = new XEO.Geometry(scene);  // Defaults to a 2x2x2 box

 var entity = new XEO.Entity(scene, {
        camera: camera,
        geometry: geometry
    });

 scene.on("tick", function () {
       camera.view.rotateEyeY(0.5);
       camera.view.rotateEyeX(0.3);
    });
 ````
 @class Perspective
 @module XEO
 @submodule camera
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this Perspective within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Perspective.
 @param [cfg.fovy=60.0] {Number} Field-of-view angle, in degrees, on Y-axis.
 @param [cfg.near=0.1] {Number} Position of the near plane on the View-space Z-axis.
 @param [cfg.far=10000] {Number} Position of the far plane on the View-space Z-axis.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Perspective = XEO.Component.extend({

        type: "XEO.Perspective",

        _init: function (cfg) {

            this._state = new XEO.renderer.ProjTransform({
                matrix: XEO.math.identityMat4(XEO.math.mat4())
            });

            this._dirty = false;
            this._fovy = 60.0;
            this._near = 0.1;
            this._far = 10000.0;

            var canvas = this.scene.canvas;

            // Recompute aspect from change in canvas size
            this._canvasResized = canvas.on("size", this._scheduleUpdate, this);

            this.fovy = cfg.fovy;
            this.near = cfg.near;
            this.far = cfg.far;
        },

        _update: function () {

            var canvas = this.scene.canvas.canvas;
            var aspect = canvas.clientWidth / canvas.clientHeight;

            XEO.math.perspectiveMatrix4(this._fovy * (Math.PI / 180.0), aspect, this._near, this._far, this._state.matrix);

            /**
             * Fired whenever this Perspective's {{#crossLink "Perspective/matrix:property"}}{{/crossLink}} property changes.
             *
             * @event matrix
             * @param value The property's new value
             */
            this.fire("matrix", this._state.matrix);
        },

        _props: {

            /**
             * The angle, in degrees on the Y-axis, of this Perspective's field-of-view.
             *
             * Fires a {{#crossLink "Perspective/fovy:event"}}{{/crossLink}} event on change.
             *
             * @property fovy
             * @default 60.0
             * @type Number
             */
            fovy: {

                set: function (value) {

                    this._fovy = (value !== undefined && value !== null) ? value : 60.0;

                    this._renderer.imageDirty = true;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Perspective's {{#crossLink "Perspective/fovy:property"}}{{/crossLink}} property changes.
                     *
                     * @event fovy
                     * @param value The property's new value
                     */
                    this.fire("fovy", this._fovy);
                },

                get: function () {
                    return this._fovy;
                }
            },

            /**
             * Position of this Perspective's near plane on the positive View-space Z-axis.
             *
             * Fires a {{#crossLink "Perspective/near:event"}}{{/crossLink}} event on change.
             *
             * @property near
             * @default 0.1
             * @type Number
             */
            near: {

                set: function (value) {

                    this._near = (value !== undefined && value !== null) ? value : 0.1;

                    this._renderer.imageDirty = true;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Perspective's   {{#crossLink "Perspective/near:property"}}{{/crossLink}} property changes.
                     * @event near
                     * @param value The property's new value
                     */
                    this.fire("near", this._near);
                },

                get: function () {
                    return this._near;
                }
            },

            /**
             * Position of this Perspective's far plane on the positive View-space Z-axis.
             *
             * Fires a {{#crossLink "Perspective/far:event"}}{{/crossLink}} event on change.
             *
             * @property far
             * @default 10000.0
             * @type Number
             */
            far: {

                set: function (value) {

                    this._far = (value !== undefined && value !== null) ? value : 10000;

                    this._renderer.imageDirty = true;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Perspective's  {{#crossLink "Perspective/far:property"}}{{/crossLink}} property changes.
                     *
                     * @event far
                     * @param value The property's new value
                     */
                    this.fire("far", this._far);
                },

                get: function () {
                    return this._far;
                }
            },

            /**
             * The elements of this Perspective's projection transform matrix.
             *
             * Fires a {{#crossLink "Perspective/matrix:event"}}{{/crossLink}} event on change.
             *
             * @property matrix
             * @type {Float64Array}
             */
            matrix: {

                get: function () {

                    if (this._updateScheduled) {
                        this._update();
                    }

                    return this._state.matrix;
                }
            }
        },

        _compile: function () {
            this._renderer.projTransform = this._state;
        },

        _getJSON: function () {
            return {
                fovy: this._fovy,
                near: this._near,
                far: this._far
            };
        },

        _destroy: function () {

            this.scene.canvas.off(this._canvasResized);

            this._state.destroy();
        }
    });

})();
;/**
 A **Canvas** manages a {{#crossLink "Scene"}}Scene{{/crossLink}}'s HTML canvas and its WebGL context.

 ## Overview

 <ul>

 <li>Each {{#crossLink "Scene"}}Scene{{/crossLink}} provides a Canvas as a read-only property on itself.</li>

 <li>When a {{#crossLink "Scene"}}Scene{{/crossLink}} is configured with the ID of
 an existing <a href="http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element">HTMLCanvasElement</a>, then
 the Canvas will bind to that, otherwise the Canvas will automatically create its own.</li>

 <li>A Canvas will fire a {{#crossLink "Canvas/resized:event"}}{{/crossLink}} event whenever
 the <a href="http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element">HTMLCanvasElement</a> resizes.</li>

 <li>A Canvas is responsible for obtaining a WebGL context from
 the <a href="http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element">HTMLCanvasElement</a>.</li>

 <li>A Canvas also fires a {{#crossLink "Canvas/webglContextLost:event"}}{{/crossLink}} event when the WebGL context is
 lost, and a {{#crossLink "Canvas/webglContextRestored:event"}}{{/crossLink}} when it is restored again.</li>

 <li>The various components within the parent {{#crossLink "Scene"}}Scene{{/crossLink}} will transparently recover on
 the {{#crossLink "Canvas/webglContextRestored:event"}}{{/crossLink}} event.</li>

 </ul>

 <img src="../../../assets/images/Canvas.png"></img>

 ## Example

 In the example below, we're creating a {{#crossLink "Scene"}}Scene{{/crossLink}} without specifying an HTML canvas element
 for it. This causes the {{#crossLink "Scene"}}Scene{{/crossLink}}'s Canvas component to create its own default element
 within the page. Then we subscribe to various events fired by that Canvas component.

 ```` javascript
 var scene = new XEO.Scene();

 // Get the Canvas off the Scene
 // Since we did not configure the Scene with the ID of a DOM canvas element,
 // the Canvas will create its own canvas element in the DOM
 var canvas = scene.canvas;

 // Get the WebGL context off the Canvas
 var gl = canvas.gl;

 // Subscribe to Canvas resize events
 canvas.on("resize", function(e) {
        var width = e.width;
        var height = e.height;
        var aspect = e.aspect;
        //...
     });

 // Subscribe to WebGL context loss events on the Canvas
 canvas.on("webglContextLost", function() {
        //...
     });

 // Subscribe to WebGL context restored events on the Canvas
 canvas.on("webglContextRestored", function(gl) {
        var newContext = gl;
        //...
     });
 ````

 When we want to bind the Canvas to an existing HTML canvas element, configure the
 {{#crossLink "Scene"}}{{/crossLink}} with the ID of the element, like this:

 ```` javascript
 // Create a Scene, this time configuting it with the
 // ID of an existing DOM canvas element
 var scene = new XEO.Scene({
          canvasId: "myCanvas"
     });

 // ..and the rest of this example can be the same as the previous example.

 ````
 @class Canvas
 @module XEO
 @submodule canvas
 @static
 @param {Scene} scene Parent scene
 @extends Component
 */
(function () {

    "use strict";

    var canvases = {};

    XEO.Canvas = XEO.Component.extend({

        type: "XEO.Canvas",

        serializable: false,

        // Names of recognised WebGL contexts
        _WEBGL_CONTEXT_NAMES: [
            "webgl",
            "experimental-webgl",
            "webkit-3d",
            "moz-webgl",
            "moz-glweb20"
        ],

        _init: function (cfg) {

            /**
             * The HTML canvas. When the {{#crossLink "Viewer"}}{{/crossLink}} was configured with the ID of an existing canvas within the DOM,
             * then this property will be that element, otherwise it will be a full-page canvas that this Canvas has
             * created by default, with a z-index of -10000.
             *
             * @property canvas
             * @type {HTMLCanvasElement}
             * @final
             */
            this.canvas = null;

            /**
             * A transparent HTML DIV overlaid over the {{#crossLink "Canvas/canvas:property"}}{{/crossLink}}, with a z-index
             * of 100000.
             *
             * The parent {{#crossLink "Scene"}}{{/crossLink}}'s {{#crossLink "Input"}}{{/crossLink}} will relay mouse
             * events from this DIV, instead of from the {{#crossLink "Canvas/canvas:property"}}{{/crossLink}}.
             *
             * When you need to have various HTML elements floating around over
             * the {{#crossLink "Canvas/canvas:property"}}{{/crossLink}}, then if you give those a z-index that lies between
             * that of the {{#crossLink "Canvas/canvas:property"}}{{/crossLink}} and this DIV, your elements will not
             * interfere with those events.
             *
             * @property canvas
             * @type {HTMLCanvasElement}
             * @final
             */
            this.overlay = null;

            /**
             * The WebGL rendering context.
             *
             * @property gl
             * @type {WebGLRenderingContext}
             * @final
             */
            this.gl = null;

            /**
             * Attributes for the WebGL context
             *
             * @type {{}|*}
             */
            this.contextAttr = cfg.contextAttr || {};

            if (!cfg.canvas) {

                // Canvas not supplied, create one automatically

                this._createCanvas();

            } else {

                // Canvas supplied

                if (XEO._isString(cfg.canvas)) {

                    // Canvas ID supplied - find the canvas

                    this.canvas = document.getElementById(cfg.canvas);

                    if (!this.canvas) {

                        // Canvas not found - create one automatically

                        this.error("Canvas element not found: " + XEO._inQuotes(cfg.canvas)
                            + " - creating default canvas instead.");

                        this._createCanvas();
                    }

                } else {

                    this.error("Config 'canvasId' should be a string - "
                        + "creating default canvas instead.");

                    this._createCanvas();
                }
            }

            if (!this.canvas) {

                this.error("Faied to create canvas");

                return;
            }

            // If the canvas uses css styles to specify the sizes make sure the basic
            // width and height attributes match or the WebGL context will use 300 x 150

            this.canvas.width = this.canvas.clientWidth;
            this.canvas.height = this.canvas.clientHeight;

            this._createOverlay();

            // Get WebGL context

            this._initWebGL();

            // Bind context loss and recovery handlers

            var self = this;

            this.canvas.addEventListener("webglcontextlost",
                function () {

                    /**
                     * Fired wheneber the WebGL context has been lost
                     * @event webglContextLost
                     */
                    self.fire("webglContextLost");
                },
                false);

            this.canvas.addEventListener("webglcontextrestored",
                function () {
                    self._initWebGL();
                    if (self.gl) {

                        /**
                         * Fired whenever the WebGL context has been restored again after having previously being lost
                         * @event webglContextRestored
                         * @param value The WebGL context object
                         */
                        self.fire("webglContextRestored", self.gl);
                    }
                },
                false);

            // Publish canvas size changes on each scene tick

            var lastWidth = null;
            var lastHeight = null;

            this._tick = this.scene.on("tick",
                function () {

                    var canvas = self.canvas;

                    if (canvas.clientWidth !== lastWidth || canvas.clientHeight !== lastHeight) {

                        var newWidth = canvas.clientWidth;
                        var newHeight = canvas.clientHeight;

                        //canvas.width = canvas.clientWidth;
                        //canvas.height = canvas.clientHeight;
                        /**
                         * Fired whenever the canvas has resized
                         * @event resized
                         * @param width {Number} The new canvas width
                         * @param height {Number} The new canvas height
                         * @param aspect {Number} The new canvas aspect ratio
                         */
                        self.fire("size", {
                            width: newWidth,
                            height: newHeight,
                            aspect: newHeight / newWidth
                        });

                        // TODO: count pixels

                        var countPixels = 0;
                        var scene;

                        for (var sceneId in XEO.scenes) {
                            if (XEO.scenes.hasOwnProperty(sceneId)) {
                                scene = XEO.scenes[sceneId];
                                countPixels += scene.canvas.canvas.clientWidth * scene.canvas.canvas.clientHeight;
                            }
                        }

                        XEO.stats.memory.pixels = countPixels;

                        lastWidth = newWidth;
                        lastHeight = newHeight;

                    }
                });

            this.canvas.oncontextmenu = function (e) {
                e.preventDefault();
            };
        },

        /**
         * Creates a canvas in the DOM
         * @private
         */
        _createCanvas: function () {

            var canvasId = "XEO-canvas-" + XEO.math.createUUID();
            var body = document.getElementsByTagName("body")[0];
            var div = document.createElement('div');

            var style = div.style;
            style.height = "100%";
            style.width = "100%";
            style.padding = "0";
            style.margin = "0";
            style.background = "black";
            style.float = "left";
            style.left = "0";
            style.top = "0";
            style.position = "absolute";
            style["z-index"] = "-10000";

            div.innerHTML += '<canvas id="' + canvasId + '" style="width: 100%; height: 100%; float: left; margin: 0; padding: 0;"></canvas>';

            body.appendChild(div);

            this.canvas = document.getElementById(canvasId);
        },

        /**
         * Creates an invisible DIV over the canvas
         * @private
         */
        _createOverlay: function () {

            var overlayId = "XEO-overlay-" + XEO.math.createUUID();
            var body = document.getElementsByTagName("body")[0];
            var div = document.createElement('div');

            var style = div.style;
            style.height = this.canvas.height + "px";
            style.width = "100%";
            style.padding = "0";
            style.margin = "0";
            style.background = "black";
            style.float = "left";
            style.left = "0";
            style.top = "0";
            style.position = "absolute";
            style.opacity = 0;
            style["z-index"] = "100000";

            div.innerHTML += '<div id="' + overlayId + '" style="width: 100%; height: 100%; float: left; margin: 0; padding: 0; opacity: 0;"></overlay>';

            body.appendChild(div);

            this.overlay = document.getElementById(overlayId);
        },

        /**
         * Initialises the WebGL context
         */
        _initWebGL: function () {

            // Default context attribute values

            var contextAttr = XEO._applyIf({
                preserveDrawingBuffer: false
            }, this.contextAttr);

            for (var i = 0; !this.gl && i < this._WEBGL_CONTEXT_NAMES.length; i++) {
                try {
                    this.gl = this.canvas.getContext(this._WEBGL_CONTEXT_NAMES[i], contextAttr);
                } catch (e) { // Try with next context name
                }
            }

            if (!this.gl) {

                this.error('Failed to get a WebGL context');

                /**
                 * Fired whenever the canvas failed to get a WebGL context, which probably means that WebGL
                 * is either unsupported or has been disabled.
                 * @event webglContextFailed
                 */
                this.fire("webglContextFailed", true, true);
            }
        },

        _destroy: function () {
            this.scene.off(this._tick);
        }
    });

})();
;/**
 * Components for cross-section views of Entities.
 *
 * @module XEO
 * @submodule clipping
 */;

/**
 A **Clip** is an arbitrarily-aligned World-space clipping plane, which may be used to create
 cross-sectional views of attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>

 <li>These are grouped within {{#crossLink "Clips"}}Clips{{/crossLink}} components, which are attached to
 {{#crossLink "Entity"}}Entities{{/crossLink}}. See the {{#crossLink "Clips"}}Clips{{/crossLink}} documentation
 for more info.</li>

 <li>A Clip is specified in World-space, as being perpendicular to a vector {{#crossLink "Clip/dir:property"}}{{/crossLink}}
 that emanates from the origin, offset at a distance {{#crossLink "Clip/dist:property"}}{{/crossLink}} along that vector. </li>

 <li>You can move a Clip back and forth along its vector by varying {{#crossLink "Clip/dist:property"}}{{/crossLink}}.</li>

 <li>Likewise, you can rotate a Clip about the origin by rotating the {{#crossLink "Clip/dir:property"}}{{/crossLink}} vector.</li>

 <li>A Clip is has a {{#crossLink "Clip/mode:property"}}{{/crossLink}},  which indicates whether it is disabled
 ("disabled"), discarding fragments that fall on the origin-side of the plane ("inside"), or clipping fragments that
 fall on the other side of the plane from the origin ("outside").</li>

 <li>You can update the {{#crossLink "Clip/mode:property"}}{{/crossLink}} of a Clip to activate or deactivate it, or to
 switch which side it discards fragments from.</li>

 <li>Clipping may also be enabled or disabled for specific {{#crossLink "Entity"}}Entities{{/crossLink}}
 via the {{#crossLink "Modes/clipping:property"}}{{/crossLink}} flag on {{#crossLink "Modes"}}Modes{{/crossLink}} components
 attached to those {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>

 <li>See <a href="Shader.html#inputs">Shader Inputs</a> for the variables that Clips create within xeoEngine's shaders.</li>

 </ul>

 <img src="../../../assets/images/Clip.png"></img>

 ## Example

 <ul>

 <li>In this example we have an {{#crossLink "Entity"}}{{/crossLink}} that's clipped by a {{#crossLink "Clips"}}{{/crossLink}}
 that contains two {{#crossLink "Clip"}}{{/crossLink}} planes.</li>

 <li>The first {{#crossLink "Clip"}}{{/crossLink}} plane is on the
 positive diagonal, while the second is on the negative diagonal.</li>

 <li>The {{#crossLink "Entity"}}Entity's{{/crossLink}}
 {{#crossLink "Geometry"}}{{/crossLink}} is the default 2x2x2 box, and the planes will clip off two of the box's corners.</li>

 </ul>

 ````javascript
 var scene = new XEO.Scene();

 // Clip plane on negative diagonal
 var clip1 = new XEO.Clip(scene, {
        dir: [-1.0, -1.0, -1.0], // Direction of Clip from World space origin
        dist: 2.0,               // Distance along direction vector
        mode: "outside"          // Clip fragments that fall beyond the plane
     });

 // Clip plane on positive diagonal
 var clip2 = new XEO.Clip(scene, {
        dir: [1.0, 1.0, 1.0],
        dist: 2.0,
        mode: "outside"
     });

 // Group the planes in a Clips
 var clips = new XEO.Clip(scene, {
        clips: [
            clip1,
            clip2
        ]
     });

 // Geometry defaults to a 2x2x2 box
 var geometry = new XEO.Geometry(scene);

 // Create an Entity, which is a box sliced by our clip planes
 var entity = new XEO.Entity(scene, {
        clips: clips,
        geometry: geometry
     });
 ````

 ### Toggling clipping on and off

 Now we'll attach a {{#crossLink "Modes"}}{{/crossLink}} to the {{#crossLink "Entity"}}{{/crossLink}}, so that we can
 enable or disable clipping of it:

 ```` javascript
 // Create the Modes
 var modes = new XEO.Modes(scene, {
    clipping: true
 });

 // Attach our Entity to the Modes
 entity.modes = modes;

 // Disable clipping for the Entity
 modes.clipping = false;
 ````

 @class Clip
 @module XEO
 @submodule clipping
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Clip in the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Clip configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 You only need to supply an ID if you need to be able to find the Clip by ID within the {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Clip.
 @param [cfg.mode="disabled"] {String} Clipping mode - "disabled" to clip nothing, "inside" to reject points inside the plane, "outside" to reject points outside the plane.
 @param [dir= [1, 0, 0]] {Array of Number} The direction of the clipping plane from the World-space origin.
 @param [dist=1.0] {Number} Distance to the clipping plane along the direction vector.

 @extends Component
 */
(function () {

    "use strict";

    XEO.Clip = XEO.Component.extend({

        type: "XEO.Clip",

        _init: function (cfg) {

            this._state = {
                mode: "disabled",
                dir: [1,0,0],
                dist: 1.0
            };

            this.mode = cfg.mode;
            this.dir = cfg.dir;
            this.dist = cfg.dist;
        },

        _props: {

            /**
             The current mode of this Clip.

             Possible states are:

             <ul>
             <li>"disabled" - inactive</li>
             <li>"inside" - clipping fragments that fall within the half-space on the origin-side of the Clip plane</li>
             <li>"outside" - clipping fragments that fall on the other side of the Clip plane from the origin</li>
             </ul>

             Fires a {{#crossLink "Clip/mode:event"}}{{/crossLink}} event on change.

             @property mode
             @default "disabled"
             @type String
             */
            mode: {

                set: function (value) {

                    this._state.mode =  value || "disabled";

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this Clip's {{#crossLink "Clip/mode:property"}}{{/crossLink}} property changes.

                     @event mode
                     @param value {String} The property's new value
                     */
                    this.fire("mode", this._state.mode);
                },

                get: function () {
                    return this._state.mode;
                }
            },

            /**
             A vector emanating from the World-space origin that indicates the orientation of this Clip plane.

             The Clip plane will be oriented perpendicular to this vector.

             Fires a {{#crossLink "Clip/dir:event"}}{{/crossLink}} event on change.

             @property dir
             @default [1.0, 1.0, 1.0]
             @type Array(Number)
             */
            dir: {

                set: function (value) {

                    this._state.dir =  value || [1, 0, 0];

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this Clip's {{#crossLink "Clip/dir:property"}}{{/crossLink}} property changes.

                     @event dir
                     @param  value  {Array(Number)} The property's new value
                     */
                    this.fire("dir", this._state.dir);
                },

                get: function () {
                    return this._state.dir;
                }
            },

            /**
             The position of this Clip along the vector indicated by {{#crossLink "Clip/dir:property"}}{{/crossLink}}.

             This is the distance of the Clip plane from the World-space origin.

             Fires a {{#crossLink "Clip/dist:event"}}{{/crossLink}} event on change.

             @property dist
             @default 1.0
             @type Number
             */
            dist: {

                set: function (value) {

                    this._state.dist = value !== undefined ? value : 1.0;

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this Clip's {{#crossLink "Clip/dist:property"}}{{/crossLink}} property changes.

                     @event dist
                     @param  value Number The property's new value
                     */
                    this.fire("dist", this._state.dist);
                },

                get: function () {
                    return this._state.dist;
                }
            }
        },

        _getJSON: function () {
            return {
                mode: this._state.mode,
                dir: this._state.dir,
                dist: this._state.dist
            };
        }
    });

})();
;/**
 A **Clips** is a group of arbitrarily-aligned World-space {{#crossLink "Clip"}}Clip{{/crossLink}} planes, which may be used to create
 cross-sectional views of attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>

 <li>Each {{#crossLink "Clip"}}Clip{{/crossLink}} is specified in World-space, as being perpendicular to a vector
 {{#crossLink "Clip/dir:property"}}{{/crossLink}} that emanates from the origin, offset at a
 distance {{#crossLink "Clip/dist:property"}}{{/crossLink}} along that vector. </li>

 <li>You can move each {{#crossLink "Clip"}}Clip{{/crossLink}} back and forth along its vector by varying
 its {{#crossLink "Clip/dist:property"}}{{/crossLink}}.</li>

 <li>Likewise, you can rotate each {{#crossLink "Clip"}}Clip{{/crossLink}} about the origin by rotating
 its {{#crossLink "Clip/dir:property"}}{{/crossLink}} vector.</li>

 <li>Each {{#crossLink "Clip"}}Clip{{/crossLink}} is has a {{#crossLink "Clip/mode:property"}}{{/crossLink}}, which indicates whether it is disabled ("disabled"), discarding fragments that fall on the origin-side of the plane ("inside"), or clipping fragments that fall on the other side of the plane from the origin ("outside").</li>

 <li>You can update each {{#crossLink "Clip"}}Clip{{/crossLink}}'s {{#crossLink "Clip/mode:property"}}{{/crossLink}} to
 activate or deactivate it, or to switch which side it discards fragments from.</li>

 <li>Clipping may also be enabled or disabled for specific {{#crossLink "Entity"}}Entities{{/crossLink}}
 via the {{#crossLink "Modes/clipping:property"}}{{/crossLink}} flag on {{#crossLink "Modes"}}Modes{{/crossLink}} components
 attached to those {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>

 <li>See <a href="Shader.html#inputs">Shader Inputs</a> for the variables that Clips create within xeoEngine's shaders.</li>

 </ul>

 <img src="../../../assets/images/Clips.png"></img>

 ## Example

 <ul>

 <li>In this example we have an {{#crossLink "Entity"}}{{/crossLink}} that's clipped by a {{#crossLink "Clips"}}{{/crossLink}}
 that contains two {{#crossLink "Clip"}}{{/crossLink}} planes.</li>

 <li>The first {{#crossLink "Clip"}}{{/crossLink}} plane is on the
 positive diagonal, while the second is on the negative diagonal.</li>

 <li>The {{#crossLink "Entity"}}Entity's{{/crossLink}}
 {{#crossLink "Geometry"}}{{/crossLink}} is the default 2x2x2 box, and the planes will clip off two of the box's corners.</li>

 </ul>

 ````javascript
 var scene = new XEO.Scene();

 // Clip plane on negative diagonal
 var clip1 = new XEO.Clip(scene, {
        dir: [-1.0, -1.0, -1.0], // Direction of Clip from World space origin
        dist: 2.0,               // Distance along direction vector
        mode: "outside"          // Clip fragments that fall beyond the plane
     });

 // Clip plane on positive diagonal
 var clip2 = new XEO.Clip(scene, {
        dir: [1.0, 1.0, 1.0],
        dist: 2.0,
        mode: "outside"
     });

 // Group the planes in a Clips
 var clips = new XEO.Clip(scene, {
        clips: [
            clip1,
            clip2
        ]
     });

 // Geometry defaults to a 2x2x2 box
 var geometry = new XEO.Geometry(scene);

 // Create an Entity, which is a box sliced by our clip planes
 var entity = new XEO.Entity(scene, {
        clips: clips,
        geometry: geometry
     });
 ````

 ### Toggling clipping on and off

 Now we'll attach a {{#crossLink "Modes"}}{{/crossLink}} to the {{#crossLink "Entity"}}{{/crossLink}}, so that we can
 enable or disable clipping of it:

 ```` javascript
 // Create the Modes
 var modes = new XEO.Modes(scene, {
    clipping: true
 });

 // Attach our Entity to the Modes
 entity.modes = modes;

 // Disable clipping for the Entity
 modes.clipping = false;
 ````

 @class Clips
 @module XEO
 @submodule clipping
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Clips in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Clips.
 @param [cfg.clips] {Array(String)|Array(XEO.Clip)} Array containing either IDs or instances of
 {{#crossLink "Clip"}}Clip{{/crossLink}} components within the parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Clips = XEO.Component.extend({

        type: "XEO.Clips",

        _init: function (cfg) {

            // Renderer state contains the states of the child Clip components
            this._state = new XEO.renderer.Clips({

                clips: [],

                hash: ""
            });

            this._dirty = true;

            // Array of child Clip components
            this._clips = [];

            // Subscriptions to "dirty" events from child Clip components
            this._dirtySubs = [];

            // Subscriptions to "destroyed" events from child Clip components
            this._destroyedSubs = [];

            // Add initial Clip components
            this.clips = cfg.clips;
        },

        _props: {

            /**
             * The clipping planes contained within this Clips.
             *
             * Fires a {{#crossLink "Clips/clips:event"}}{{/crossLink}} event on change.
             *
             * @property clips
             * @default []
             * @type Array(XEO.Clip)
             */
            clips: {

                set: function (value) {

                    value = value || [];

                    var clip;

                    // Unsubscribe from events on old clips
                    for (var i = 0, len = this._clips.length; i < len; i++) {

                        clip = this._clips[i];

                        clip.off(this._dirtySubs[i]);
                        clip.off(this._destroyedSubs[i]);
                    }

                    this._clips = [];

                    this._dirtySubs = [];
                    this._destroyedSubs = [];

                    var self = this;

                    function clipDirty() {
                        self.fire("dirty", true);
                    }

                    function clipDestroyed() {

                        var id = this.id; // Clip ID

                        for (var i = 0, len = self._clips.length; i < len; i++) {

                            if (self._clips[i].id === id) {

                                self._clips = self._clips.slice(i, i + 1);

                                self._dirtySubs = self._dirtySubs.slice(i, i + 1);
                                self._destroyedSubs = self._destroyedSubs.slice(i, i + 1);

                                self._dirty = true;

                                self.fire("dirty", true);
                                self.fire("clips", self._clips);

                                return;
                            }
                        }
                    }

                    for (var i = 0, len = value.length; i < len; i++) {

                        clip = value[i];

                        if (XEO._isString(clip)) {

                            // ID given for clip - find the clip component

                            var id = clip;

                            clip = this.components[id];

                            if (!clip) {
                                this.error("Component not found: " + XEO._inQuotes(id));
                                continue;
                            }
                        }

                        if (clip.type !== "XEO.Clip") {
                            this.error("Component " + XEO._inQuotes(id) + " is not a XEO.Clip");
                            continue;
                        }

                        this._clips.push(clip);

                        this._dirtySubs.push(clip.on("dirty", clipDirty));

                        this._destroyedSubs.push(clip.on("destroyed", clipDestroyed));
                    }

                    this._dirty = true;

                    /**
                     Fired whenever this Clips' {{#crossLink "Clips/clips:property"}}{{/crossLink}} property changes.
                     @event clips
                     @param value {Array of XEO.Clip} The property's new value
                     */
                    this.fire("dirty", true);
                    this.fire("clips", this._clips);
                },

                get: function () {
                    return this._clips.slice(0, this._clips.length);
                }
            }
        },

        _compile: function () {

            var state = this._state;

            if (this._dirty) {

                state.clips = [];

                for (var i = 0, len = this._clips.length; i < len; i++) {
                    state.clips.push(this._clips[i]._state);
                }

                this._makeHash();

                this._dirty = false;
            }

            this._renderer.clips = state;
        },

        _makeHash: function () {

            var clips = this._state.clips;

            if (clips.length === 0) {
                return ";";
            }

            var clip;
            var hash = [];

            for (var i = 0, len = clips.length; i < len; i++) {

                clip = clips[i];

                hash.push(clip._state.mode);
            }

            hash.push(";");

            this._state.hash = hash.join("");
        },

        _getJSON: function () {

            var clipIds = [];

            for (var i = 0, len = this._clips.length; i < len; i++) {
                clipIds.push(this._clips[i].id);
            }

            return {
                clips: clipIds
            };
        },

        _destroy: function () {
            this._state.destroy();
        }
    });

})();
;/**
 * Components for managing Scene configuration.
 *
 * @module XEO
 * @submodule configs
 */;/**
 A **Configs** holds configuration properties for the parent {{#crossLink "Scene"}}Scene{{/crossLink}}.

 ## Overview

 <ul>
 <li>Each {{#crossLink "Scene"}}Scene{{/crossLink}} provides a Configs on itself as a read-only property.</li>
 <li>Config property values are set on a Configs using its {{#crossLink "Configs/set:method"}}{{/crossLink}} method,
 and changes to properties may be subscribed to using {{#crossLink "Component/on:method"}}{{/crossLink}}.</li>
 <li>You can define your own properties in a Configs, but take care not to clobber the native properties used by
 xeoEngine (see table below).</li>
 </ul>

 <img src="../../../assets/images/Configs.png"></img>

 ## Native xeoEngine config properties

 Don't use the following names for your own Configs properties, because these are already used by xeoEngine:

 | Name  | Description  |
 |---|---|
 | TODO  | TODO  |
 | TODO  | TODO  |


 ## Example

 In this example, we're subscribing to change events for a {{#crossLink "Scene"}}Scene's{{/crossLink}} "foo" configuration property, then updating that
 property, which fires a change event.

 ````Javascript
 var scene = new XEO.Scene();

 var configs = scene.configs;

 // Subscribe to change of a Configs property.
 // The subscriber is also immediately notified of the current value via the callback.
 configs.on("foo", function(value) {
    console.log("foo = " + value);
});

 // Create and set a Configs property, firing our change handler:
 configs.set("foo", "Hello!");

 // Read the current value of a Configs property.
 // Normally we would asynchronously subscribe with #on though, to be sure that
 // we're getting the latest changes to the property.
 var bar = configs.props["bar"];
 ````

 @class Configs
 @module XEO
 @submodule configs
 @constructor
 @param [scene] {Scene} Parent scene - creates this component in the default scene when omitted.
 @param {Object} [cfg]  Config values.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Configs = XEO.Component.extend({

        type: "XEO.Configs",

        _init: function (cfg) {

            this.props = {};

            for (var key in cfg) {
                if (cfg.hasOwnProperty(key)) {
                    this.set(key, cfg[key]);
                }
            }
        },

        /**
         * Sets a property on this Configs.
         *
         * Fires an event with the same name as the property. Existing subscribers to the event will be
         * notified immediately of the property value. Like all events on a Component, this Configs will
         * retain the event, to notify any subscribers that are attached subsequently.
         *
         * @method set
         * @param {String} name The property name
         * @param {Object} value The property value
         * @param {Boolean} [forget=false] When true, does not retain for subsequent subscribers
         */
        set: function (name, value) {

            this.props[name] = value;

            this.fire(name, value);
        },

        _toJSON: function () {
            return XEO._copy(this.props);
        }
    });

})();
;/**
 * Components for controlling things with user input.
 *
 * @module XEO
 * @submodule controls
 */;/**
 A **CameraControl** pans, rotates and zooms a {{#crossLink "Camera"}}{{/crossLink}} using the mouse and keyboard,
 as well as switches it between preset left, right, anterior, posterior, superior and inferior views.

 A CameraControl contains the following control sub-components, each of which handle an aspect of interaction:

 <ul>
 <li>{{#crossLink "KeyboardPanCamera"}}{{/crossLink}} pans the camera with the W,S,A,D,X and Z keys</li>
 <li>{{#crossLink "MousePanCamera"}}{{/crossLink}} pans horizontally and vertically by dragging the mouse with left and right buttons down</li>
 <li>{{#crossLink "KeyboardRotateCamera"}}{{/crossLink}} rotates the camera with the arrow keys</li>
 <li>{{#crossLink "MouseRotateCamera"}}{{/crossLink}} rotates the camera by dragging with the left mouse button down</li>
 <li>{{#crossLink "KeyboardZoomCamera"}}{{/crossLink}} zooms the *eye* position closer and further from the *look* position with the + and - keys</li>
 <li>{{#crossLink "MouseZoomCamera"}}{{/crossLink}} zooms the *eye* closer and further from *look* using the mousewheel</li>
 <li>{{#crossLink "KeyboardAxisCamera"}}{{/crossLink}} between preset left, right, anterior, posterior, superior and inferior views using keys 1-6</li>
 <li>{{#crossLink "MousePickEntity"}}{{/crossLink}} TODO</li>
 <li>{{#crossLink "CameraFlight"}}{{/crossLink}} TODO</li>
 </ul>

 A CameraControl provides these control sub-components as read-only properties, which allows them to be individually configured (or deactivated) as required.

 <ul>
 <li>Activating or deactivating a CameraControl will activate or deactivate all its control sub-components.</li>
 <li>Attaching a different {{#crossLink "Camera"}}{{/crossLink}} to the CameraControl will also attach that
 {{#crossLink "Camera"}}{{/crossLink}} to all the control sub-components.</li>
 <li>The control sub-components are not supposed to be re-attached to a different {{#crossLink "Camera"}}{{/crossLink}} than the owner CameraControl.</li>
 <li>A CameraControl manages the life-cycles of its control sub-components, destroying them when the CameraControl is destroyed.</li>
 </ul>

 <br><br>
 <img src="../../../assets/images/CameraControl.png"></img>

 ## Example

 ````Javascript
 var camera = new XEO.Camera();

 var cameraControl = new XEO.CameraControl({

        camera: camera,

        // "First person" mode rotates look about eye.
        // By default however, we orbit eye about look.
        firstPerson: false
    });

 // Reduce the sensitivity of mouse rotation
 cameraControl.mouseRotate.sensitivity = 0.7;

 // Deactivate switching between preset views
 cameraControl.keyboardAxis.active = false;

 // Create a Entity
 var entity = new XEO.Entity({
    camera: camera
 });
 ````

 @class CameraControl
 @module XEO
 @submodule controls
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}{{/crossLink}}.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this CameraControl.
 @param [cfg.camera] {String|Camera} ID or instance of a {{#crossLink "Camera"}}Camera{{/crossLink}} to control.
 Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this CameraControl. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/camera:property"}}camera{{/crossLink}}.
 @param [cfg.active=true] {Boolean} Whether or not this CameraControl is active.
 @param [firstPerson=false] {Boolean} Whether or not this CameraControl is in "first person" mode.
 @extends Component
 */
(function () {

    "use strict";


    XEO.CameraControl = XEO.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.CameraControl",

        /**
         Indicates that only one instance of a CameraControl may be active within
         its {{#crossLink "Scene"}}{{/crossLink}} at a time. When a CameraControl is activated, that has
         a true value for this flag, then any other active CameraControl will be deactivated first.

         @property exclusive
         @type Boolean
         @final
         */
        exclusive: true,

        _init: function (cfg) {

            var self = this;

            var scene = this.scene;

            // Shows a bounding box around each Entity we fly to
            this._boundaryEntity = new XEO.Entity(scene, {
                geometry: new XEO.BoundaryGeometry(scene),
                material: new XEO.PhongMaterial(scene, {
                    diffuse: [0, 0, 0],
                    ambient: [0, 0, 0],
                    specular: [0, 0, 0],
                    emissive: [1.0, 1.0, 0.6],
                    lineWidth: 4
                }),
                visibility: new XEO.Visibility(scene, {
                    visible: false
                }),
                modes: new XEO.Modes(scene, {

                    // Does not contribute to the size of any enclosing boundaries
                    // that might be calculated by xeoEngine, eg. like that returned by XEO.Scene#worldBoundary
                    collidable: false
                })
            });

            /**
             * The {{#crossLink "KeyboardAxisCamera"}}{{/crossLink}} within this CameraControl.
             *
             * @property keyboardAxis
             * @final
             * @type KeyboardAxisCamera
             */
            this.keyboardAxis = new XEO.KeyboardAxisCamera(scene, {
                camera: cfg.camera
            });

            /**
             * The {{#crossLink "KeyboardRotateCamera"}}{{/crossLink}} within this CameraControl.
             *
             * @property keyboardOrbit
             * @final
             * @type KeyboardRotateCamera
             */
            this.keyboardRotate = new XEO.KeyboardRotateCamera(scene, {
                camera: cfg.camera
            });

            /**
             * The {{#crossLink "MouseRotateCamera"}}{{/crossLink}} within this CameraControl.
             *
             * @property mouseRotate
             * @final
             * @type MouseRotateCamera
             */
            this.mouseRotate = new XEO.MouseRotateCamera(scene, {
                camera: cfg.camera
            });

            /**
             * The {{#crossLink "KeyboardPanCamera"}}{{/crossLink}} within this CameraControl.
             *
             * @property keyboardPan
             * @final
             * @type KeyboardPanCamera
             */
            this.keyboardPan = new XEO.KeyboardPanCamera(scene, {
                camera: cfg.camera
            });

            /**
             * The {{#crossLink "MousePanCamera"}}{{/crossLink}} within this CameraControl.
             *
             * @property mousePan
             * @final
             * @type MousePanCamera
             */
            this.mousePan = new XEO.MousePanCamera(scene, {
                camera: cfg.camera
            });

            /**
             * The {{#crossLink "KeyboardZoomCamera"}}{{/crossLink}} within this CameraControl.
             *
             * @property keyboardZoom
             * @final
             * @type KeyboardZoomCamera
             */
            this.keyboardZoom = new XEO.KeyboardZoomCamera(scene, {
                camera: cfg.camera
            });

            /**
             * The {{#crossLink "MouseZoomCamera"}}{{/crossLink}} within this CameraControl.
             *
             * @property mouseZoom
             * @final
             * @type MouseZoomCamera
             */
            this.mouseZoom = new XEO.MouseZoomCamera(scene, {
                camera: cfg.camera
            });

            /**
             * The {{#crossLink "MousePickEntity"}}{{/crossLink}} within this CameraControl.
             *
             * @property mousePickEntity
             * @final
             * @type MousePickEntity
             */
            this.mousePickEntity = new XEO.MousePickEntity(scene, {
                rayPick: true
            });

            this.mousePickEntity.on("pick", this._entityPicked, this);

            this.mousePickEntity.on("nopick",
                function (e) {
                    //alert("Nothing picked");
                });

            /**
             * The {{#crossLink "CameraFlight"}}{{/crossLink}} within this CameraControl.
             *
             * @property cameraFlight
             * @final
             * @type CameraFlight
             */
            this.cameraFlight = new XEO.CameraFlight(scene, {
                camera: cfg.camera,
                duration: 0.5
            });

            // Set component properties

            this.firstPerson = cfg.firstPerson;
            this.camera = cfg.camera;
            this.active = cfg.active !== false;
        },

        _entityPicked: function (e) {

            // Fly camera to each picked entity
            // Don't change distance between look and eye

            var view = this.cameraFlight.camera.view;

            var pos;

            if (e.worldPos) {
                pos = e.worldPos

            } else if (e.entity) {
                pos = e.entity.worldBoundary.center
            }

            if (pos) {

                var diff = XEO.math.subVec3(view.eye, view.look, []);

                var input = this.scene.input;

                //  if (input.keyDown[input.KEY_SHIFT] && e.entity) {

                // var aabb = e.entity.worldBoundary.aabb;

                this._boundaryEntity.geometry.obb = e.entity.worldBoundary.obb;
                this._boundaryEntity.visibility.visible = true;

                var center = e.entity.worldBoundary.center;

                this.cameraFlight.flyTo({
                        aabb: e.entity.worldBoundary.aabb,
                        oXffset: [
                            pos[0] - center[0],
                            pos[1] - center[1],
                            pos[2] - center[2]
                        ]
                    },
                    this._hideEntityBoundary, this);

                //} else {
                //
                //    this.cameraFlight.flyTo({
                //            look: pos,
                //            eye: [
                //                pos[0] + diff[0],
                //                pos[1] + diff[1],
                //                pos[2] + diff[2]
                //            ]
                //        },
                //        this._hideEntityBoundary, this);
                //}
            }
        },

        _hideEntityBoundary: function () {
            this._boundaryEntity.visibility.visible = false;
        },

        _props: {

            /**
             * Flag which indicates whether this CameraControl is in "first person" mode.
             *
             * In "first person" mode (disabled by default) the look position rotates about the eye position. Otherwise,
             * the eye rotates about the look.
             *
             * Fires a {{#crossLink "KeyboardRotateCamera/firstPerson:event"}}{{/crossLink}} event on change.
             *
             * @property firstPerson
             * @default false
             * @type Boolean
             */
            firstPerson: {

                set: function (value) {

                    value = !!value;

                    this._firstPerson = value;

                    this.keyboardRotate.firstPerson = value;
                    this.mouseRotate.firstPerson = value;

                    /**
                     * Fired whenever this CameraControl's {{#crossLink "CameraControl/firstPerson:property"}}{{/crossLink}} property changes.
                     * @event firstPerson
                     * @param value The property's new value
                     */
                    this.fire('firstPerson', this._firstPerson);
                }

                ,

                get: function () {
                    return this._firstPerson;
                }
            }
            ,

            /**
             * The {{#crossLink "Camera"}}{{/crossLink}} being controlled by this CameraControl.
             *
             * Must be within the same {{#crossLink "Scene"}}{{/crossLink}} as this CameraControl. Defaults to the parent
             * {{#crossLink "Scene"}}Scene's{{/crossLink}} default {{#crossLink "Scene/camera:property"}}camera{{/crossLink}} when set to
             * a null or undefined value.
             *
             * @property camera
             * @type Camera
             */
            camera: {

                set: function (value) {

                    /**
                     * Fired whenever this CameraControl's {{#crossLink "CameraControl/camera:property"}}{{/crossLink}}
                     * property changes.
                     *
                     * @event camera
                     * @param value The property's new value
                     */
                    this._setChild("camera", value);

                    // Update camera on child components

                    var camera = this._children.camera;

                    this.keyboardAxis.camera = camera;
                    this.keyboardRotate.camera = camera;
                    this.mouseRotate.camera = camera;
                    this.keyboardPan.camera = camera;
                    this.mousePan.camera = camera;
                    this.keyboardZoom.camera = camera;
                    this.mouseZoom.camera = camera;
                    this.cameraFlight.camera = camera;
                }

                ,

                get: function () {
                    return this._children.camera;
                }
            }
            ,

            /**
             * Flag which indicates whether this CameraControl is active or not.
             *
             * Fires an {{#crossLink "CameraControl/active:event"}}{{/crossLink}} event on change.
             *
             * @property active
             * @type Boolean
             */
            active: {

                set: function (value) {

                    value = !!value;

                    if (this._active === value) {
                        return;
                    }

                    // Activate or deactivate child components

                    this.keyboardAxis.active = value;
                    this.keyboardRotate.active = value;
                    this.mouseRotate.active = value;
                    this.keyboardPan.active = value;
                    this.mousePan.active = value;
                    this.keyboardZoom.active = value;
                    this.mouseZoom.active = value;
                    this.mousePickEntity.active = value;
                    this.cameraFlight.active = value;

                    /**
                     * Fired whenever this CameraControl's {{#crossLink "CameraControl/active:property"}}{{/crossLink}} property changes.
                     * @event active
                     * @param value The property's new value
                     */
                    this.fire('active', this._active = value);
                },

                get: function () {
                    return this._active;
                }
            }
        }
        ,

        _getJSON: function () {

            var json = {
                firstPerson: this._firstPerson,
                active: this._active
            };

            if (this._children.camera) {
                json.camera = this._children.camera.id;
            }

            return json;
        }
        ,

        _destroy: function () {

            this.active = false;

            // FIXME: Does not recursively destroy child components
            this._boundaryEntity.destroy();

            this.keyboardAxis.destroy();
            this.keyboardRotate.destroy();
            this.mouseRotate.destroy();
            this.keyboardPan.destroy();
            this.mousePan.destroy();
            this.keyboardZoom.destroy();
            this.mouseZoom.destroy();
            this.mousePickEntity.destroy();
            this.cameraFlight.destroy();
        }
    });

})();
;/**
 A **KeyboardAxisCamera** switches a {{#crossLink "Camera"}}{{/crossLink}} between preset left, right, anterior,
 posterior, superior and inferior views using the keyboard.

 ## Overview

 <ul>
 <li>A KeyboardAxisCamera updates the {{#crossLink "Lookat"}}{{/crossLink}} attached to the target {{#crossLink "Camera"}}{{/crossLink}}.
 </ul>

 By default the views are selected by the following keys:

 <ul>
 <li>'1' - left side, viewing center from along -X axis</li>
 <li>'2' - right side, viewing center from along +X axis</li>
 <li>'3' - anterior, viewing center from along -Z axis</li>
 <li>'4' - posterior, viewing center from along +Z axis</li>
 <li>'5' - superior, viewing center from along -Y axis</li>
 <li>'6' - inferior, viewing center from along +Y axis</li>
 </ul>

 ## Example

 ````Javascript
 var scene = new XEO.Scene();

 var camera = new XEO.Camera(scene);

 var control = new XEO.KeyboardAxisCamera(scene, {
        camera: camera
    });

 var entity = new XEO.Entity(scene);
 ````

 @class KeyboardAxisCamera
 @module XEO
 @submodule controls
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}{{/crossLink}}.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Entity} Optional map of user-defined metadata to attach to this KeyboardAxisCamera.
 @param [cfg.camera] {String|Camera} ID or instance of a {{#crossLink "Camera"}}Camera{{/crossLink}} to control.
 Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this KeyboardAxisCamera. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/camera:property"}}camera{{/crossLink}}.
 @param [cfg.active=true] {Boolean} Whether or not this KeyboardAxisCamera is active.
 @extends Component
 */
(function () {

    "use strict";

    XEO.KeyboardAxisCamera = XEO.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.KeyboardAxisCamera",

        _init: function (cfg) {

            // Event handles

            this._onKeyDown = null;

            // Animations

            this._cameraFly = new XEO.CameraFlight(this.scene, {
                duration: 1.0
            });

            // Init properties

            this.camera = cfg.camera;
            this.active = cfg.active !== false;
        },

        _props: {

            /**
             * The {{#crossLink "Camera"}}Camera{{/crossLink}} attached to this KeyboardAxisCamera.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this KeyboardAxisCamera. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/camera:property"}}camera{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires a {{#crossLink "KeyboardAxisCamera/camera:event"}}{{/crossLink}} event on change.
             *
             * @property camera
             * @type Camera
             */
            camera: {

                set: function (value) {

                    /**
                     * Fired whenever this KeyboardAxisCamera's {{#crossLink "KeyboardAxisCamera/camera:property"}}{{/crossLink}} property changes.
                     *
                     * @event camera
                     * @param value The property's new value
                     */
                    this._setChild("camera", value);

                    // Update animation

                    this._cameraFly.camera = this._children.camera;
                },

                get: function () {
                    return this._children.camera;
                }
            },

            /**
             * Flag which indicates whether this KeyboardAxisCamera is active or not.
             *
             * Fires an {{#crossLink "KeyboardAxisCamera/active:event"}}{{/crossLink}} event on change.
             *
             * @property active
             * @type Boolean
             */
            active: {

                set: function (value) {

                    value = !!value;

                    if (this._active === value) {
                        return;
                    }

                    this._cameraFly.active = value;

                    var self = this;

                    var input = this.scene.input;

                    if (value) {

                        this._onKeyDown = input.on("keydown",
                            function (keyCode) {

                                if (!self._children.camera) {
                                    return;
                                }

                                if (keyCode === input.KEY_NUM_1
                                    || keyCode === input.KEY_NUM_2
                                    || keyCode === input.KEY_NUM_3
                                    || keyCode === input.KEY_NUM_4
                                    || keyCode === input.KEY_NUM_5
                                    || keyCode === input.KEY_NUM_6) {


                                    XEO.scheduleTask(function () {
                                        self._fly(keyCode);
                                    });
                                }
                            });

                    } else {

                        this.scene.off(this._onKeyDown);
                    }

                    /**
                     * Fired whenever this KeyboardAxisCamera's {{#crossLink "KeyboardAxisCamera/active:property"}}{{/crossLink}} property changes.
                     * @event active
                     * @param value The property's new value
                     */
                    this.fire('active', this._active = value);
                },

                get: function () {
                    return this._active;
                }
            }
        },

        _fly: function (keyCode) {

            var input = this.scene.input;
            var boundary = this.scene.worldBoundary;
            var aabb = boundary.aabb;
            var center = boundary.center;
            var diag = XEO.math.getAABBDiag(aabb);

            this._stopFOV = 55;
            var dist = Math.abs((diag) / Math.tan(this._stopFOV / 2));

            switch (keyCode) {

                case input.KEY_NUM_1:

                    // Right view

                    this._cameraFly.flyTo({
                        look: center,
                        eye: [center[0] - dist, center[1], center[2]],
                        up: [0, 1, 0]
                    });

                    break;

                case input.KEY_NUM_2:

                    // Back view

                    this._cameraFly.flyTo({
                        look: center,
                        eye: [center[0], center[1], center[2] + dist],
                        up: [0, 1, 0]
                    });

                    break;

                case input.KEY_NUM_3:

                    // Left view

                    this._cameraFly.flyTo({
                        look: center,
                        eye: [center[0] + dist, center[1], center[2]],
                        up: [0, 1, 0]
                    });


                    break;

                case input.KEY_NUM_4:

                    // Front view

                    this._cameraFly.flyTo({
                        look: center,
                        eye: [center[0], center[1], center[2] - dist],
                        up: [0, 1, 0]
                    });

                    break;

                case input.KEY_NUM_5:

                    // Top view

                    this._cameraFly.flyTo({
                        look: center,
                        eye: [center[0], center[1] - dist, center[2]],
                        up: [0, 0, -1]
                    });

                    break;

                case input.KEY_NUM_6:

                    // Bottom view

                    this._cameraFly.flyTo({
                        look: center,
                        eye: [center[0], center[1] + dist, center[2]],
                        up: [0, 0, 1]
                    });

                    break;
            }
        },

        _getJSON: function () {

            var json = {
                active: this._active
            };

            if (this._children.camera) {
                json.camera = this._children.camera.id;
            }

            return json;
        },

        _destroy: function () {

            this.active = false;

            this._cameraFly.destroy();
        }
    });

})();
;/**
 A **KeyboardRotateCamera** orbits a {{#crossLink "Camera"}}{{/crossLink}} about its point-of-interest using the keyboard's arrow keys.

 ## Overview

 <ul>
 <li>A KeyboardRotateCamera updates the {{#crossLink "Lookat"}}{{/crossLink}} attached to its target {{#crossLink "Camera"}}{{/crossLink}}.
 <li>The point-of-interest is the {{#crossLink "Lookat"}}Lookat's{{/crossLink}} {{#crossLink "Lookat/look:property"}}{{/crossLink}}.</li>
 <li>Orbiting involves rotating the {{#crossLink "Lookat"}}Lookat's{{/crossLink}} {{#crossLink "Lookat/eye:property"}}{{/crossLink}}
 about {{#crossLink "Lookat/look:property"}}{{/crossLink}}.</li>
 <li>Y-axis rotation is about the {{#crossLink "Lookat"}}Lookat's{{/crossLink}} {{#crossLink "Lookat/up:property"}}{{/crossLink}} vector.</li>
 <li>Z-axis rotation is about the {{#crossLink "Lookat/eye:property"}}{{/crossLink}} -&gt; {{#crossLink "Lookat/look:property"}}{{/crossLink}} vector.</li>
 <li>X-axis rotation is about the vector perpendicular to the {{#crossLink "Lookat/eye:property"}}{{/crossLink}}-&gt;{{#crossLink "Lookat/look:property"}}{{/crossLink}}
 and {{#crossLink "Lookat/up:property"}}{{/crossLink}} vectors.</li>
 <li>In 'first person' mode, the {{#crossLink "Lookat"}}Lookat's{{/crossLink}} {{#crossLink "Lookat/look:property"}}{{/crossLink}}
 position will orbit the {{#crossLink "Lookat/eye:property"}}{{/crossLink}} position, otherwise the {{#crossLink "Lookat/eye:property"}}{{/crossLink}}
 will orbit the {{#crossLink "Lookat/look:property"}}{{/crossLink}}.</li>
 </ul>

 ## Example

 ````Javascript
 var scene = new XEO.Scene();

 var camera = new XEO.Camera(scene);

 var control = new XEO.KeyboardRotateCamera(scene, {

        camera: camera,

        // "First person" mode rotates look about eye.
        // By default however, we orbit eye about look.
        firstPerson: false
    });

 var entity = new XEO.Entity(scene);
 ````


 @class KeyboardRotateCamera
 @module XEO
 @submodule controls
 @constructor
 @param [viewer] {Viewer} Parent {{#crossLink "Viewer"}}{{/crossLink}}.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent viewer, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this KeyboardAxisCamera.
 @param [cfg.camera] {String|Camera} ID or instance of a {{#crossLink "Camera"}}Camera{{/crossLink}} to control.
 Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this KeyboardRotateCamera. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/camera:property"}}camera{{/crossLink}}.
 @param [cfg.sensitivity=1.0] {Number} Orbit sensitivity factor.
 @param [cfg.firstPerson=false] {Boolean}  Indicates whether this KeyboardRotateCamera is in "first person" mode.
 @param [cfg.active=true] {Boolean} Whether or not this MousePanCamera is active.
 @extends Component
 */
(function () {

    "use strict";

    XEO.KeyboardRotateCamera = XEO.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.KeyboardRotateCamera",

        _init: function (cfg) {

            // Event handles

            this._onTick = null;

            // Init properties

            this.camera = cfg.camera;
            this.active = cfg.active !== false;
            this.sensitivity = cfg.sensitivity;
        },

        _props: {

            /**
             * The {{#crossLink "Camera"}}Camera{{/crossLink}} attached to this KeyboardRotateCamera.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this KeyboardRotateCamera. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/camera:property"}}camera{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires a {{#crossLink "KeyboardRotateCamera/camera:event"}}{{/crossLink}} event on change.
             *
             * @property camera
             * @type Camera
             */
            camera: {

                set: function (value) {

                    /**
                     * Fired whenever this KeyboardRotateCamera's {{#crossLink "KeyboardRotateCamera/camera:property"}}{{/crossLink}} property changes.
                     *
                     * @event camera
                     * @param value The property's new value
                     */
                    this._setChild("camera", value);
                },

                get: function () {
                    return this._children.camera;
                }
            },

            /**
             * The sensitivity of this KeyboardRotateCamera.
             *
             * Fires a {{#crossLink "KeyboardRotateCamera/sensitivity:event"}}{{/crossLink}} event on change.
             *
             * @property sensitivity
             * @type Number
             * @default 1.0
             */
            sensitivity: {

                set: function (value) {

                    this._sensitivity = value || 1.0;

                    /**
                     * Fired whenever this KeyboardRotateCamera's  {{#crossLink "KeyboardRotateCamera/sensitivity:property"}}{{/crossLink}} property changes.
                     *
                     * @event sensitivity
                     * @param value The property's new value
                     */
                    this.fire("sensitivity", this._sensitivity);
                },

                get: function () {
                    return this._sensitivity;
                }
            },

            /**
             * Flag which indicates whether this KeyboardRotateCamera is in "first person" mode.
             *
             * A KeyboardRotateCamera updates the {{#crossLink "Lookat"}}{{/crossLink}} attached to its
             * target {{#crossLink "Camera"}}{{/crossLink}}. In 'first person' mode, the
             * {{#crossLink "Lookat"}}Lookat's{{/crossLink}} {{#crossLink "Lookat/look:property"}}{{/crossLink}}
             * position orbits the {{#crossLink "Lookat/eye:property"}}{{/crossLink}} position, otherwise
             * the {{#crossLink "Lookat/eye:property"}}{{/crossLink}} orbits {{#crossLink "Lookat/look:property"}}{{/crossLink}}.</li>
             *
             * Fires a {{#crossLink "KeyboardRotateCamera/firstPerson:event"}}{{/crossLink}} event on change.
             *
             * @property firstPerson
             * @default false
             * @type Boolean
             */
            firstPerson: {

                set: function (value) {

                    value = !!value;

                    this._firstPerson = value;

                    /**
                     * Fired whenever this KeyboardRotateCamera's {{#crossLink "KeyboardRotateCamera/firstPerson:property"}}{{/crossLink}} property changes.
                     * @event firstPerson
                     * @param value The property's new value
                     */
                    this.fire('firstPerson', this._firstPerson);
                },

                get: function () {
                    return this._firstPerson;
                }
            },

            /**
             * Flag which indicates whether this KeyboardRotateCamera is active or not.
             *
             * Fires an {{#crossLink "KeyboardRotateCamera/active:event"}}{{/crossLink}} event on change.
             *
             * @property active
             * @type Boolean
             */
            active: {

                set: function (value) {

                    if (this._active === value) {
                        return;
                    }

                    var input = this.scene.input;

                    if (value) {

                        var self = this;

                        this._onTick = this.scene.on("tick",
                            function (params) {

                                var camera = self._children.camera;

                                if (!camera) {
                                    return;
                                }

                                var elapsed = params.deltaTime;

                                var yawRate = self._sensitivity * 0.3;
                                var pitchRate = self._sensitivity * 0.3;

                                if (!input.ctrlDown && !input.altDown) {

                                    var left = input.keyDown[input.KEY_LEFT_ARROW];
                                    var right = input.keyDown[input.KEY_RIGHT_ARROW];
                                    var up = input.keyDown[input.KEY_UP_ARROW];
                                    var down = input.keyDown[input.KEY_DOWN_ARROW];

                                    if (left || right || up || down) {

                                        var yaw = 0;
                                        var pitch = 0;

                                        if (right) {
                                            yaw = -elapsed * yawRate;

                                        } else if (left) {
                                            yaw = elapsed * yawRate;
                                        }

                                        if (down) {
                                            pitch = elapsed * pitchRate;

                                        } else if (up) {
                                            pitch = -elapsed * pitchRate;
                                        }

                                        if (Math.abs(yaw) > Math.abs(pitch)) {
                                            pitch = 0;
                                        } else {
                                            yaw = 0;
                                        }

                                        if (yaw != 0) {
                                            camera.view.rotateEyeY(yaw);
                                        }

                                        if (pitch != 0) {
                                            camera.view.rotateEyeX(pitch);
                                        }
                                    }
                                }
                            });

                    } else {

                        this.scene.off(this._onTick);
                    }

                    /**
                     * Fired whenever this KeyboardRotateCamera's {{#crossLink "KeyboardRotateCamera/active:property"}}{{/crossLink}} property changes.
                     * @event active
                     * @param value The property's new value
                     */
                    this.fire('active', this._active = value);
                },

                get: function () {
                    return this._active;
                }
            }
        },

        _getJSON: function () {

            var json = {
                sensitivity: this._sensitivity,
                active: this._active
            };

            if (this._children.camera) {
                json.camera = this._children.camera.id;
            }

            return json;
        },

        _destroy: function () {
            this.active = false; // Unbinds events
        }
    });

})();
;/**
 A **KeyboardPanCamera** pans a {{#crossLink "Camera"}}{{/crossLink}} using the W,S,A,D,X and Z keys.

 ## Overview

 <ul>
 <li>A KeyboardPanCamera updates the {{#crossLink "Lookat"}}{{/crossLink}} attached to the target {{#crossLink "Camera"}}{{/crossLink}}.
 <li>Panning up and down involves translating the positions of the {{#crossLink "Lookat"}}Lookat's{{/crossLink}}
 {{#crossLink "Lookat/eye:property"}}{{/crossLink}} and {{#crossLink "Lookat/look:property"}}{{/crossLink}} back and forth
 along the {{#crossLink "Lookat"}}Lookat's{{/crossLink}} {{#crossLink "Lookat/up:property"}}{{/crossLink}} vector.</li>
 <li>Panning forwards and backwards involves translating
 {{#crossLink "Lookat/eye:property"}}{{/crossLink}} and {{#crossLink "Lookat/look:property"}}{{/crossLink}} back and forth along the
 {{#crossLink "Lookat/eye:property"}}{{/crossLink}}-&gt;{{#crossLink "Lookat/look:property"}}{{/crossLink}} vector.</li>
 <li>Panning left and right involves translating the {{#crossLink "Lookat/eye:property"}}{{/crossLink}} and
 {{#crossLink "Lookat/look:property"}}{{/crossLink}} along the the vector perpendicular to the {{#crossLink "Lookat/up:property"}}{{/crossLink}}
 and {{#crossLink "Lookat/eye:property"}}{{/crossLink}}-&gt;{{#crossLink "Lookat/look:property"}}{{/crossLink}} vectors.</li>
 </ul>

 ## Example

 ````Javascript
 var scene = new XEO.Scene();

 var camera = new XEO.Camera(scene);

 var control = new XEO.KeyboardPanCamera(scene, {
        camera: camera
    });

 var entity = new XEO.Entity(scene);
 ````

 @class KeyboardPanCamera
 @module XEO
 @submodule controls
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}{{/crossLink}}.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this KeyboardRotateCamera.
 @param [cfg.camera] {String|Camera} ID or instance of a {{#crossLink "Camera"}}Camera{{/crossLink}} to control.
 Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this KeyboardPanCamera. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/camera:property"}}camera{{/crossLink}}.
 @param [cfg.sensitivity=0.5] {Number} Pan sensitivity factor.
 @param [cfg.active=true] {Boolean} Whether or not this KeyboardPanCamera is active.
 @extends Component
 */
(function () {

    "use strict";

    XEO.KeyboardPanCamera = XEO.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.KeyboardPanCamera",

        _init: function (cfg) {

            // Event handles

            this._onTick = null;

            // Init properties

            this.camera = cfg.camera;
            this.sensitivity = cfg.sensitivity;
            this.active = cfg.active !== false;
        },

        _props: {

            /**
             * The {{#crossLink "Camera"}}Camera{{/crossLink}} attached to this KeyboardPanCamera.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this KeyboardPanCamera. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/camera:property"}}camera{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires a {{#crossLink "KeyboardPanCamera/camera:event"}}{{/crossLink}} event on change.
             *
             * @property camera
             * @type Camera
             */
            camera: {

                set: function (value) {

                    /**
                     * Fired whenever this KeyboardPanCamera's {{#crossLink "KeyboardPanCamera/camera:property"}}{{/crossLink}} property changes.
                     *
                     * @event camera
                     * @param value The property's new value
                     */
                    this._setChild("camera", value);
                },

                get: function () {
                    return this._children.camera;
                }
            },

            /**
             * The sensitivity of this KeyboardPanCamera.
             *
             * Fires a {{#crossLink "KeyboardPanCamera/sensitivity:event"}}{{/crossLink}} event on change.
             *
             * @property sensitivity
             * @type Number
             * @default 0.5
             */
            sensitivity: {

                set: function (value) {

                    this._sensitivity = value || 0.5;

                    /**
                     * Fired whenever this KeyboardPanCamera's  {{#crossLink "KeyboardPanCamera/sensitivity:property"}}{{/crossLink}} property changes.
                     *
                     * @event sensitivity
                     * @param value The property's new value
                     */
                    this.fire("sensitivity", this._sensitivity);
                },

                get: function () {
                    return this._sensitivity;
                }
            },

            /**
             * Flag which indicates whether this KeyboardPanCamera is active or not.
             *
             * Fires an {{#crossLink "KeyboardPanCamera/active:event"}}{{/crossLink}} event on change.
             *
             * @property active
             * @type Boolean
             */
            active: {

                set: function (value) {

                    if (this._active === value) {
                        return;
                    }

                    var input = this.scene.input;

                    if (value) {

                        var self = this;

                        this._onTick = this.scene.on("tick",
                            function (params) {

                                var camera = self._children.camera;

                                if (!camera) {
                                    return;
                                }

                                var elapsed = params.deltaTime;

                                if (!input.ctrlDown && !input.altDown) {

                                    var wkey = input.keyDown[input.KEY_W];
                                    var skey = input.keyDown[input.KEY_S];
                                    var akey = input.keyDown[input.KEY_A];
                                    var dkey = input.keyDown[input.KEY_D];
                                    var zkey = input.keyDown[input.KEY_Z];
                                    var xkey = input.keyDown[input.KEY_X];

                                    if (wkey || skey || akey || dkey || xkey || zkey) {

                                        var x = 0;
                                        var y = 0;
                                        var z = 0;

                                        var sensitivity = self._sensitivity * 0.01;

                                        if (skey) {
                                            y = elapsed * sensitivity;

                                        } else if (wkey) {
                                            y = -elapsed * sensitivity;
                                        }

                                        if (dkey) {
                                            x = elapsed * sensitivity;

                                        } else if (akey) {
                                            x = -elapsed * sensitivity;
                                        }

                                        if (xkey) {
                                            z = elapsed * sensitivity;

                                        } else if (zkey) {
                                            z = -elapsed * sensitivity;
                                        }

                                        camera.view.pan([x, y, z]);
                                    }
                                }
                            });

                    } else {

                        if (this._onTick) {
                            this.scene.off(this._onTick);
                        }
                    }

                    /**
                     * Fired whenever this KeyboardPanCamera's {{#crossLink "KeyboardPanCamera/active:property"}}{{/crossLink}} property changes.
                     * @event active
                     * @param value The property's new value
                     */
                    this.fire('active', this._active = value);
                },

                get: function () {
                    return this._active;
                }
            }
        },

        _getJSON: function () {

            var json = {
                sensitivity: this._sensitivity,
                active: this._active
            };

            if (this._children.camera) {
                json.camera = this._children.camera.id;
            }

            return json;
        },

        _destroy: function () {
            this.active = false;
        }
    });

})();
;/**
 A **KeyboardZoomCamera** zooms a {{#crossLink "Camera"}}{{/crossLink}} using the + and - keys.

 ## Overview

 <ul>
 <li>A KeyboardZoomCamera updates the {{#crossLink "Lookat"}}{{/crossLink}} attached to the target {{#crossLink "Camera"}}{{/crossLink}}.
 <li>Zooming involves translating the positions of the {{#crossLink "Lookat"}}Lookat's{{/crossLink}}
 {{#crossLink "Lookat/eye:property"}}{{/crossLink}} and {{#crossLink "Lookat/look:property"}}{{/crossLink}} back and forth
 along the {{#crossLink "Lookat/eye:property"}}{{/crossLink}}-&gt;{{#crossLink "Lookat/look:property"}}{{/crossLink}} vector.</li>
 </ul>

 ## Example

 ````Javascript
 var scene = new XEO.Scene();

 var camera = new XEO.Camera(scene);

 var control = new XEO.KeyboardZoomCamera(scene, {
        camera: camera
    });

 var entity = new XEO.Entity(scene);
 ````

 @class KeyboardZoomCamera
 @module XEO
 @submodule controls
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}{{/crossLink}}.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this KeyboardZoomCamera.
 @param [cfg.camera] {String|Camera} ID or instance of a {{#crossLink "Camera"}}Camera{{/crossLink}} to control.
 Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this KeyboardZoomCamera. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/camera:property"}}camera{{/crossLink}}.
 @param [cfg.sensitivity=0.5] {Number} Zoom sensitivity factor.
 @param [cfg.active=true] {Boolean} Whether or not this KeyboardZoomCamera is active.
 @extends Component
 */
(function () {

    "use strict";

    XEO.KeyboardZoomCamera = XEO.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.KeyboardZoomCamera",

        _init: function (cfg) {

            // Event handles

            this._onTick = null;

            // Init properties

            this.camera = cfg.camera;
            this.sensitivity = cfg.sensitivity;
            this.active = cfg.active !== false;
        },

        _props: {

            /**
             * The {{#crossLink "Camera"}}Camera{{/crossLink}} attached to this KeyboardZoomCamera.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this KeyboardZoomCamera. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/camera:property"}}camera{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires a {{#crossLink "KeyboardZoomCamera/camera:event"}}{{/crossLink}} event on change.
             *
             * @property camera
             * @type Camera
             */
            camera: {

                set: function (value) {

                    /**
                     * Fired whenever this KeyboardZoomCamera's {{#crossLink "KeyboardZoomCamera/camera:property"}}{{/crossLink}} property changes.
                     *
                     * @event camera
                     * @param value The property's new value
                     */
                    this._setChild("camera", value);
                },

                get: function () {
                    return this._children.camera;
                }
            },

            /**
             * The sensitivity of this KeyboardZoomCamera.
             *
             * Fires a {{#crossLink "KeyboardZoomCamera/sensitivity:event"}}{{/crossLink}} event on change.
             *
             * @property sensitivity
             * @type Number
             * @default 0.5
             */
            sensitivity: {

                set: function (value) {

                    this._sensitivity = value || 0.5;

                    /**
                     * Fired whenever this KeyboardZoomCamera's  {{#crossLink "KeyboardZoomCamera/sensitivity:property"}}{{/crossLink}} property changes.
                     *
                     * @event sensitivity
                     * @param value The property's new value
                     */
                    this.fire("sensitivity", this._sensitivity);
                },

                get: function () {
                    return this._sensitivity;
                }
            },

            /**
             * Flag which indicates whether this KeyboardZoomCamera is active or not.
             *
             * Fires an {{#crossLink "KeyboardZoomCamera/active:event"}}{{/crossLink}} event on change.
             *
             * @property active
             * @type Boolean
             */
            active: {

                set: function (value) {

                    if (this._active === value) {
                        return;
                    }

                    var input = this.scene.input;

                    if (value) {

                        var self = this;

                        this._onTick = this.scene.on("tick",
                            function (params) {

                                var camera = self._children.camera;

                                if (!camera) {
                                    return;
                                }

                                var elapsed = params.deltaTime;

                                if (!input.ctrlDown && !input.altDown) {

                                    var wkey = input.keyDown[input.KEY_ADD];
                                    var skey = input.keyDown[input.KEY_SUBTRACT];

                                    if (wkey || skey) {

                                        var z = 0;

                                        var sensitivity = self.sensitivity * 0.01;

                                        if (skey) {
                                            z = elapsed * sensitivity;

                                        } else if (wkey) {
                                            z = -elapsed * sensitivity;
                                        }

                                        camera.view.zoom(z);
                                    }
                                }
                            });

                    } else {

                        if (this._onTick !== null) {
                            this.scene.off(this._onTick);
                        }
                    }

                    /**
                     * Fired whenever this KeyboardZoomCamera's {{#crossLink "KeyboardZoomCamera/active:property"}}{{/crossLink}} property changes.
                     * @event active
                     * @param value The property's new value
                     */
                    this.fire('active', this._active = value);
                },

                get: function () {
                    return this._active;
                }
            }
        },

        _getJSON: function () {

            var json = {
                sensitivity: this._sensitivity,
                active: this._active
            };

            if (this._children.camera) {
                json.camera = this._children.camera.id;
            }

            return json;
        },

        _destroy: function () {
            this.active = false;
        }
    });

})();
;/**
 A **MouseRotateCamera** orbits a {{#crossLink "Camera"}}{{/crossLink}} about its point-of-interest using the mouse.

 ## Overview

 <ul>
 <li>A MouseRotateCamera updates the {{#crossLink "Lookat"}}{{/crossLink}} attached to the target {{#crossLink "Camera"}}{{/crossLink}}.
 <li>The point-of-interest is the {{#crossLink "Lookat"}}Lookat's{{/crossLink}} {{#crossLink "Lookat/look:property"}}{{/crossLink}}.</li>
 <li>Orbiting involves rotating the {{#crossLink "Lookat"}}Lookat's{{/crossLink}} {{#crossLink "Lookat/eye:property"}}{{/crossLink}}
 about {{#crossLink "Lookat/look:property"}}{{/crossLink}}.</li>
 <li>Y-axis rotation is about the {{#crossLink "Lookat"}}Lookat's{{/crossLink}} {{#crossLink "Lookat/up:property"}}{{/crossLink}} vector.</li>
 <li>Z-axis rotation is about the {{#crossLink "Lookat/eye:property"}}{{/crossLink}} -&gt; {{#crossLink "Lookat/look:property"}}{{/crossLink}} vector.</li>
 <li>X-axis rotation is about the vector perpendicular to the {{#crossLink "Lookat/eye:property"}}{{/crossLink}}-&gt;{{#crossLink "Lookat/look:property"}}{{/crossLink}}
 and {{#crossLink "Lookat/up:property"}}{{/crossLink}} vectors.</li>
 <li>In 'first person' mode, the {{#crossLink "Lookat"}}Lookat's{{/crossLink}} {{#crossLink "Lookat/look:property"}}{{/crossLink}}
 position will orbit the {{#crossLink "Lookat/eye:property"}}{{/crossLink}} position, otherwise the {{#crossLink "Lookat/eye:property"}}{{/crossLink}}
 will orbit the {{#crossLink "Lookat/look:property"}}{{/crossLink}}.</li>
 </ul>

 ## Example

 ````Javascript
 var scene = new XEO.Scene();

 var camera = new XEO.Camera(scene);

 var control = new XEO.MouseRotateCamera(scene, {

        camera: camera,

        // "First person" mode rotates look about eye.
        // By default however, we orbit eye about look.
        firstPerson: false
    });

 var entity = new XEO.Entity(scene);
 ````

 @class MouseRotateCamera
 @module XEO
 @submodule controls
 @constructor
 @param [scene] {scene} Parent {{#crossLink "Scene"}}{{/crossLink}}.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent Scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this MouseRotateCamera.
 @param [cfg.camera] {String|Camera} ID or instance of a {{#crossLink "Camera"}}Camera{{/crossLink}} to control.
 Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MouseRotateCamera. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/camera:property"}}camera{{/crossLink}}.
 @param [cfg.sensitivity=0.5] {Number} Mouse drag sensitivity factor.
 @param [cfg.firstPerson=false] {Boolean}  Indicates whether this MouseRotateCamera is in "first person" mode.
 @param [cfg.active=true] {Boolean} Whether or not this MouseRotateCamera is active.
 @extends Component
 */
(function () {

    "use strict";

    XEO.MouseRotateCamera = XEO.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.MouseRotateCamera",

        _init: function (cfg) {

            // Event handles

            this._onTick = null;
            this._onMouseDown = null;
            this._onMouseMove = null;
            this._onMouseUp = null;

            // Init properties

            this.camera = cfg.camera;
            this.sensitivity = cfg.sensitivity;
            this.active = cfg.active !== false;
        },

        _props: {

            /**
             * The {{#crossLink "Camera"}}Camera{{/crossLink}} attached to this MouseRotateCamera.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MouseRotateCamera. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/camera:property"}}camera{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires a {{#crossLink "MouseRotateCamera/camera:event"}}{{/crossLink}} event on change.
             *
             * @property camera
             * @type Camera
             */
            camera: {

                set: function (value) {

                    /**
                     * Fired whenever this MouseRotateCamera's {{#crossLink "MouseRotateCamera/camera:property"}}{{/crossLink}} property changes.
                     *
                     * @event camera
                     * @param value The property's new value
                     */
                    this._setChild("camera", value);
                },

                get: function () {
                    return this._children.camera;
                }
            },

            /**
             * The sensitivity of this MouseRotateCamera.
             *
             * Fires a {{#crossLink "MouseRotateCamera/sensitivity:event"}}{{/crossLink}} event on change.
             *
             * @property sensitivity
             * @type Number
             * @default 0.5
             */
            sensitivity: {

                set: function (value) {

                    this._sensitivity = value || 0.5;

                    /**
                     * Fired whenever this MouseRotateCamera's  {{#crossLink "MouseRotateCamera/sensitivity:property"}}{{/crossLink}} property changes.
                     *
                     * @event sensitivity
                     * @param value The property's new value
                     */
                    this.fire("sensitivity", this._sensitivity);
                },

                get: function () {
                    return this._sensitivity;
                }
            },

            /**
             * Flag which indicates whether this MouseRotateCamera is in "first person" mode.
             *
             * A MouseRotateCamera updates the {{#crossLink "Lookat"}}{{/crossLink}} attached to its
             * target {{#crossLink "Camera"}}{{/crossLink}}. In 'first person' mode, the
             * {{#crossLink "Lookat"}}Lookat's{{/crossLink}} {{#crossLink "Lookat/look:property"}}{{/crossLink}}
             * position orbits the {{#crossLink "Lookat/eye:property"}}{{/crossLink}} position, otherwise
             * the {{#crossLink "Lookat/eye:property"}}{{/crossLink}} orbits {{#crossLink "Lookat/look:property"}}{{/crossLink}}.</li>
             *
             * Fires a {{#crossLink "MouseRotateCamera/firstPerson:event"}}{{/crossLink}} event on change.
             *
             * @property firstPerson
             * @default false
             * @type Boolean
             */
            firstPerson: {

                set: function (value) {

                    value = !!value;

                    this._firstPerson = value;

                    /**
                     * Fired whenever this MouseRotateCamera's {{#crossLink "MouseRotateCamera/firstPerson:property"}}{{/crossLink}} property changes.
                     * @event firstPerson
                     * @param value The property's new value
                     */
                    this.fire('firstPerson', this._firstPerson);
                },

                get: function () {
                    return this._firstPerson;
                }
            },

            /**
             * Flag which indicates whether this MouseRotateCamera is active or not.
             *
             * Fires an {{#crossLink "MouseRotateCamera/active:event"}}{{/crossLink}} event on change.
             *
             * @property active
             * @type Boolean
             */
            active: {

                set: function (value) {

                    if (this._active === value) {
                        return;
                    }

                    var input = this.scene.input;

                    if (value) {

                        var lastX;
                        var lastY;
                        var xDelta = 0;
                        var yDelta = 0;
                        var down = false;
                        var angle;

                        this._onTick = this.scene.on("tick",
                            function () {

                                var camera = this._children.camera;

                                if (!camera) {
                                    return;
                                }

                                if (xDelta != 0) {

                                    angle = -xDelta * this._sensitivity;

                                    if (this._firstPerson) {
                                        camera.view.rotateLookY(angle);
                                    } else {
                                        camera.view.rotateEyeY(angle);
                                    }

                                    xDelta = 0;
                                }

                                if (yDelta != 0) {

                                    angle = yDelta * this._sensitivity;

                                    if (this._firstPerson) {
                                        camera.view.rotateLookX(-angle);
                                    } else {
                                        camera.view.rotateEyeX(angle);
                                    }

                                    yDelta = 0;
                                }
                            }, this);

                        this._onMouseDown = input.on("mousedown",
                            function (e) {

                                if (input.mouseDownLeft
                                    && !input.mouseDownRight
                                    && !input.keyDown[input.KEY_SHIFT]
                                    && !input.mouseDownMiddle) {

                                    down = true;
                                    lastX = e[0];
                                    lastY = e[1];

                                } else {
                                    down = false;
                                }

                            }, this);

                        this._onMouseUp = input.on("mouseup",
                            function () {
                                down = false;
                            });

                        this._onMouseMove = input.on("mousemove",
                            function (e) {
                                if (down) {
                                    xDelta += (e[0] - lastX) * this._sensitivity;
                                    yDelta += (e[1] - lastY) * this._sensitivity;
                                    lastX = e[0];
                                    lastY = e[1];
                                }
                            }, this);

                    } else {

                        input.off(this._onTick);

                        input.off(this._onMouseDown);
                        input.off(this._onMouseUp);
                        input.off(this._onMouseMove);
                    }

                    /**
                     * Fired whenever this MouseRotateCamera's {{#crossLink "MouseRotateCamera/active:property"}}{{/crossLink}} property changes.
                     * @event active
                     * @param value The property's new value
                     */
                    this.fire('active', this._active = value);
                },

                get: function () {
                    return this._active;
                }
            }
        },

        _getJSON: function () {

            var json = {
                sensitivity: this._sensitivity,
                active: this._active
            };

            if (this._children.camera) {
                json.camera = this._children.camera.id;
            }

            return json;
        },

        _destroy: function () {
            this.active = false;
        }
    });

})();
;/**
 A **MousePanCamera** pans a {{#crossLink "Camera"}}{{/crossLink}} using the mouse.

 ## Overview

 <ul>
 <li>A MousePanCamera updates the {{#crossLink "Lookat"}}{{/crossLink}} attached to the target {{#crossLink "Camera"}}{{/crossLink}}.
 <li>Panning is done by dragging the mouse with both the left and right buttons down.</li>
 <li>Panning up and down involves translating the positions of the {{#crossLink "Lookat"}}Lookat's{{/crossLink}}
 {{#crossLink "Lookat/eye:property"}}{{/crossLink}} and {{#crossLink "Lookat/look:property"}}{{/crossLink}} back and forth
 along the {{#crossLink "Lookat"}}Lookat's{{/crossLink}} {{#crossLink "Lookat/up:property"}}{{/crossLink}} vector.</li>
 <li>Panning forwards and backwards involves translating
 {{#crossLink "Lookat/eye:property"}}{{/crossLink}} and {{#crossLink "Lookat/look:property"}}{{/crossLink}} back and forth along the
 {{#crossLink "Lookat/eye:property"}}{{/crossLink}}-&gt;{{#crossLink "Lookat/look:property"}}{{/crossLink}} vector.</li>
 <li>Panning left and right involves translating the {{#crossLink "Lookat/eye:property"}}{{/crossLink}} and
 {{#crossLink "Lookat/look:property"}}{{/crossLink}} along the the vector perpendicular to the {{#crossLink "Lookat/up:property"}}{{/crossLink}}
 and {{#crossLink "Lookat/eye:property"}}{{/crossLink}}-&gt;{{#crossLink "Lookat/look:property"}}{{/crossLink}} vectors.</li>
 </ul>

 ## Example

 ````Javascript
 var scene = new XEO.Scene();

 var camera = new XEO.Camera(scene);

 var control = new XEO.MousePanCamera(scene, {
        camera: camera
    });

 var entity = new XEO.Entity(scene);
 ````

 @class MousePanCamera
 @module XEO
 @submodule controls
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}{{/crossLink}}.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this MousePanCamera.
 @param [cfg.camera] {String|Camera} ID or instance of a {{#crossLink "Camera"}}Camera{{/crossLink}} to control.
 Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MousePanCamera. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/camera:property"}}camera{{/crossLink}}.
 @param [cfg.sensitivity=0.5] {Number} Pan sensitivity factor.
 @param [cfg.active=true] {Boolean} Whether or not this MousePanCamera is active.
 @extends Component
 */
(function () {

    "use strict";

    XEO.MousePanCamera = XEO.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.MousePanCamera",

        _init: function (cfg) {

            // Event handles

            this._onTick = null;
            this._onMouseDown = null;
            this._onMouseMove = null;
            this._onMouseUp = null;

            // Init properties

            this.camera = cfg.camera;
            this.sensitivity = cfg.sensitivity;
            this.active = cfg.active !== false;
        },

        _props: {

            /**
             * The {{#crossLink "Camera"}}Camera{{/crossLink}} attached to this MousePanCamera.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MousePanCamera. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/camera:property"}}camera{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires a {{#crossLink "MousePanCamera/camera:event"}}{{/crossLink}} event on change.
             *
             * @property camera
             * @type Camera
             */
            camera: {

                set: function (value) {

                    /**
                     * Fired whenever this MousePanCamera's {{#crossLink "MousePanCamera/camera:property"}}{{/crossLink}} property changes.
                     *
                     * @event camera
                     * @param value The property's new value
                     */
                    this._setChild("camera", value);
                },

                get: function () {
                    return this._children.camera;
                }
            },

            /**
             * The sensitivity of this MousePanCamera.
             *
             * Fires a {{#crossLink "MousePanCamera/sensitivity:event"}}{{/crossLink}} event on change.
             *
             * @property sensitivity
             * @type Number
             * @default 0.5
             */
            sensitivity: {

                set: function (value) {

                    this._sensitivity = value ? value * 0.03 : 0.03;

                    /**
                     * Fired whenever this MousePanCamera's  {{#crossLink "MousePanCamera/sensitivity:property"}}{{/crossLink}} property changes.
                     *
                     * @event sensitivity
                     * @param value The property's new value
                     */
                    this.fire("sensitivity", this._sensitivity);
                },

                get: function () {
                    return this._sensitivity;
                }
            },

            /**
             * Flag which indicates whether this MousePanCamera is active or not.
             *
             * Fires an {{#crossLink "MousePanCamera/active:event"}}{{/crossLink}} event on change.
             *
             * @property active
             * @type Boolean
             */
            active: {

                set: function (value) {

                    if (this._active === value) {
                        return;
                    }

                    var input = this.scene.input;

                    if (value) {

                        var lastX;
                        var lastY;
                        var xDelta = 0;
                        var yDelta = 0;
                        var down = false;

                        var self = this;

                        this._onTick = this.scene.on("tick",
                            function () {

                                var camera = self._children.camera;

                                if (!camera) {
                                    return;
                                }

                                if (xDelta != 0 || yDelta != 0) {

                                    camera.view.pan([xDelta, yDelta, 0]);

                                    xDelta = 0;
                                    yDelta = 0;
                                }
                            });

                        this._onMouseDown = input.on("mousedown",
                            function (e) {

                                if ((input.mouseDownLeft && input.mouseDownRight) ||
                                    (input.mouseDownLeft && input.keyDown[input.KEY_SHIFT]) ||
                                    input.mouseDownMiddle) {

                                    lastX = e[0];
                                    lastY = e[1];

                                    down = true;

                                } else {
                                    down = false;
                                }
                            });

                        this._onMouseUp = input.on("mouseup",
                            function () {
                                down = false;
                            });

                        this._onMouseMove = input.on("mousemove",
                            function (e) {
                                if (down) {
                                    xDelta += (e[0] - lastX) * self._sensitivity;
                                    yDelta += (e[1] - lastY) * self._sensitivity;
                                    lastX = e[0];
                                    lastY = e[1];
                                }
                            });

                    } else {

                        input.off(this._onTick);
                        input.off(this._onMouseDown);
                        input.off(this._onMouseUp);
                        input.off(this._onMouseMove);
                    }

                    /**
                     * Fired whenever this MousePanCamera's {{#crossLink "MousePanCamera/active:property"}}{{/crossLink}} property changes.
                     * @event active
                     * @param value The property's new value
                     */
                    this.fire('active', this._active = value);
                },

                get: function () {
                    return this._active; // Unbinds events
                }
            }
        },

        _getJSON: function () {

            var json = {
                sensitivity: this._sensitivity,
                active: this._active
            };

            if (this._children.camera) {
                json.camera = this._children.camera.id;
            }

            return json;
        },

        _destroy: function () {
            this.active = false;
        }
    });

})();
;/**
 A **MousePickEntity** picks {{#crossLink "Entity"}}Entities{{/crossLink}} with mouse clicks.

 ## Overview

 TODO

 ## Example

 ````Javascript
 var scene = new XEO.Scene({ element: "myDiv" });

 // Create some Entities

 var entity1 = new XEO.Entity(scene, {
    id: "entity1",
    transform: new XEO.Translate(scene, { xyz: [-5, 0, 0] })
 });

 var entity2 = new XEO.Entity(scene, {
    id: "entity2",
    transform: new XEO.Translate(scene, { xyz: [0, 0, 0] })
 });

 var entity3 = new XEO.Entity(scene, {
    id: "entity3",
    transform: new XEO.Translate(scene, { xyz: [5, 0, 0] })
 });

 // Create a MousePickEntity
 var mousePickEntity = new XEO.MousePickEntity(scene, {

    // We want the 3D World-space coordinates
    // of each location we pick

    rayPick: true
 });

 // Handle picked Entities
 mousePickEntity.on("pick", function(e) {
    var entity = e.entity;
    var canvasPos = e.canvasPos;
    var primitiveIndex = e.primitiveIndex;
 });

 // Handle nothing picked
 mousePickEntity.on("nopick", function(e) {
    var canvasPos = e.canvasPos;
 });
 ````

 @class MousePickEntity
 @module XEO
 @submodule controls
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}{{/crossLink}}.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this MousePickEntity.
 @param [rayPick=false] {Boolean} Indicates whether this MousePickEntity will find the 3D ray intersection whenever it picks a
 {{#crossLink "Entity"}}{{/crossLink}}.
 @param [cfg.active=true] {Boolean} Indicates whether or not this MousePickEntity is active.
 @extends Component
 */
(function () {

    "use strict";

    XEO.MousePickEntity = XEO.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.MousePickEntity",

        _init: function (cfg) {

            this.rayPick = cfg.rayPick;

            this.active = cfg.active !== false;
        },

        _props: {

            /**
             * Flag which indicates whether this MousePickEntity is active or not.
             *
             * Fires a {{#crossLink "MousePickEntity/active:event"}}{{/crossLink}} event on change.
             *
             * @property active
             * @type Boolean
             */
            active: {

                set: function (value) {

                    if (this._active === value) {
                        return;
                    }

                    var input = this.scene.input;

                    if (value) {

                        var self = this;

                        var tolerance = 2; // Pixels
                        var down = false;
                        var downX;
                        var downY;

                        this._onMouseDown = input.on("mousedown",
                            function (canvasPos) {
                                down = true;
                                downX = canvasPos[0];
                                downY = canvasPos[1];
                            });

                        this._onMouseUp = input.on("mouseup",
                            function (canvasPos) {

                                if (!down) {
                                    return;
                                }

                                if (downX >= (canvasPos[0] - tolerance) &&
                                    downX <= (canvasPos[0] + tolerance) &&
                                    downY >= (canvasPos[1] - tolerance) &&
                                    downY <= (canvasPos[1] + tolerance)) {

                                    var hit = self.scene.pick({
                                        canvasPos : canvasPos,
                                        rayPick: self._rayPick
                                    });

                                    if (hit) {

                                        /**
                                         * Fired whenever an {{#crossLink "Entity"}}Entity{{/crossLink}} is picked.
                                         * @event picked
                                         * @param {String} entityId The ID of the picked {{#crossLink "Entity"}}Entity{{/crossLink}} within the parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
                                         * @param {Array of Number} canvasPos The Canvas-space coordinate that was picked.
                                         * @param {Array of Number} worldPos When {{#crossLink "MousePickEntity/rayPick"}}{{/crossLink}} is true,
                                         * provides the World-space coordinate that was ray-picked on the surface of the
                                         * {{#crossLink "Entity"}}Entity{{/crossLink}}.
                                         */
                                        self.fire("pick", hit);

                                    } else {

                                        /**
                                         * Fired whenever an attempt to pick {{#crossLink "Entity"}}Entity{{/crossLink}} picks empty space.
                                         * @event nopick
                                         * @param {Array of Number} canvasPos The Canvas-space coordinate at which the pick was attempted.
                                         */
                                        self.fire("nopick", {
                                            canvasPos: canvasPos
                                        });
                                    }
                                }

                                down = false;
                            });
                    } else {

                        input.off(this._onMouseDown);
                        input.off(this._onMouseUp);
                    }

                    /**
                     * Fired whenever this MousePickEntity's {{#crossLink "MousePickEntity/active:property"}}{{/crossLink}} property changes.
                     * @event active
                     * @param value The property's new value
                     */
                    this.fire('active', this._active = value);
                }
                ,

                get: function () {
                    return this._active;
                }
            },

            /**
             * Indicates whether this MousePickEntity will try to pick a {{#crossLink "Geometry"}}{{/crossLink}} primitive
             * whenever it picks an {{#crossLink "Entity"}}{{/crossLink}}.
             *
             * When true, this MousePickEntity will try to return the primitive index in a
             * {{#crossLink "MousePickEntity/picked:event"}}{{/crossLink}} event.
             *
             * Fires a {{#crossLink "MousePickEntity/rayPick:event"}}{{/crossLink}} event on change.
             *
             * @property rayPick
             * @type Boolean
             */
            rayPick: {

                set: function (value) {

                    value = !!value;

                    if (this._rayPick === value) {
                        return;
                    }

                    this._dirty = false;

                    /**
                     * Fired whenever this MousePickEntity's {{#crossLink "MousePickEntity/rayPick:property"}}{{/crossLink}} property changes.
                     * @event rayPick
                     * @param value The property's new value
                     */
                    this.fire('rayPick', this._rayPick = value);
                },

                get: function () {
                    return this._rayPick;
                }
            }
        },

        _getJSON: function () {

            var json = {
                rayPick: this._rayPick,
                active: this._active
            };

            return json;
        },

        _destroy: function () {
            this.active = false;
        }
    });
})();;/**
 A **MouseZoomCamera** zooms a {{#crossLink "Camera"}}{{/crossLink}} using the mouse wheel.

 ## Overview

 <ul>
 <li>A MouseZoomCamera updates the {{#crossLink "Lookat"}}{{/crossLink}} attached to the target {{#crossLink "Camera"}}{{/crossLink}}.
 <li>Zooming involves translating the positions of the {{#crossLink "Lookat"}}Lookat's{{/crossLink}}
 {{#crossLink "Lookat/eye:property"}}{{/crossLink}} and {{#crossLink "Lookat/look:property"}}{{/crossLink}} back and forth
 along the {{#crossLink "Lookat/eye:property"}}{{/crossLink}}-&gt;{{#crossLink "Lookat/look:property"}}{{/crossLink}} vector.</li>
 </ul>

 ## Example

 ````Javascript
 var scene = new XEO.Scene();

 var camera = new XEO.Camera(scene);

 var control = new XEO.MouseZoomCamera(scene, {
        camera: camera
    });

 var entity = new XEO.Entity(scene);
 ````

 @class MouseZoomCamera
 @module XEO
 @submodule controls
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}{{/crossLink}}.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this MouseZoomCamera.
 @param [cfg.camera] {String|Camera} ID or instance of a {{#crossLink "Camera"}}Camera{{/crossLink}} to control.
 Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MouseZoomCamera. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/camera:property"}}camera{{/crossLink}}.
 @param [cfg.sensitivity=0.5] {Number} Zoom sensitivity factor.
 @param [cfg.active=true] {Boolean} Whether or not this MouseZoomCamera is active.
 @extends Component
 */
(function () {

    "use strict";

    XEO.MouseZoomCamera = XEO.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.MouseZoomCamera",

        _init: function (cfg) {

            // Event handles

            this._onTick = null;
            this._onMouseWheel = null;

            // Init properties

            this.camera = cfg.camera;
            this.sensitivity = cfg.sensitivity;
            this.active = cfg.active !== false;
        },

        _props: {

            /**
             * The {{#crossLink "Camera"}}Camera{{/crossLink}} attached to this MouseZoomCamera.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MouseZoomCamera. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/camera:property"}}camera{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires a {{#crossLink "MouseZoomCamera/camera:event"}}{{/crossLink}} event on change.
             *
             * @property camera
             * @type Camera
             */
            camera: {

                set: function (value) {

                    /**
                     * Fired whenever this MouseZoomCamera's {{#crossLink "MouseZoomCamera/camera:property"}}{{/crossLink}} property changes.
                     *
                     * @event camera
                     * @param value The property's new value
                     */
                    this._setChild("camera", value);
                },

                get: function () {
                    return this._children.camera;
                }
            },

            /**
             * The sensitivity of this MouseZoomCamera.
             *
             * Fires a {{#crossLink "MouseZoomCamera/sensitivity:event"}}{{/crossLink}} event on change.
             *
             * @property sensitivity
             * @type Number
             * @default 0.5
             */
            sensitivity: {

                set: function (value) {

                    this._sensitivity = value || 0.5;

                    /**
                     * Fired whenever this MouseZoomCamera's  {{#crossLink "MouseZoomCamera/sensitivity:property"}}{{/crossLink}} property changes.
                     *
                     * @event sensitivity
                     * @param value The property's new value
                     */
                    this.fire("sensitivity", this._sensitivity);
                },

                get: function () {
                    return this._sensitivity;
                }
            },

            /**
             * Indicates whether this MouseZoomCamera is active or not.
             *
             * Fires an {{#crossLink "MouseZoomCamera/active:event"}}{{/crossLink}} event on change.
             *
             * @property active
             * @type Boolean
             */
            active: {

                set: function (value) {

                    if (this._active === value) {
                        return;
                    }

                    if (value) {

                        var delta = 0;
                        var target = 0;
                        var newTarget = false;
                        var targeting = false;
                        var progress = 0;

                        var eyeVec = XEO.math.vec3();
                        var lookVec = XEO.math.vec3();
                        var tempVec3 = XEO.math.vec3();

                        var self = this;

                        this._onMouseWheel = this.scene.input.on("mousewheel",
                            function (_delta) {

                                delta = _delta;

                                if (delta === 0) {
                                    targeting = false;
                                    newTarget = false;
                                } else {
                                    newTarget = true;
                                }
                            });

                        this._onTick = this.scene.on("tick",
                            function () {

                                var camera = self._children.camera;

                                if (!camera) {
                                    return;
                                }

                                var eye = camera.view.eye;
                                var look = camera.view.look;

                                eyeVec[0] = eye[0];
                                eyeVec[1] = eye[1];
                                eyeVec[2] = eye[2];

                                lookVec[0] = look[0];
                                lookVec[1] = look[1];
                                lookVec[2] = look[2];

                                XEO.math.subVec3(eyeVec, lookVec, tempVec3);

                                var lenLook = Math.abs(XEO.math.lenVec3(tempVec3));
                                var lenLimits = 1000;
                                var f = self._sensitivity * (2.0 + (lenLook / lenLimits));

                                if (newTarget) {
                                    target = delta * f;
                                    progress = 0;
                                    newTarget = false;
                                    targeting = true;
                                }

                                if (targeting) {

                                    if (delta > 0) {

                                        progress += 0.2 * f;

                                        if (progress > target) {
                                            targeting = false;
                                        }

                                    } else if (delta < 0) {

                                        progress -= 0.2 * f;

                                        if (progress < target) {
                                            targeting = false;
                                        }
                                    }

                                    if (targeting) {
                                        camera.view.zoom(progress);
                                    }
                                }
                            });

                    } else {

                        if (this._onTick !== null) {
                            this.scene.off(this._onTick);
                            this.scene.input.off(this._onMouseWheel);
                        }
                    }

                    /**
                     * Fired whenever this MouseZoomCamera's {{#crossLink "MouseZoomCamera/active:property"}}{{/crossLink}} property changes.
                     * @event active
                     * @param value The property's new value
                     */
                    this.fire('active', this._active = value);
                },

                get: function () {
                    return this._active;
                }
            }
        },

        _getJSON: function () {

            var json = {
                sensitivity: this._sensitivity,
                active: this._active
            };

            if (this._children.camera) {
                json.camera = this._children.camera.id;
            }

            return json;
        },

        _destroy: function () {
            this.active = false;
        }
    });

})();
;/**
 * Components for controlling the visibility of Entities.
 *
 * @module XEO
 * @submodule culling
 */;/**
 A **Visibility** toggles the visibility of attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>
 <li>A Visibility may be shared among multiple {{#crossLink "Entity"}}Entities{{/crossLink}} to toggle
 their visibility as a group.</li>
 </ul>

 <img src="../../../assets/images/Visibility.png"></img>

 ## Example

 This example creates a Visibility that toggles the visibility of
 two {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ````javascript
 var scene = new XEO.Scene();

 // Create a Visibility
 var visibility = new XEO.Visibility(scene, {
    visible: true
});

 // Create two Entities whose visibility will be controlled by our Visibility

 var entity1 = new XEO.Entity(scene, {
    visibility: visibility
});

 var entity2 = new XEO.Entity(scene, {
    visibility: visibility
});

 // Subscribe to change on the Visibility's "visible" property
 var handle = visibility.on("visible", function(value) {
    //...
});

 // Hide our Entities by flipping the Visibility's "visible" property,
 // which will also call our handler
 visibility.visible = false;

 // Unsubscribe from the Visibility again
 visibility.off(handle);

 // When we destroy our Visibility, the Entities will fall back
 // on the Scene's default Visibility instance
 visibility.destroy();
 ````
 @class Visibility
 @module XEO
 @submodule culling
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Visibility in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Visibility.
 @param [cfg.visible=true] {Boolean} Flag which controls visibility of the attached {{#crossLink "Entity"}}Entities{{/crossLink}}
 @extends Component
 */
(function () {

    "use strict";

    XEO.Visibility = XEO.Component.extend({

        type: "XEO.Visibility",

        _init: function (cfg) {

            this._state = new XEO.renderer.Visibility({
                visible: true
            });

            this.visible = cfg.visible;
        },

        _props: {

            /**
             Indicates whether this Visibility makes attached {{#crossLink "Entity"}}Entities{{/crossLink}} visible or not.

             Fires a {{#crossLink "Visibility/visible:event"}}{{/crossLink}} event on change.

             @property visible
             @default true
             @type Boolean
             */
            visible: {

                set: function (value) {

                    this._state.visible =  value !== false;

                    this._renderer.drawListDirty = true;

                    /**
                     Fired whenever this Visibility's {{#crossLink "Visibility/visible:property"}}{{/crossLink}} property changes.

                     @event visible
                     @param value {Boolean} The property's new value
                     */
                    this.fire("visible",  this._state.visible);
                },

                get: function () {
                    return this._state.visible;
                }
            }
        },

        _compile: function () {
            this._renderer.visibility = this._state;
        },

        _getJSON: function () {
            return {
                visible: this.visible
            };
        },

        _destroy: function () {
            this._state.destroy();
        }
    });

})();
;/**
 Components for defining 3D curves.

 @module XEO
 @submodule curves
 */;/**
 A **Curve** is the abstract base class for various other curve classes.

 ## Overview

 The Curve is subclassed by the following component types:

 <ul>
 <li>{{#crossLink "SplineCurve"}}{{/crossLink}}</li>
 <li>{{#crossLink "CubicBezierCurve"}}{{/crossLink}}</li>
 <li>{{#crossLink "QuadraticBezierCurve"}}{{/crossLink}}</li>
 <li>{{#crossLink "Path"}}{{/crossLink}}</li>
 </u>

 @class Curve
 @module XEO
 @submodule curves
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg] {*} Configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Curve.
 @param [cfg.t=0] Current position on this Curve, in range between 0..1.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Curve = XEO.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.Curve",

        _init: function (cfg) {

            this.t = cfg.t;
        },

        _props: {

            /**
             Progress along this Curve.

             Automatically clamps to range [0..1].

             Fires a {{#crossLink "Curve/t:event"}}{{/crossLink}} event on change.

             @property t
             @default 0
             @type Number
             */
            t: {

                set: function (value) {

                    value = value || 0;

                    this._t = value < 0.0 ? 0.0 : (value > 1.0 ? 1.0 : value);

                    /**
                     * Fired whenever this Curve's
                     * {{#crossLink "Curve/t:property"}}{{/crossLink}} property changes.
                     * @event t
                     * @param value The property's new value
                     */
                    this.fire("t", this._t);
                },

                get: function () {
                    return this._t;
                }
            },


            /**
             Tangent on this Curve at position {{#crossLink "Curve/t:property"}}{{/crossLink}}.

             @property point
             @type {{Array of Number}}
             */
            tangent: {

                get: function () {

                    return this.getTangent(this._t);
                }
            },

            /**
             Length of this Curve.
             @property length
             @type {Number}
             */
            length: {

                get: function () {
                    var lengths = this._getLengths();
                    return lengths[lengths.length - 1];
                }
            }
        },

        /**
         * Returns a normalized tangent vector on this Curve at the given position.
         * @method getTangent
         * @param {Number} t Position to get tangent at.
         * @returns {{Array of Number}} Normalized tangent vector
         */
        getTangent: function(t) {

            var delta = 0.0001;

            var t1 = this._t - delta;
            var t2 = this._t + delta;

            if (t1 < 0) {
                t1 = 0;
            }

            if (t2 > 1) {
                t2 = 1;
            }

            var pt1 = this.getPoint(t1);
            var pt2 = this.getPoint(t2);

            var vec = XEO.math.subVec3(pt2, pt1, []);

            return XEO.math.normalizeVec3(vec, []);
        },


        _getPointAt: function (u) {

            var t = this._getUToTMapping(u);

            return this.getPoint(t);

        },

        /**
         * Samples points on this Curve, at the given number of equally-spaced divisions.
         * @method getPoints
         * @param {Number} divisions The number of divisions.
         * @returns {Array of Array} Array of sampled 3D points.
         */
        getPoints: function (divisions) {

            if (!divisions) {
                divisions = 5;
            }

            var d, pts = [];

            for (d = 0; d <= divisions; d++) {
                pts.push(this.getPoint(d / divisions));
            }

            return pts;

        },

        getSpacedPoints: function (divisions) {

            if (!divisions) {
                divisions = 5;
            }

            var d, pts = [];

            for (d = 0; d <= divisions; d++) {
                pts.push(this._getPointAt(d / divisions));
            }

            return pts;
        },


        _getLengths: function (divisions) {

            if (!divisions) {
                divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;
            }

            if (this.cacheArcLengths
                && ( this.cacheArcLengths.length == divisions + 1 )
                && !this.needsUpdate) {

                return this.cacheArcLengths;

            }

            this.needsUpdate = false;

            var cache = [];
            var current;
            var last = this.getPoint(0);
            var p;
            var sum = 0;

            cache.push(0);

            for (p = 1; p <= divisions; p++) {

                current = this.getPoint(p / divisions);
                sum += XEO.math.lenVec3(XEO.math.subVec3(current, last, []));
                cache.push(sum);
                last = current;

            }

            this.cacheArcLengths = cache;

            return cache; // { sums: cache, sum:sum }, Sum is in the last element.

        },

        _updateArcLengths: function () {
            this.needsUpdate = true;
            this._getLengths();
        },

        // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

        _getUToTMapping: function (u, distance) {

            var arcLengths = this._getLengths();

            var i = 0, il = arcLengths.length;

            var targetArcLength; // The targeted u distance value to get

            if (distance) {

                targetArcLength = distance;

            } else {

                targetArcLength = u * arcLengths[il - 1];
            }

            //var time = Date.now();

            // binary search for the index with largest value smaller than target u distance

            var low = 0, high = il - 1, comparison;

            while (low <= high) {

                i = Math.floor(low + ( high - low ) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

                comparison = arcLengths[i] - targetArcLength;

                if (comparison < 0) {

                    low = i + 1;

                } else if (comparison > 0) {

                    high = i - 1;

                } else {

                    high = i;
                    break;

                    // DONE
                }
            }

            i = high;

            //console.log('b' , i, low, high, Date.now()- time);

            if (arcLengths[i] == targetArcLength) {

                var t = i / ( il - 1 );
                return t;

            }

            // we could get finer grain at lengths, or use simple interpolatation between two points

            var lengthBefore = arcLengths[i];
            var lengthAfter = arcLengths[i + 1];

            var segmentLength = lengthAfter - lengthBefore;

            // determine where we are between the 'before' and 'after' points

            var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

            // add that fractional amount to t

            var t = ( i + segmentFraction ) / ( il - 1 );

            return t;
        }
    });

})();
;/**
 A **CubicBezierCurve** extends {{#crossLink "Curve"}}{{/crossLink}} to provide a cubic Bezier curve.

 ## Overview

 <img style="border:1px solid;" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/B%C3%A9zier_3_big.gif/240px-B%C3%A9zier_3_big.gif"/>

 *[Cubic Bezier Curve from WikiPedia](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)*

 <ul>
 <li>To build a complex path, you can combine an unlimited combination of CubicBezierCurves,
 {{#crossLink "QuadraticBezierCurve"}}QuadraticBezierCurves{{/crossLink}} and {{#crossLink "SplineCurve"}}SplineCurves{{/crossLink}}
 within a {{#crossLink "Path"}}{{/crossLink}}.</li>
 </ul>

 ## Example

 ````javascript

 var curve = new XEO.CubicBezierCurve({
        v0: [-10, 0, 0],
        v1: [-5, 15, 0],
        v2: [20, 15, 0],
        v3: [10, 0, 0]
    });

 curve.scene.on("tick", function(e) {

        curve.t = (e.time - e.startTime) * 0.01;

        var point = curve.point;
        var tangent = curve.tangent;

        this.log("t=" + curve.t + ", point=" +
            JSON.stringify(point) + ", tangent=" +
                JSON.stringify(tangent));
    });
 ````

 @class CubicBezierCurve
 @module XEO
 @submodule curves
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg] {*} Configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this CubicBezierCurve.
 @param [cfg.v0=[0,0,0]] The starting point.
 @param [cfg.v1=[0,0,0]] The first control point.
 @param [cfg.v2=[0,0,0]] The middle control point.
 @param [cfg.v3=[0,0,0]] The ending point.
 @param [cfg.t=0] Current position on this CubicBezierCurve, in range between 0..1.
 @extends Curve
 */
(function () {

    "use strict";

    XEO.CubicBezierCurve = XEO.Curve.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.CubicBezierCurve",

        _init: function (cfg) {

            this._super(cfg);

            this.v0 = cfg.v0;
            this.v1 = cfg.v1;
            this.v2 = cfg.v2;
            this.v3 = cfg.v3;

            this.t = cfg.t;
        },

        _props: {

            /**
             Starting point on this CubicBezierCurve.

             Fires a {{#crossLink "CubicBezierCurve/v0:event"}}{{/crossLink}} event on change.

             @property v0
             @default [0.0, 0.0, 0.0]
             @type Array(Number)
             */
            v0: {

                set: function (value) {

                    /**
                     * Fired whenever this CubicBezierCurve's
                     * {{#crossLink "CubicBezierCurve/v0:property"}}{{/crossLink}} property changes.
                     * @event v0
                     * @param value The property's new value
                     */
                    this.fire("v0", this._v0 = value || [0, 0, 0]);
                },

                get: function () {
                    return this._v0;
                }
            },

            /**
             First control point on this CubicBezierCurve.

             Fires a {{#crossLink "CubicBezierCurve/v1:event"}}{{/crossLink}} event on change.

             @property v1
             @default [0.0, 0.0, 0.0]
             @type Array(Number)
             */
            v1: {

                set: function (value) {

                    /**
                     * Fired whenever this CubicBezierCurve's
                     * {{#crossLink "CubicBezierCurve/v1:property"}}{{/crossLink}} property changes.
                     * @event v1
                     * @param value The property's new value
                     */
                    this.fire("v1", this._v1 = value || [0, 0, 0]);
                },

                get: function () {
                    return this._v1;
                }
            },

            /**
             Second control point on this CubicBezierCurve.

             Fires a {{#crossLink "CubicBezierCurve/v2:event"}}{{/crossLink}} event on change.

             @property v2
             @default [0.0, 0.0, 0.0]
             @type Array(Number)
             */
            v2: {

                set: function (value) {

                    /**
                     * Fired whenever this CubicBezierCurve's
                     * {{#crossLink "CubicBezierCurve/v2:property"}}{{/crossLink}} property changes.
                     * @event v2
                     * @param value The property's new value
                     */
                    this.fire("v2", this._v2 = value || [0, 0, 0]);
                },

                get: function () {
                    return this._v2;
                }
            },

            /**
             End point on this CubicBezierCurve.

             Fires a {{#crossLink "CubicBezierCurve/v3:event"}}{{/crossLink}} event on change.

             @property v3
             @default [0.0, 0.0, 0.0]
             @type Array(Number)
             */
            v3: {

                set: function (value) {

                    /**
                     * Fired whenever this CubicBezierCurve's
                     * {{#crossLink "CubicBezierCurve/v3:property"}}{{/crossLink}} property changes.
                     * @event v3
                     * @param value The property's new value
                     */
                    this.fire("v3", this._v3 = value || [0, 0, 0]);
                },

                get: function () {
                    return this._v3;
                }
            },

            /**
             Current position of progress along this CubicBezierCurve.

             Automatically clamps to range [0..1].

             Fires a {{#crossLink "CubicBezierCurve/t:event"}}{{/crossLink}} event on change.

             @property t
             @default 0
             @type Number
             */
            t: {
                set: function (value) {

                    value = value || 0;

                    this._t = value < 0.0 ? 0.0 : (value > 1.0 ? 1.0 : value);

                    /**
                     * Fired whenever this CubicBezierCurve's
                     * {{#crossLink "CubicBezierCurve/t:property"}}{{/crossLink}} property changes.
                     * @event t
                     * @param value The property's new value
                     */
                    this.fire("t", this._t);
                },

                get: function () {
                    return this._t;
                }
            },

            /**
             Point on this CubicBezierCurve at position {{#crossLink "CubicBezierCurve/t:property"}}{{/crossLink}}.

             @property point
             @type {{Array of Number}}
             */
            point: {

                get: function () {
                    return this.getPoint(this._t);
                }
            }
        },

        /**
         * Returns point on this CubicBezierCurve at the given position.
         * @param {Number} t Position to get point at.
         * @returns {{Array of Number}}
         */
        getPoint: function (t) {

            var math = XEO.math;
            var vector = math.vec3();

            vector[0] = math.b3(t, this._v0[0], this._v1[0], this._v2[0], this._v3[0]);
            vector[1] = math.b3(t, this._v0[1], this._v1[1], this._v2[1], this._v3[1]);
            vector[2] = math.b3(t, this._v0[2], this._v1[2], this._v2[2], this._v3[2]);

            return vector;
        },

        _getJSON: function () {
            return {
                v0: this._v0,
                v1: this._v1,
                v2: this._v2,
                v3: this._v3,
                t: this._t
            };
        }
    });

})();
;/**
 A **SplineCurve** extends {{#crossLink "Curve"}}{{/crossLink}} to provide a spline curve.

 ## Overview

 <img style="border:1px solid; background: white;" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Quadratic_spline_six_segments.svg/200px-Quadratic_spline_six_segments.svg.png"/>

 *[Spline Curve from Wikipedia](https://en.wikipedia.org/wiki/Spline_(mathematics))*

 <ul>
 <li>To build a complex path, you can combine an unlimited combination of SplineCurves,
 {{#crossLink "CubicBezierCurve"}}CubicBezierCurves{{/crossLink}} and {{#crossLink "QuadraticBezierCurve"}}QuadraticBezierCurves{{/crossLink}}
 within a {{#crossLink "Path"}}{{/crossLink}}.</li>
 </ul>


 ## Example 1

 Create a SplineCurve, subscribe to updates on its {{#crossLink "SplineCurve/point:property"}}{{/crossLink}} and
 {{#crossLink "Curve/tangent:property"}}{{/crossLink}} properties, then vary its {{#crossLink "SplineCurve/t:property"}}{{/crossLink}}
 property over time:

 ````javascript

 var curve = new XEO.SplineCurve({
        points: [
            [-10, 0, 0],
            [-5, 15, 0],
            [20, 15, 0],
            [10, 0, 0]
        ]
    });

 curve.scene.on("tick", function(e) {

        curve.t = (e.time - e.startTime) * 0.01;

        var point = curve.point;
        var tangent = curve.tangent;

        this.log("t=" + curve.t + ", point=" + JSON.stringify(point) + ", tangent=" + JSON.stringify(tangent));
    });
 ````

 ## Example 2

 Alternatively, we can randomly sample the point and vector at a given **t** with calls
 to the SplineCurve's {{#crossLink "SplineCurve/getPoint:method"}}{{/crossLink}} and
 {{#crossLink "Curve/getTangent:method"}}{{/crossLink}} methods:

 ````javascript
 var curve = new XEO.SplineCurve({
        points: [
            [-10, 0, 0],
            [-5, 15, 0],
            [20, 15, 0],
            [10, 0, 0]
        ]
    });

 curve.scene.on("tick", function(e) {

        var t = (e.time - e.startTime) * 0.01;

        var point = curve.getPoint(t);
        var tangent = curve.getTangent(t);

        this.log("t=" + t + ", point=" + JSON.stringify(point) + ", tangent=" + JSON.stringify(tangent));
    });
 ````

 @class SplineCurve
 @module XEO
 @submodule curves
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg] {*} Configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this SplineCurve.
 @param [cfg.points=[]] Control points on this SplineCurve.
 @param [cfg.t=0] Current position on this SplineCurve, in range between 0..1.
 @extends Curve
 */
(function () {

    "use strict";

    XEO.SplineCurve = XEO.Curve.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.SplineCurve",

        _init: function (cfg) {

            this._super(cfg);

            this.points = cfg.points;

            this.t = cfg.t;
        },

        _props: {

            /**
             Control points on this SplineCurve.

             Fires a {{#crossLink "SplineCurve/points:event"}}{{/crossLink}} event on change.

             @property points
             @default []
             @type Array(Number)
             */
            points: {

                set: function (value) {

                    this._points = value || [];

                    /**
                     * Fired whenever this SplineCurve's
                     * {{#crossLink "SplineCurve/points:property"}}{{/crossLink}} property changes.
                     * @event points
                     * @param value The property's new value
                     */
                    this.fire("points", this._points);
                },

                get: function () {
                    return this._points;
                }
            },

            /**
             Progress along this SplineCurve.

             Automatically clamps to range [0..1].

             Fires a {{#crossLink "SplineCurve/t:event"}}{{/crossLink}} event on change.

             @property t
             @default 0
             @type Number
             */
            t: {
                set: function (value) {

                    value = value || 0;

                    this._t = value < 0.0 ? 0.0 : (value > 1.0 ? 1.0 : value);

                    /**
                     * Fired whenever this SplineCurve's
                     * {{#crossLink "SplineCurve/t:property"}}{{/crossLink}} property changes.
                     * @event t
                     * @param value The property's new value
                     */
                    this.fire("t", this._t);
                },

                get: function () {
                    return this._t;
                }
            },

            /**
             Point on this SplineCurve at position {{#crossLink "SplineCurve/t:property"}}{{/crossLink}}.

             @property point
             @type {{Array of Number}}
             */
            point: {

                get: function () {
                    return this.getPoint(this._t);
                }
            }
        },

        /**
         * Returns point on this SplineCurve at the given position.
         * @method getPoint
         * @param {Number} t Position to get point at.
         * @returns {{Array of Number}}
         */
        getPoint: function(t) {

            var math = XEO.math;

            var points = this.points;
            var point = ( points.length - 1 ) * t;

            var intPoint = Math.floor(point);
            var weight = point - intPoint;

            var point0 = points[intPoint == 0 ? intPoint : intPoint - 1];
            var point1 = points[intPoint];
            var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
            var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];

            var vector = math.vec3();

            vector[0] = math.catmullRomInterpolate(point0[0], point1[0], point2[0], point3[0], weight);
            vector[1] = math.catmullRomInterpolate(point0[1], point1[1], point2[1], point3[1], weight);
            vector[2] = math.catmullRomInterpolate(point0[2], point1[2], point2[2], point3[2], weight);

            return vector;
        },

        _getJSON: function () {
            return {
                v0: this._v0,
                v1: this._v1,
                v2: this._v2,
                v3: this._v3,
                t: this._t
            };
        }
    });

})();
;/**
 A **QuadraticBezierCurve** extends {{#crossLink "Curve"}}{{/crossLink}} to provide a cubic Bezier curve.

 ## Overview

 <img style="border:1px solid;" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3d/B%C3%A9zier_2_big.gif/240px-B%C3%A9zier_2_big.gif"/>

 *[Quadratic Bezier Curve from WikiPedia](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)*

 <ul>
 <li>To build a complex path, you can combine an unlimited combination of QuadraticBezierCurves,
 {{#crossLink "CubicBezierCurve"}}CubicBezierCurves{{/crossLink}} and {{#crossLink "SplineCurve"}}SplineCurves{{/crossLink}}
 within a {{#crossLink "Path"}}{{/crossLink}}.</li>
 </ul>

 ## Example 1

 In our first example, we'll define a QuadraticBezierCurve and update it on each scene tick,
 while logging the curve's changing properties.

 ````javascript
 var curve = new XEO.QuadraticBezierCurve({
        v0: [-10, 0, 0],
        v1: [20, 15, 0],
        v2: [10, 0, 0]
    });

 curve.scene.on("tick", function(e) {

        curve.t = (e.time - e.startTime) * 0.01;

        var point = curve.point;
        var tangent = curve.tangent;

        this.log("t=" + curve.t + ", point=" +
            JSON.stringify(point) + ", tangent=" +
                JSON.stringify(tangent));
    });
 ````

 ## Example 2

 In the next example, we'll create an {{#crossLink "Entity"}}{{/crossLink}} with a
 {{#crossLink "PhongMaterial"}}{{/crossLink}} whose diffuse color is bound to the
 interpolated {{#crossLink "QuadraticBezierCurve/point:property"}}{{/crossLink}} property on the QuadraticBezierCurve.

 Then we'll animate the QuadraticBezierCurve's {{#crossLink "QuadraticBezierCurve/t:property"}}{{/crossLink}} property
 to update the diffuse color.

 ````javascript
 var curve = new XEO.QuadraticBezierCurve({
        v0: [1, 0, 0],
        v1: [0, 1, 0],
        v2: [0, 0, 1]
    });

 // Create a Entity with a PhongMaterial
 var material = new XEO.PhongMaterial({
        diffuse: [0, 0, 0]
    });

 var entity = new XEO.Entity({
        material: material
    });

 // Bind the PhongMaterial diffuse color
 // to the QuadraticBezierCurve
 curve.on("t", function() {
        material.diffuse = curve.point;
    });

 // Animate the QuadraticBezierCurve, which in turn
 // updates the PhongMaterial diffuse color
 var tick = entity.scene.on("tick", function (e) {
        curve.t = (e.time - e.startTime) * 0.00005;
   });
 ````

 ## Example 3

 In the previous two examples, we relied on our QuadraticBezierCurves to remember their progress in their
 {{#crossLink "QuadraticBezierCurve/t:property"}}{{/crossLink}} and {{#crossLink "QuadraticBezierCurve/point:property"}}{{/crossLink}}
 properties, which is useful when we want to wire components together into reactive event-driven networks, as we did with the
 PhongMaterial in the previous example.

 As an alternative, we can instead sample the point and vector at a given *t* via calls
 to the QuadraticBezierCurve's {{#crossLink "QuadraticBezierCurve/getPoint:method"}}{{/crossLink}} and
 {{#crossLink "Curve/getTangent:method"}}{{/crossLink}} methods:

 ````javascript
 var curve = new XEO.QuadraticBezierCurve({
        v0: [-10, 0, 0],
        v1: [20, 15, 0],
        v2: [10, 0, 0]
    });

 curve.scene.on("tick", function(e) {

        var t = (e.time - e.startTime) * 0.01;

        var point = curve.getPoint(t);
        var tangent = curve.getTangent(t);

        this.log("t=" + t + ", point=" + JSON.stringify(point) + ", tangent=" + JSON.stringify(tangent));
    });
 ````

 ## Example 4

 When we want to build a {{#crossLink "Geometry"}}{{/crossLink}} from a QuadraticBezierCurve, we can sample points
 along the curve using its {{#crossLink "Curve/getPoints:method"}}{{/crossLink}} method, as shown below.

 Note that we need to flatten the points array for consumption by the {{#crossLink "Geometry"}}{{/crossLink}}.

 ````javascript
 var curve = new XEO.QuadraticBezierCurve({
        v0: [-10, 0, 0],
        v1: [20, 15, 0],
        v2: [10, 0, 0]
    });

 // Geometry which creates a line-strip through fifty
 // points sampled at equidistant positions on our QuadraticBezierCurve

 var geometry = new XEO.Geometry({
    positions: XEO.math.flatten(curve.getPoints(50))
 });
 ````

 @class QuadraticBezierCurve
 @module XEO
 @submodule curves
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg] {*} Configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this QuadraticBezierCurve.
 @param [cfg.v0=[0,0,0]] The starting point.
 @param [cfg.v1=[0,0,0]] The middle control point.
 @param [cfg.v2=[0,0,0]] The end point.
 @param [cfg.t=0] Current position on this QuadraticBezierCurve, in range between 0..1.
 @extends Curve
 */
(function () {

    "use strict";

    XEO.QuadraticBezierCurve = XEO.Curve.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.QuadraticBezierCurve",

        _init: function (cfg) {

            this._super(cfg);

            this.v0 = cfg.v0;
            this.v1 = cfg.v1;
            this.v2 = cfg.v2;

            this.t = cfg.t;
        },

        _props: {

            /**
             Starting point on this QuadraticBezierCurve.

             Fires a {{#crossLink "QuadraticBezierCurve/v0:event"}}{{/crossLink}} event on change.

             @property v0
             @default [0.0, 0.0, 0.0]
             @type Array(Number)
             */
            v0: {

                set: function (value) {

                    /**
                     * Fired whenever this QuadraticBezierCurve's
                     * {{#crossLink "QuadraticBezierCurve/v0:property"}}{{/crossLink}} property changes.
                     * @event v0
                     * @param value The property's new value
                     */
                    this.fire("v0", this._v0 = value || [0, 0, 0]);
                },

                get: function () {
                    return this._v0;
                }
            },

            /**
             Middle control point on this QuadraticBezierCurve.

             Fires a {{#crossLink "QuadraticBezierCurve/v1:event"}}{{/crossLink}} event on change.

             @property v1
             @default [0.0, 0.0, 0.0]
             @type Array(Number)
             */
            v1: {

                set: function (value) {

                    /**
                     * Fired whenever this QuadraticBezierCurve's
                     * {{#crossLink "QuadraticBezierCurve/v1:property"}}{{/crossLink}} property changes.
                     * @event v1
                     * @param value The property's new value
                     */
                    this.fire("v1", this._v1 = value || [0, 0, 0]);
                },

                get: function () {
                    return this._v1;
                }
            },

            /**
             End point on this QuadraticBezierCurve.

             Fires a {{#crossLink "QuadraticBezierCurve/v2:event"}}{{/crossLink}} event on change.

             @property v2
             @default [0.0, 0.0, 0.0]
             @type Array(Number)
             */
            v2: {

                set: function (value) {

                    /**
                     * Fired whenever this QuadraticBezierCurve's
                     * {{#crossLink "QuadraticBezierCurve/v2:property"}}{{/crossLink}} property changes.
                     * @event v2
                     * @param value The property's new value
                     */
                    this.fire("v2", this._v2 = value || [0, 0, 0]);
                },

                get: function () {
                    return this._v2;
                }
            },

            /**
             Progress along this QuadraticBezierCurve.

             Automatically clamps to range [0..1].

             Fires a {{#crossLink "QuadraticBezierCurve/t:event"}}{{/crossLink}} event on change.

             @property t
             @default 0
             @type Number
             */
            t: {
                set: function (value) {

                    value = value || 0;

                    this._t = value < 0.0 ? 0.0 : (value > 1.0 ? 1.0 : value);

                    /**
                     * Fired whenever this QuadraticBezierCurve's
                     * {{#crossLink "QuadraticBezierCurve/t:property"}}{{/crossLink}} property changes.
                     * @event t
                     * @param value The property's new value
                     */
                    this.fire("t", this._t);
                },

                get: function () {
                    return this._t;
                }
            },


            /**
             Point on this QuadraticBezierCurve at position {{#crossLink "QuadraticBezierCurve/t:property"}}{{/crossLink}}.

             @property point
             @type {{Array of Number}}
             */
            point: {

                get: function () {
                    return this.getPoint(this._t);
                }
            }
        },

        /**
         * Returns point on this QuadraticBezierCurve at the given position.
         * @method getPoint
         * @param {Number} t Position to get point at.
         * @returns {{Array of Number}}
         */
        getPoint: function (t) {

            var math = XEO.math;
            var vector = math.vec3();

            vector[0] = math.b2(t, this._v0[0], this._v1[0], this._v2[0]);
            vector[1] = math.b2(t, this._v0[1], this._v1[1], this._v2[1]);
            vector[2] = math.b2(t, this._v0[2], this._v1[2], this._v2[2]);

            return vector;
        },

        _getJSON: function () {
            return {
                v0: this._v0,
                v1: this._v1,
                v2: this._v2,
                t: this._t
            };
        }
    });

})();
;/**
 A **Path** is a complex curved path constructed from various types of sub-curves.

 ## Overview

 A Path can be constructed from the following {{#crossLink "Curve"}}{{/crossLink}} sub-classes:

 <ul>
 <li>{{#crossLink "SplineCurve"}}{{/crossLink}}</li>
 <li>{{#crossLink "CubicBezierCurve"}}{{/crossLink}}</li>
 <li>{{#crossLink "QuadraticBezierCurve"}}{{/crossLink}}</li>
 </ul>

 ## Example

 ````javascript

 var path = new XEO.Path({
        curves: [
            new XEO.CubicBezierCurve({
                v0: [-10, 0, 0],
                v1: [-5, 15, 0],
                v2: [20, 15, 0],
                v3: [10, 0, 0]
            }),
            new XEO.QuadraticBezierCurve({
                v0: [-10, 0, 0],
                v1: [20, 15, 0],
                v2: [10, 0, 0]
            }),
            new XEO.SplineCurve({
                points: [
                    [-10, 0, 0],
                    [-5, 15, 0],
                    [20, 15, 0],
                    [10, 0, 0]
                ]
            })
        ]
    });

 path.scene.on("tick", function(e) {

        path.t = (e.time - e.startTime) * 0.01;

        var point = path.point;
        var tangent = path.tangent;

        this.log("t=" + path.t + ", point=" +
            JSON.stringify(point) + ", tangent=" +
                JSON.stringify(tangent));
    });
 ````

 @class Path
 @module XEO
 @submodule curves
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg] {*} Fly configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Path.
 @param [cfg.curves=[]] IDs or instances of {{#crossLink "Curve"}}{{/crossLink}} subtypes to add to this Path.
 @param [cfg.t=0] Current position on this Path, in range between 0..1.
 @extends Curve
 */
(function () {

    "use strict";

    XEO.Path = XEO.Curve.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.Path",

        _init: function (cfg) {

            this._super(cfg);

            this._cachedLengths = [];
            this._dirty = true;

            // Array of child Curve components
            this._curves = [];

            this._t = 0;

            // Subscriptions to "dirty" events from child Curve components
            this._dirtySubs = [];

            // Subscriptions to "destroyed" events from child Curve components
            this._destroyedSubs = [];

            // Add initial curves
            this.curves = cfg.curves || [];

            // Set initial progress
            this.t = cfg.t;
        },

        /**
         * Adds a {{#crossLink "Curve"}}{{/crossLink}} to this Path.
         *
         * Fires a {{#crossLink "Path/curves:event"}}{{/crossLink}} event on change.
         *
         * @param {Curve} curve The {{#crossLink "Curve"}}{{/crossLink}} to add.
         */
        addCurve: function (curve) {

            this._curves.push(curve);

            this._dirty = true;

            /**
             * Fired whenever this Path's
             * {{#crossLink "Path/curves:property"}}{{/crossLink}} property changes.
             * @event curves
             * @param value The property's new value
             */
            this.fire("curves", this._curves);
        },

        _props: {

            /**
             The {{#crossLink "Curve"}}Curves{{/crossLink}} in this Path.

             Fires a {{#crossLink "Path/curves:event"}}{{/crossLink}} event on change.

             @property curves
             @default []
             @type {{Array of Spline, Path, QuadraticBezierCurve or CubicBezierCurve}}
             */
            curves: {

                set: function (value) {

                    value = value || [];

                    var curve;

                    // Unsubscribe from events on old curves

                    var i;
                    var len;

                    for (i = 0, len = this._curves.length; i < len; i++) {

                        curve = this._curves[i];

                        curve.off(this._dirtySubs[i]);
                        curve.off(this._destroyedSubs[i]);
                    }

                    this._curves = [];

                    this._dirtySubs = [];
                    this._destroyedSubs = [];

                    var self = this;

                    function curveDirty() {
                        self._dirty = true;
                    }

                    function curveDestroyed() {

                        var id = this.id;

                        for (i = 0, len = self._curves.length; i < len; i++) {

                            if (self._curves[i].id === id) {

                                self._curves = self._curves.slice(i, i + 1);
                                self._dirtySubs = self._dirtySubs.slice(i, i + 1);
                                self._destroyedSubs = self._destroyedSubs.slice(i, i + 1);

                                self._dirty = true;

                                self.fire("curves", self._curves);

                                return;
                            }
                        }
                    }

                    for (i = 0, len = value.length; i < len; i++) {

                        curve = value[i];

                        if (XEO._isNumeric(curve) || XEO._isString(curve)) {

                            // ID given for curve - find the curve component

                            var id = curve;

                            curve = this.scene.components[id];

                            if (!curve) {
                                this.error("Component not found: " + XEO._inQuotes(id));
                                continue;
                            }
                        }

                        var type = curve.type;

                        if (type !== "XEO.SplineCurve" &&
                            type != "XEO.Path" &&
                            type != "XEO.CubicBezierCurve" &&
                            type != "XEO.QuadraticBezierCurve") {

                            this.error("Component " + XEO._inQuotes(curve.id)
                                + " is not a XEO.SplineCurve, XEO.Path or XEO.QuadraticBezierCurve");

                            continue;
                        }

                        this._curves.push(curve);

                        this._dirtySubs.push(curve.on("dirty", curveDirty));

                        this._destroyedSubs.push(curve.on("destroyed", curveDestroyed));
                    }

                    this._dirty = true;

                    this.fire("curves", this._curves);
                },

                get: function () {
                    return this._curves;
                }
            },

            /**
             Current point of progress along this Path.

             Automatically clamps to range [0..1].

             Fires a {{#crossLink "Path/t:event"}}{{/crossLink}} event on change.

             @property t
             @default 0
             @type Number
             */
            t: {
                set: function (value) {

                    value = value || 0;

                    this._t = value < 0.0 ? 0.0 : (value > 1.0 ? 1.0 : value);

                    /**
                     * Fired whenever this Path's
                     * {{#crossLink "Path/t:property"}}{{/crossLink}} property changes.
                     * @event t
                     * @param value The property's new value
                     */
                    this.fire("t", this._t);
                },

                get: function () {
                    return this._t;
                }
            },

            /**
             Point on this Path corresponding to the current value of {{#crossLink "Path/t:property"}}{{/crossLink}}.

             @property point
             @type {{Array of Number}}
             */
            point: {

                get: function () {
                    return this.getPoint(this._t);
                }
            },

            /**
             Length of this Path, which is the cumulative length of all {{#crossLink "Curve/t:property"}}Curves{{/crossLink}}
             currently in {{#crossLink "Path/curves:property"}}{{/crossLink}}.

             @property length
             @type {Number}
             */
            length: {

                get: function () {
                    var lens = this._getCurveLengths();
                    return lens[lens.length - 1];
                }
            }
        },

        /**
         * Gets a point on this Path corresponding to the given progress position.
         * @param {Number} t Indicates point of progress along this curve, in the range [0..1].
         * @returns {{Array of Number}}
         */
        getPoint: function (t) {

            var d = t * this.length;
            var curveLengths = this._getCurveLengths();
            var i = 0, diff, curve;

            while (i < curveLengths.length) {

                if (curveLengths[i] >= d) {

                    diff = curveLengths[i] - d;
                    curve = this._curves[i];

                    var u = 1 - diff / curve.length;

                    return curve._getPointAt(u);
                }
                i++;
            }
            return null;
        },

        _getCurveLengths: function () {

            if (!this._dirty) {
                return this._cachedLengths;
            }

            var lengths = [];
            var sums = 0;
            var i, il = this._curves.length;

            for (i = 0; i < il; i++) {

                sums += this._curves[i].length;
                lengths.push(sums);

            }

            this._cachedLengths = lengths;
            this._dirty = false;

            return lengths;
        },

        _getJSON: function () {

            var curveIds = [];

            for (var i = 0, len = this._curves.length; i < len; i++) {
                curveIds.push(this._curves[i].id);
            }

            return {
                curves: curveIds,
                t: this._t
            };
        },

        _destroy: function () {

            var i;
            var len;
            var curve;

            for (i = 0, len = this._curves.length; i < len; i++) {

                curve = this._curves[i];

                curve.off(this._dirtySubs[i]);
                curve.off(this._destroyedSubs[i]);
            }

            this._super();
        }
    });

})();

;/**
 * Components for defining geometry.
 *
 * @module XEO
 * @submodule geometry
 */;/**
 A **Geometry** defines the geometric shape of attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Contents

 <ul>
 <li><a href="#overview">Overview</a></li>
 <li><a href="#defaultShape">Default box shape</a></li>
 <li><a href="#sceneDefault">Scene's default Geometry</a></li>
 <li><a href="#sharing">Sharing among Entities</a></li>
 <li><a href="#triangles">Defining a triangle mesh</a></li>
 <li><a href="#editing">Editing Geometry</a></li>
 <li><a href="#backfaces">Toggling backfaces on or off</li>
 <li><a href="#frontfaces">Setting frontface vertex winding</li>
 </ul>

 ## <a name="overview">Overview</a>

 <ul>
 <li>Like everything in xeoEngine, all properties on a Geometry are dynamically editable.</li>
 <li>A Geometry's {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} type can be 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' or 'triangle-fan'".</li>
 <li>Depending on the {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} type, a Geometry can have {{#crossLink "Geometry/positions:property"}}vertex positions{{/crossLink}},
 {{#crossLink "Geometry/colors:property"}}vertex colors{{/crossLink}}, {{#crossLink "Geometry/uv:property"}}UV coordinates{{/crossLink}},
 {{#crossLink "Geometry/normals:property"}}normal vectors{{/crossLink}}, as well as {{#crossLink "Geometry/indices:property"}}{{/crossLink}},
 which specify how the vertices connect together to form the primitives.</li>
 <li>When no shape is specified (ie. no primitive type, vertex arrays and indices), a Geometry will default to a 2x2x2 box
 made of triangles, with UV coordinates, vertex colors and normals. This default is used for most of the examples in this documentation.</li>
 <li>A {{#crossLink "Scene"}}{{/crossLink}} provides such a box as its default {{#crossLink "Scene/geometry:property"}}{{/crossLink}},
 for {{#crossLink "Entity"}}Entities{{/crossLink}} to fall back on, when they are not explicitly attached to a Geometry.</li>
 <li>See <a href="Shader.html#inputs">Shader Inputs</a> for the variables that Geometries create within xeoEngine's shaders.</li>
 </ul>

 <img src="../../../assets/images/Geometry.png"></img>

 ## <a name="defaultShape">Default box shape</a>

 If you create a Geometry with no specified shape, it will default to a 2x2x2 box defined as a triangle mesh.

 ```` javascript
 var geometry = new XEO.Geometry(scene); // 2x2x2 box

 var entity1 = new XEO.Entity(scene, {
    geometry: geometry
});
 ````

 ## <a name="sceneDefault">Scene's default Geometry</a>

 If you create an {{#crossLink "Entity"}}Entity{{/crossLink}} with no Geometry, it will inherit its {{#crossLink "Scene"}}Scene{{/crossLink}}'s
 default {{#crossLink "Scene/geometry:property"}}{{/crossLink}}, which is also a 2x2x2 box:

 ```` javascript
 var scene = new XEO.Scene();

 var entity1 = new XEO.Entity(scene);
 ````

 ## <a name="sharing">Sharing among Entities</a>

 xeoEngine components can be shared among multiple {{#crossLink "Entity"}}Entities{{/crossLink}}. For components like
 Geometry and {{#crossLink "Texture"}}{{/crossLink}}, this can provide significant memory
 and performance savings. To render the example below, xeoEngine will issue two draw WebGL calls, one for
 each {{#crossLink "Entity"}}{{/crossLink}}, but will only need to bind the Geometry's arrays once on WebGL.

 ```` javascript
 var scene = new XEO.Scene();

 var geometry = new XEO.Geometry(scene); // 2x2x2 box by default

 // Create two Entities which share our Geometry

 var entity1 = new XEO.Entity(scene, {
    geometry: geometry
});

 // Offset the second Entity slightly on the World-space
 // X-axis using a Translate modelling transform

 var translate = new XEO.Translate(scene, {
    xyz: [5, 0, 0
});

 var entity2 = new XEO.Entity(scene, {
    geometry: geometry,
    transform: translate
});
 ````

 ## <a name="triangles">Defining a triangle mesh</a>

 Finally, we'll create an {{#crossLink "Entity"}}Entity{{/crossLink}} with a Geometry that we've **explicitly**
 configured as a 2x2x2 box:

 ```` javascript
 var scene = new XEO.Scene();

 // Create a 2x2x2 box centered at the World-space origin
 var geometry = new XEO.Geometry(scene, {

        // Supported primitives are 'points', 'lines', 'line-loop', 'line-strip', 'triangles',
        // 'triangle-strip' and 'triangle-fan'.primitive: "triangles",
        primitive: "triangles",

        // Vertex positions
        positions : [

            // Front face
            -1.0, -1.0, 1.0,
            1.0, -1.0, 1.0,
            1.0, 1.0, 1.0,
            -1.0, 1.0, 1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0, 1.0, -1.0,
             1.0, 1.0, -1.0,
            1.0, -1.0, -1.0,

            // Top face
            -1.0, 1.0, -1.0,
            -1.0, 1.0, 1.0,
            1.0, 1.0, 1.0,
            1.0, 1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
            1.0, -1.0, -1.0,
            1.0, -1.0, 1.0,
            -1.0, -1.0, 1.0,

            // Right face
            1.0, -1.0, -1.0,
            1.0, 1.0, -1.0,
            1.0, 1.0, 1.0,
            1.0, -1.0, 1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0, 1.0,
            -1.0, 1.0, 1.0,
            -1.0, 1.0, -1.0
        ],

        // Vertex colors
        colors: [
            1.0,  1.0,  1.0,  1.0,    // Front face: white
            1.0,  0.0,  0.0,  1.0,    // Back face: red
            0.0,  1.0,  0.0,  1.0,    // Top face: green
            0.0,  0.0,  1.0,  1.0,    // Bottom face: blue
            1.0,  1.0,  0.0,  1.0,    // Right face: yellow
            1.0,  0.0,  1.0,  1.0     // Left face: purple
        ],

        // Vertex normals
        normals: [
            0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
            1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
            0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
            -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0,
            0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,
            0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1
        ],

        // UV coordinates
        uv: [
            1, 1, 0, 1, 0, 0, 1, 0,
            0, 1, 0, 0, 1, 0, 1, 1,
            1, 0, 1, 1, 0, 1, 0, 0,
            1, 1, 0, 1, 0, 0, 1, 0,
            0, 0, 1, 0, 1, 1, 0, 1,
            0, 0, 1, 0, 1, 1, 0, 1
        ],

        // Triangle indices
        indices: [
            0,  1,  2,      0,  2,  3,    // front
            4,  5,  6,      4,  6,  7,    // back
            8,  9,  10,     8,  10, 11,   // top
            12, 13, 14,     12, 14, 15,   // bottom
            16, 17, 18,     16, 18, 19,   // right
            20, 21, 22,     20, 22, 23    // left
        ]
});

 var entity = new XEO.Entity(scene, {
    geometry: geometry
});
 ````
 ## <a name="editing">Editing Geometry</a>

 Recall that everything in xeoEngine is dynamically editable, including Geometry. Let's remove the front and back faces
 from our triangle mesh Geometry by updating its **indices** array:

 ````javascript
 geometry2.indices = [
 8,  9,  10,     8,  10, 11,   // top
 12, 13, 14,     12, 14, 15,   // bottom
 16, 17, 18,     16, 18, 19,   // right
 20, 21, 22,     20, 22, 23    // left
 ];
 ````

 Now let's make it wireframe by changing its primitive type from **faces** to **lines**:

 ````javascript
 geometry2.primitive = "lines";
 ````

 ## <a name="backfaces">Toggling backfaces on or off</a>

 Now we'll attach a {{#crossLink "Modes"}}{{/crossLink}} to that last {{#crossLink "Entity"}}{{/crossLink}}, so that
 we can show or hide its {{#crossLink "Geometry"}}Geometry's{{/crossLink}} backfaces:

 ```` javascript
 var modes = new XEO.Modes(scene);

 entity.modes = modes;

 // Hide backfaces

 modes.backfaces = false;

 ````

 ## <a name="frontfaces">Setting frontface vertex winding</a>

 The <a href="https://www.opengl.org/wiki/Face_Culling" target="other">vertex winding order</a> of each face determines
 whether it's a frontface or a backface.

 By default, xeoEngine considers faces to be frontfaces if they have a counter-clockwise
 winding order, but we can change that by setting the {{#crossLink "Modes"}}{{/crossLink}}
 {{#crossLink "Modes/frontface:property"}}{{/crossLink}} property, like so:

 ```` javascript
 // Set the winding order for frontfaces to clockwise
 // Options are "ccw" for counter-clockwise or "cw" for clockwise

 entity.frontface = "cw";
 ````


 @class Geometry
 @module XEO
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Geometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Geometry.
 @param [cfg.primitive="triangles"] {String} The primitive type. Accepted values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.
 @param [cfg.positions] {Array of Number} Positions array.
 @param [cfg.normals] {Array of Number} Normals array.
 @param [cfg.uv] {Array of Number} UVs array.
 @param [cfg.colors] {Array of Number} Vertex colors.
 @param [cfg.tangents] {Array of Number} Vertex tangents.
 @param [cfg.indices] {Array of Number} Indices array.
 @param [cfg.autoNormals] {Boolean} Set true to automatically generate normal vectors from positions and indices.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Geometry = XEO.Component.extend({

        type: "XEO.Geometry",

        _init: function (cfg) {

            var self = this;

            this._state = new XEO.renderer.Geometry({

                primitive: null, // WebGL enum
                primitiveName: null, // String

                // VBOs 

                positions: null,
                colors: null,
                normals: null,
                uv: null,
                tangents: null,
                indices: null,

                // Getters for VBOs that are only created on demand

                // Tangents for normal mapping

                getTangents: function () {
                    if (self._tangentsDirty) {
                        self._buildTangents();
                    }
                    return self._tangents;
                },

                // Arrays modified to support primitive-picking

                getPickPositions: function () {
                    if (self._pickVBOsDirty) {
                        self._buildPickVBOs();
                    }
                    return self._pickPositions;
                },

                getPickColors: function () {
                    if (self._pickVBOsDirty) {
                        self._buildPickVBOs();
                    }
                    return self._pickColors;
                },

                getPickIndices: function () {
                    if (self._pickVBOsDirty) {
                        self._buildPickVBOs();
                    }
                    return self._pickIndices;
                }
            });

            this._updateScheduled = false;
            this._vboUpdateScheduled = false;

            this._hashDirty = true;

            // Typed arrays

            this._positionsData = null;
            this._colorsData = null;
            this._normalsData = null;
            this._uvData = null;
            this._tangentsData = null;
            this._indicesData = null;

            // Lazy-generated VBOs

            this._tangents = null;
            this._pickPositions = null;
            this._pickColors = null;
            this._pickIndices = null;

            // Flags for work pending

            this._vboUpdateScheduled = false;
            this._positionsDirty = true;
            this._colorsDirty = true;
            this._normalsDirty = true;
            this._uvDirty = true;
            this._tangentsDirty = true;
            this._indicesDirty = true;
            this._pickVBOsDirty = true;

            // Local-space Boundary3D

            this._localBoundary = null;
            this._boundaryDirty = true;


            var defaultGeometry = (!cfg.positions && !cfg.normals && !cfg.uv && !cfg.indices);

            if (defaultGeometry) {

                this.primitive = cfg.primitive;

            } else {

                var defaultLineStripGeometry = ((!cfg.primitive || cfg.primitive === "line-strip") && cfg.positions && !cfg.indices);

                if (defaultLineStripGeometry) {

                    // Line strip when only positions are given and no primitive

                    var indices = [];
                    for (var i = 0, len = cfg.positions.length / 3; i < len; i++) {
                        indices.push(i);
                    }

                    this.primitive = "line-strip";
                    this.positions = cfg.positions;
                    this.indices = indices;

                } else {

                    // Custom geometry

                    this.primitive = cfg.primitive;
                    this.positions = cfg.positions;
                    this.colors = cfg.colors;
                    this.normals = cfg.normals;
                    this.uv = cfg.uv;
                    this.tangents = cfg.tangents;
                    this.indices = cfg.indices;
                }
            }

            this.autoNormals = cfg.autoNormals;

            this.usage = cfg.usage;

            this._webglContextRestored = this.scene.canvas.on("webglContextRestored", this._scheduleVBOUpdate, this);

            XEO.stats.memory.meshes++;
        },

        /**
         * Protected method, called by sub-classes to queue a call to _update(), to rebuild geometry data arrays.
         *
         * @protected
         */
        _scheduleUpdate: function () {
            if (!this._updateScheduled) {
                this._updateScheduled = true;
                XEO.scheduleTask(this._doUpdate, this);
            }
        },

        _doUpdate: function () {

            if (this._updateScheduled) {

                this._vboUpdateScheduled = true; // Prevents needless scheduling within _update()

                if (this._update) {
                    this._update();
                }

                this._updateScheduled = false;
            }

            if (this._vboUpdateScheduled) {
                this._doVBOUpdate();
            }
        },

        /**
         * Protected virtual template method, implemented by sub-classes to generate geometry data arrays.
         *
         * @protected
         */
        _update: null,

        _scheduleVBOUpdate: function () {

            if (!this._vboUpdateScheduled) {

                this._vboUpdateScheduled = true;

                // Build VBOs for renderer; no other components in the scene
                // will be waiting them, so OK to schedule that for next tick.
                XEO.scheduleTask(this._doVBOUpdate, this);
            }
        },

        _doVBOUpdate: function () {

            if (this._updateScheduled) {

                if (this._update) {
                    this._vboUpdateScheduled = true; // Prevents needless scheduling within _update()
                    this._update();
                }

                this._updateScheduled = false;
                this._vboUpdateScheduled = true;

            } else if (!this._vboUpdateScheduled) {
                return;
            }

            var gl = this.scene.canvas.gl;

            switch (this._state.primitiveName) {

                case "points":
                    this._state.primitive = gl.POINTS;
                    break;

                case "lines":
                    this._state.primitive = gl.LINES;
                    break;

                case "line-loop":
                    this._state.primitive = gl.LINE_LOOP;
                    break;

                case "line-strip":
                    this._state.primitive = gl.LINE_STRIP;
                    break;

                case "triangles":
                    this._state.primitive = gl.TRIANGLES;
                    break;

                case "triangle-strip":
                    this._state.primitive = gl.TRIANGLE_STRIP;
                    break;

                case "triangle-fan":
                    this._state.primitive = gl.TRIANGLE_FAN;
                    break;

                default:
                    this._state.primitive = gl.TRIANGLES;
            }

            var usage = gl.STATIC_DRAW;

            var memoryStats = XEO.stats.memory;

            if (this._positionsDirty) {
                if (this._state.positions) {
                    memoryStats.positions -= this._state.positions.numItems;
                    this._state.positions.destroy();
                }
                this._state.positions = this._positionsData ? new XEO.renderer.webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, new Float32Array(this._positionsData), this._positionsData.length, 3, usage) : null;
                if (this._state.positions) {
                    memoryStats.positions += this._state.positions.numItems;
                }
                this._positionsDirty = false;

                // Need to rebuild pick mesh now
                this._pickVBOsDirty = true;
            }

            if (this._colorsDirty) {

                if (this._state.colors) {
                    memoryStats.colors -= this._state.colors.numItems;
                    this._state.colors.destroy();
                }
                this._state.colors = this._colorsData ? new XEO.renderer.webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, new Float32Array(this._colorsData), this._colorsData.length, 4, usage) : null;
                if (this._state.colors) {
                    memoryStats.colors += this._state.colors.numItems;
                }
                this._colorsDirty = false;
            }

            if (this._normalsDirty) {
                if (this._state.normals) {
                    memoryStats.normals -= this._state.normals.numItems;
                    this._state.normals.destroy();
                }

                // Automatic normal generation

                if (this._autoNormals && this._positionsData && this._indicesData) {
                    this._normalsData = XEO.math.buildNormals(this._positionsData, this._indicesData);
                }

                this._state.normals = this._normalsData ? new XEO.renderer.webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, new Float32Array(this._normalsData), this._normalsData.length, 3, usage) : null;
                if (this._state.normals) {
                    memoryStats.normals += this._state.normals.numItems;
                }
                this._normalsDirty = false;

                // Need to rebuild tangents
                // next time the renderer gets them from the state

                this._tangentsDirty = true;
            }

            if (this._uvDirty) {
                if (this._state.uv) {
                    memoryStats.uvs -= this._state.uv.numItems;
                    this._state.uv.destroy();
                }
                this._state.uv = this._uvData ? new XEO.renderer.webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, new Float32Array(this._uvData), this._uvData.length, 2, usage) : null;
                if (this._state.uv) {
                    memoryStats.uvs += this._state.uv.numItems;
                }
                this._uvDirty = false;

                // Need to rebuild tangents
                // next time the renderer gets them from the state

                this._tangentsDirty = true;
            }

            if (this._indicesDirty) {
                if (this._state.indices) {
                    memoryStats.indices -= this._state.indices.numItems;
                    this._state.indices.destroy();
                }
                this._state.indices = this._indicesData ? new XEO.renderer.webgl.ArrayBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this._indicesData), this._indicesData.length, 1, usage) : null;
                if (this._state.indices) {
                    memoryStats.indices += this._state.indices.numItems;
                }
                this._indicesDirty = false;

                // Need to rebuild pick mesh next time the
                // renderer gets it from the state

                this._pickVBOsDirty = true;
            }

            this._vboUpdateScheduled = false;

            this._setBoundaryDirty();
        },

        _buildTangents: function () {

            if (!this._tangentsDirty) {
                return;
            }

            if (this._updateScheduled || this._vboUpdateScheduled) {
                this._doUpdate();
            }

            var memoryStats = XEO.stats.memory;

            if (this._tangents) {
                memoryStats.tangents -= this._tangents.numItems;
                this._tangents.destroy();
            }

            var gl = this.scene.canvas.gl;

            var usage = gl.STATIC_DRAW;

            this._tangents = this._tangentsData ? new XEO.renderer.webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, new Float32Array(this._tangentsData), this._tangentsData.length, 4, usage) : null;

            if (this._tangents) {
                memoryStats.tangents += this._tangents.numItems;
            }

            this._tangentsDirty = false;
        },

        _buildPickVBOs: function () {

            if (!this._pickVBOsDirty) {
                return;
            }

            if (this._updateScheduled || this._vboUpdateScheduled) {
                this._doUpdate();
            }

            this._destroyPickVBOs();

            if (this._positionsData && this._indicesData) {

                var gl = this.scene.canvas.gl;

                var usage = gl.STATIC_DRAW;

                var arrays = XEO.math.getPickPrimitives(this._positionsData, this._indicesData);

                var pickPositions = arrays.pickPositions;
                var pickColors = arrays.pickColors;
                var pickIndices = arrays.pickIndices;

                this._pickPositions = new XEO.renderer.webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, new Float32Array(pickPositions), pickPositions.length, 3, usage);
                this._pickColors = new XEO.renderer.webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, new Float32Array(pickColors), pickColors.length, 4, usage);
                this._pickIndices = new XEO.renderer.webgl.ArrayBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(pickIndices), pickIndices.length, 1, usage);

                var memoryStats = XEO.stats.memory;

                memoryStats.positions += this._pickPositions.numItems;
                memoryStats.colors += this._pickColors.numItems;
                memoryStats.indices += this._pickIndices.numItems;
            }

            this._pickVBOsDirty = false;
        },

        _destroyPickVBOs: function () {

            var memoryStats = XEO.stats.memory;

            if (this._pickPositions) {
                this._pickPositions.destroy();
                memoryStats.positions -= this._pickPositions.numItems;
                this._pickPositions = null;
            }

            if (this._pickColors) {
                this._pickColors.destroy();
                memoryStats.colors -= this._pickColors.numItems;
                this._pickColors = null;
            }

            if (this._pickIndices) {
                this._pickIndices.destroy();
                memoryStats.indices -= this._pickIndices.numItems;
                this._pickIndices = null;
            }

            this._pickVBOsDirty = true;
        },


        _props: {

            /**
             * The Geometry's usage type.
             *
             * Valid types are: 'static', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.
             *
             * Fires a {{#crossLink "Geometry/usage:event"}}{{/crossLink}} event on change.
             *
             * @property usage
             * @default "triangles"
             * @type String
             */
            usage: {

                set: function (value) {

                    value = value || "static";

                    if (value !== "static" && value !== "dynamic" && value !== "stream") {

                        this.error("Unsupported value for 'usage': '" + value +
                            "' - supported values are 'static', 'dynamic' and 'stream'.");

                        value = "static";
                    }

                    this._state.usageName = value;

                    this._scheduleVBOUpdate();

                    this.fire("dirty", true);

                    /**
                     * Fired whenever this Geometry's {{#crossLink "Geometry/usage:property"}}{{/crossLink}} property changes.
                     * @event usage
                     * @type String
                     * @param value The property's new value
                     */
                    this.fire("usage", this._state.usageName);
                },

                get: function () {
                    return this._state.usageName;
                }
            },

            /**
             * The Geometry's primitive type.
             *
             * Valid types are: 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.
             *
             * Fires a {{#crossLink "Geometry/primitive:event"}}{{/crossLink}} event on change.
             *
             * @property primitive
             * @default "triangles"
             * @type String
             */
            primitive: {

                set: function (value) {

                    value = value || "triangles";

                    if (value !== "points" &&
                        value !== "lines" &&
                        value !== "line-loop" &&
                        value !== "line-strip" &&
                        value !== "triangles" &&
                        value !== "triangle-strip" &&
                        value !== "triangle-fan") {

                        this.error("Unsupported value for 'primitive': '" + value +
                            "' - supported values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', " +
                            "'triangle-strip' and 'triangle-fan'. Defaulting to 'triangles'.");

                        value = "triangles";
                    }

                    this._state.primitiveName = value;

                    this._scheduleVBOUpdate();

                    this._hashDirty = true;

                    this.fire("dirty", true);

                    /**
                     * Fired whenever this Geometry's {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} property changes.
                     * @event primitive
                     * @type String
                     * @param value The property's new value
                     */
                    this.fire("primitive", this._state.primitiveName);
                },

                get: function () {
                    return this._state.primitiveName;
                }
            },

            /**
             * The Geometry's positions array.
             *
             * This property is a one-dimensional array - use  {{#crossLink "XEO.math/flatten:method"}}{{/crossLink}} to
             * convert two-dimensional arrays for assignment to this property.
             *
             * Fires a {{#crossLink "Geometry/positions:event"}}{{/crossLink}} event on change.
             *
             * @property positions
             * @default null
             * @type {Array of Number}
             */
            positions: {

                set: function (value) {

                    // Only recompile when adding or removing this property, not when modifying
                    var dirty = (!this._positionsData !== !value);

                    this._positionsData = value;
                    this._positionsDirty = true;

                    this._scheduleVBOUpdate();

                    if (dirty) {
                        this._hashDirty = true;
                        this.fire("dirty", true);
                    }

                    /**
                     * Fired whenever this Geometry's {{#crossLink "Geometry/positions:property"}}{{/crossLink}} property changes.
                     * @event positions
                     * @param value The property's new value
                     */
                    this.fire("positions", this._positionsData);

                    /**
                     * Fired whenever this Geometry's {{#crossLink "Geometry/localBoundary:property"}}{{/crossLink}} property changes.
                     *
                     * Note that this event does not carry the value of the property. In order to avoid needlessly
                     * calculating unused values for this property, it will be lazy-calculated next time it's referenced
                     * on this Geometry.
                     *
                     * @event positions
                     * @param value The property's new value
                     */
                    this.fire("localBoundary", true);

                    this._renderer.imageDirty = true;
                },

                get: function () {

                    if (this._updateScheduled) {
                        this._doUpdate();
                    }

                    return this._positionsData;
                }
            },

            /**
             * The Geometry's normal vectors array.
             *
             * Fires a {{#crossLink "Geometry/normals:event"}}{{/crossLink}} event on change.
             *
             * @property normals
             * @default null
             * @type {Array of Number}
             */
            normals: {

                set: function (value) {

                    // Only recompile when adding or removing this property, not when modifying
                    var dirty = (!this._normalsData !== !value);

                    this._normalsData = value;
                    this._normalsDirty = true;

                    this._scheduleVBOUpdate();

                    if (dirty) {
                        this._hashDirty = true;
                        this.fire("dirty", true);
                    }

                    /**
                     * Fired whenever this Geometry's {{#crossLink "Geometry/ normals:property"}}{{/crossLink}} property changes.
                     * @event  normals
                     * @param value The property's new value
                     */
                    this.fire(" normals", this._normalsData);

                    this._renderer.imageDirty = true;
                },

                get: function () {

                    if (this._updateScheduled) {
                        this._doUpdate();
                    }

                    return this._normalsData;
                }
            },

            /**
             * The Geometry's UV coordinate array.
             *
             * Fires a {{#crossLink "Geometry/uv:event"}}{{/crossLink}} event on change.
             *
             * @property uv
             * @default null
             * @type {Array of Number}
             */
            uv: {

                set: function (value) {

                    // Only recompile when adding or removing this property, not when modifying
                    var dirty = (!this._uvData !== !value);

                    this._uvData = value;
                    this._uvDirty = true;

                    this._scheduleVBOUpdate();

                    if (dirty) {
                        this._hashDirty = true;
                        this.fire("dirty", true);
                    }

                    /**
                     * Fired whenever this Geometry's {{#crossLink "Geometry/uv:property"}}{{/crossLink}} property changes.
                     * @event uv
                     * @param value The property's new value
                     */
                    this.fire("uv", this._uvData);

                    this._renderer.imageDirty = true;
                },

                get: function () {

                    if (this._updateScheduled) {
                        this._doUpdate();
                    }

                    return this._uvData;
                }
            },

            /**
             * The Geometry's vertex colors array.
             *
             * Fires a {{#crossLink "Geometry/colors:event"}}{{/crossLink}} event on change.
             *
             * @property colors
             * @default null
             * @type {Array of Number}
             */
            colors: {

                set: function (value) {

                    // Only recompile when adding or removing this property, not when modifying
                    var dirty = (!this._colorsData != !value);

                    this._colorsData = value;
                    this._colorsDirty = true;

                    this._scheduleVBOUpdate();

                    if (dirty) {
                        this._hashDirty = true;
                        this.fire("dirty", true);
                    }

                    /**
                     * Fired whenever this Geometry's {{#crossLink "Geometry/colors:property"}}{{/crossLink}} property changes.
                     * @event colors
                     * @param value The property's new value
                     */
                    this.fire("colors", this._colorsData);

                    this._renderer.imageDirty = true;
                },

                get: function () {

                    if (this._updateScheduled) {
                        this._doUpdate();
                    }

                    return this._colorsData;
                }
            },

            /**
             * The Geometry's indices array.
             *
             * Fires a {{#crossLink "Geometry/indices:event"}}{{/crossLink}} event on change.
             *
             * @property indices
             * @default null
             * @type {Array of Number}
             */
            indices: {

                set: function (value) {

                    // Only recompile when adding or removing this property, not when modifying
                    var dirty = (!this._indicesData && !value);

                    this._indicesData = value;
                    this._indicesDirty = true;

                    this._scheduleVBOUpdate();

                    if (dirty) {
                        this._hashDirty = true;
                        this.fire("dirty", true);
                    }

                    /**
                     * Fired whenever this Geometry's {{#crossLink "Geometry/indices:property"}}{{/crossLink}} property changes.
                     * @event indices
                     * @param value The property's new value
                     */
                    this.fire("indices", this._indicesData);

                    this._renderer.imageDirty = true;
                },

                get: function () {

                    if (this._updateScheduled) {
                        this._doUpdate();
                    }

                    return this._indicesData;
                }
            },

            /**
             * Local-space 3D boundary enclosing the {{#crossLink "Geometry/positions:property"}}{{/crossLink}} of this Geometry.
             *
             * The a {{#crossLink "Boundary3D"}}{{/crossLink}} is lazy-instantiated the first time that this
             * property is referenced. If {{#crossLink "Component/destroy:method"}}{{/crossLink}} is then called on it,
             * then this property will be assigned to a fresh {{#crossLink "Boundary3D"}}{{/crossLink}} instance next
             * time it's referenced.
             *
             * The {{#crossLink "Boundary3D"}}{{/crossLink}} will fire an {{#crossLink "Boundary3D/updated:event"}}{{/crossLink}}
             * event whenever this Geometry's {{#crossLink "Geometry/positions:property"}}{{/crossLink}} are updated.
             *
             * @property localBoundary
             * @type Boundary3D
             * @final
             */
            localBoundary: {

                get: function () {

                    if (!this._localBoundary) {

                        var self = this;

                        //this._setBoundaryDirty();

                        this._localBoundary = new XEO.Boundary3D(this.scene, {

                            // Inject callbacks through which this Geometry
                            // can manage caching for the boundary

                            getDirty: function () {
                                if (self._boundaryDirty) {
                                    self._boundaryDirty = false;
                                    return true;
                                }
                                return false;
                            },

                            getPositions: function () {

                                if (self._updateScheduled) {
                                    self._doUpdate();
                                }

                                return self._positionsData;
                            }
                        });

                        this._localBoundary.on("destroyed",
                            function () {
                                self._localBoundary = null;
                            });
                    }

                    return this._localBoundary;
                }
            },

            /**
             * Set true to make this Geometry automatically generate {{#crossLink "Geometry/normals:property"}}{{/crossLink}} from
             * {{#crossLink "Geometry/positions:property"}}{{/crossLink}} and {{#crossLink "Geometry/indices:property"}}{{/crossLink}}.
             *
             * When true, causes this Geometry to auto-generate its {{#crossLink "Geometry/normals:property"}}{{/crossLink}} on the
             * next {{#crossLink "Scene"}}{{/crossLink}} {{#crossLink "Scene/tick:event"}}{{/crossLink}} event.
             *
             * Fires an {{#crossLink "Geometry/autoNormals:event"}}{{/crossLink}} event on change.
             *
             * @property autoNormals
             * @default  false
             * @type Boolean
             */
            autoNormals: {

                set: function (value) {

                    value = !!value;

                    if (this._autoNormals === value) {
                        return;
                    }

                    this._autoNormals = value;

                    this._normalsDirty = true;

                    this._scheduleVBOUpdate();

                    /**
                     * Fired whenever this Geometry's {{#crossLink "Geometry/autoNormals:property"}}{{/crossLink}} property changes.
                     * @event autoNormals
                     * @type Boolean
                     * @param value The property's new value
                     */
                    this.fire("autoNormals", this._autoNormals);
                },

                get: function () {
                    return this._autoNormals;
                }
            }
            //,
            //
            ///**
            // * Set true to make this Geometry automatically generate {{#crossLink "Geometry/tangents:property"}}{{/crossLink}} from
            // * {{#crossLink "Geometry/uv:property"}}{{/crossLink}} and {{#crossLink "Geometry/normals:property"}}{{/crossLink}}.
            // *
            // * This Geomatry will auto-generate its {{#crossLink "Geometry/tangents:property"}}{{/crossLink}} on the
            // * next {{#crossLink "Scene"}}{{/crossLink}} {{#crossLink "Scene/tick:event"}}{{/crossLink}} event.
            // *
            // * Fires a {{#crossLink "Geometry/autoTangents:event"}}{{/crossLink}} event on change.
            // *
            // * @property autoTangents
            // * @default  false
            // * @type Boolean
            // */
            //autoTangents: {
            //
            //    set: function (value) {
            //
            //        value = !!value;
            //
            //        if (this._autoTangents === value) {
            //            return;
            //        }
            //
            //        this._autoTangents = value;
            //
            //        /**
            //         * Fired whenever this Geometry's {{#crossLink "Geometry/autoTangents:property"}}{{/crossLink}} property changes.
            //         * @event autoTangents
            //         * @type Boolean
            //         * @param value The property's new value
            //         */
            //        this.fire("autoTangents", this._primitive);
            //
            //        this._scheduleVBOUpdate();
            //    },
            //
            //    get: function () {
            //        return this._autoTangents;
            //    }
            //}

        },

        _setBoundaryDirty: function () {

            if (this._boundaryDirty) {
                return;
            }

            this._boundaryDirty = true;

            if (this._localBoundary) {
                this._localBoundary.fire("updated", true);
            }
        },

        _compile: function () {

            if (this._updateScheduled || this._vboUpdateScheduled) {
                this._doUpdate();
            }

            if (this._hashDirty) {
                this._makeHash();
                this._hashDirty = false;
            }

            this._renderer.geometry = this._state;
        },

        _makeHash: function () {

            var state = this._state;

            var hash = ["/g"];

            hash.push("/" + state.primitive + ";");

            if (state.positions) {
                hash.push("0");
            }

            if (state.colors) {
                hash.push("1");
            }

            if (state.normals) {
                hash.push("2");
            }

            if (state.uv) {
                hash.push("3");
            }

            // TODO: Tangents

            hash.push(";");

            state.hash = hash.join("");
        },

        _getJSON: function () {

            if (this._updateScheduled) {
                this._update();
            }

            return {
                primitive: this._state.primitiveName,
                positions: this._positionsData,
                normals: this._normalsData,
                uv: this._uvData,
                colors: this._colorsData,
                indices: this._indicesData
            };
        },

        _destroy: function () {

            this.scene.canvas.off(this._webglContextRestored);

            // Destroy VBOs

            if (this._state.positions) {
                this._state.positions.destroy();
            }

            if (this._state.colors) {
                this._state.colors.destroy();
            }

            if (this._state.normals) {
                this._state.normals.destroy();
            }

            if (this._state.uv) {
                this._state.uv.destroy();
            }

            if (this._state.indices) {
                this._state.indices.destroy();
            }

            // Destroy lazy-generated VBOs

            if (this._tangentsData) {
                this._tangentsData.destroy();
            }

            if (this._pickPositions) {
                this._pickPositions.destroy();
            }

            if (this._pickColors) {
                this._pickColors.destroy();
            }

            if (this._pickIndices) {
                this._pickIndices.destroy();
            }

            // Destroy boundary

            if (this._localBoundary) {
                this._localBoundary.destroy();
            }

            // Destroy state

            this._state.destroy();

            // Decrement geometry statistic

            XEO.stats.memory.meshes--;
        }
    });
})();
;/**
 A **BoxGeometry** defines box-shaped geometry for attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Example

 ````javascript

 ````

 @class BoxGeometry
 @module XEO
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this BoxGeometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this BoxGeometry.
 @param [cfg.primitive="triangles"] {String} The primitive type. Accepted values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.
 @param [cfg.xSize=1.0] {Number}
 @param [cfg.ySize=1.0] {Number}
 @param [cfg.zSize=1.0] {Number}
 @extends Geometry
 */
(function () {

    "use strict";

    XEO.BoxGeometry = XEO.Geometry.extend({

        type: "XEO.BoxGeometry",

        _init: function (cfg) {

            this._super(cfg);

            this.xSize = cfg.xSize;
            this.ySize = cfg.ySize;
            this.zSize = cfg.zSize;
        },

        /**
         * Implement protected virtual template method {{#crossLink "Geometry/method:_update"}}{{/crossLink}},
         * to generate geometry data arrays.
         *
         * @protected
         */
        _update: function () {

            var xmin = -this._xSize;
            var ymin = -this._ySize;
            var zmin = -this._zSize;
            var xmax = this._xSize;
            var ymax = this._ySize;
            var zmax = this._zSize;

            // The vertices - eight for our cube, each
            // one spanning three array elements for X,Y and Z
            this.positions = [

                // v0-v1-v2-v3 front
                xmax, ymax, zmax,
                xmin, ymax, zmax,
                xmin, ymin, zmax,
                xmax, ymin, zmax,

                // v0-v3-v4-v1 right
                xmax, ymax, zmax,
                xmax, ymin, zmax,
                xmax, ymin, zmin,
                xmax, ymax, zmin,

                // v0-v1-v6-v1 top
                xmax, ymax, zmax,
                xmax, ymax, zmin,
                xmin, ymax, zmin,
                xmin, ymax, zmax,

                // v1-v6-v7-v2 left
                xmin, ymax, zmax,
                xmin, ymax, zmin,
                xmin, ymin, zmin,
                xmin, ymin, zmax,

                // v7-v4-v3-v2 bottom
                xmin, ymin, zmin,
                xmax, ymin, zmin,
                xmax, ymin, zmax,
                xmin, ymin, zmax,

                // v4-v7-v6-v1 back
                xmax, ymin, zmin,
                xmin, ymin, zmin,
                xmin, ymax, zmin,
                xmax, ymax, zmin
            ];

            // Normal vectors, one for each vertex
            this.normals = [

                // v0-v1-v2-v3 front
                0, 0, 1,
                0, 0, 1,
                0, 0, 1,
                0, 0, 1,

                // v0-v3-v4-v5 right
                1, 0, 0,
                1, 0, 0,
                1, 0, 0,
                1, 0, 0,

                // v0-v5-v6-v1 top
                0, 1, 0,
                0, 1, 0,
                0, 1, 0,
                0, 1, 0,

                // v1-v6-v7-v2 left
                -1, 0, 0,
                -1, 0, 0,
                -1, 0, 0,
                -1, 0, 0,

                // v7-v4-v3-v2 bottom
                0, -1, 0,
                0, -1, 0,
                0, -1, 0,
                0, -1, 0,

                // v4-v7-v6-v5 back
                0, 0, -1,
                0, 0, -1,
                0, 0, -1,
                0, 0, -1
            ];

            // UV coords
            this.uv = [

                // v0-v1-v2-v3 front
                1, 1,
                0, 1,
                0, 0,
                1, 0,

                // v0-v3-v4-v1 right
                0, 1,
                0, 0,
                1, 0,
                1, 1,

                // v0-v1-v6-v1 top
                1, 0,
                1, 1,
                0, 1,
                0, 0,

                // v1-v6-v7-v2 left
                1, 1,
                0, 1,
                0, 0,
                1, 0,

                // v7-v4-v3-v2 bottom
                0, 0,
                1, 0,
                1, 1,
                0, 1,

                // v4-v7-v6-v1 back
                0, 0,
                1, 0,
                1, 1,
                0, 1
            ];

            // Indices - these organise the
            // positions and uv texture coordinates
            // into geometric primitives in accordance
            // with the "primitive" parameter,
            // in this case a set of three indices
            // for each triangle.
            //
            // Note that each triangle is specified
            // in counter-clockwise winding order.
            //
            // You can specify them in clockwise
            // order if you configure the Modes
            // node's frontFace flag as "cw", instead of
            // the default "ccw".
            this.indices = [
                0, 1, 2,
                0, 2, 3,
                // front
                4, 5, 6,
                4, 6, 7,
                // right
                8, 9, 10,
                8, 10, 11,
                // top
                12, 13, 14,
                12, 14, 15,
                // left
                16, 17, 18,
                16, 18, 19,
                // bottom
                20, 21, 22,
                20, 22, 23
            ];

            // Tangents are lazy-computed from normals and UVs
            // for Normal mapping once we know we have texture

            this.tangents = null;
        },

        _props: {

            /**
             * The BoxGeometry's size on the X-axis.
             *
             * Fires a {{#crossLink "BoxGeometry/xsize:event"}}{{/crossLink}} event on change.
             *
             * @property xSize
             * @default 1
             * @type Number
             */
            xSize: {

                set: function (value) {

                    value = value || 1;

                    if (this._xSize === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative xSize not allowed - will invert");
                        value = value * -1;
                    }

                    this._xSize = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this BoxGeometry's {{#crossLink "BoxGeometry/xSize:property"}}{{/crossLink}} property changes.
                     * @event xSize
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("xSize", this._xSize);
                },

                get: function () {
                    return this._xSize;
                }
            },

            /**
             * The BoxGeometry's size on the Y-axis.
             *
             * Fires a {{#crossLink "BoxGeometry/ySize:event"}}{{/crossLink}} event on change.
             *
             * @property ySize
             * @default 1
             * @type Number
             */
            ySize: {

                set: function (value) {

                    value = value || 1;

                    if (this._ySize === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative ySize not allowed - will invert");
                        value = value * -1;
                    }

                    this._ySize = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this BoxGeometry's {{#crossLink "BoxGeometry/ySize:property"}}{{/crossLink}} property changes.
                     * @event ySize
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("ySize", this._ySize);
                },

                get: function () {
                    return this._ySize;
                }
            },

            /**
             * The BoxGeometry's size on the Z-axis.
             *
             * Fires a {{#crossLink "BoxGeometry/zSize:event"}}{{/crossLink}} event on change.
             *
             * @property zSize
             * @default 1
             * @type Number
             */
            zSize: {

                set: function (value) {

                    value = value || 1;

                    if (this._zSize === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative zSize not allowed - will invert");
                        value = value * -1;
                    }

                    this._zSize = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this BoxGeometry's {{#crossLink "BoxGeometry/zSize:property"}}{{/crossLink}} property changes.
                     * @event zSize
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("zSize", this._zSize);
                },

                get: function () {
                    return this._zSize;
                }
            }
        },

        _getJSON: function () {
            return {
                xSize: this._xSize,
                ySize: this._ySize,
                zSize: this._zSize
            };
        }
    });

})();
;/**
 A **BoundaryGeometry** is a {{#crossLink "Geometry"}}{{/crossLink}} that shows the entity-aligned wireframe bounding box (OBB)
 of a {{#crossLink "Boundary3D"}}{{/crossLink}}.

 ## Example

 ````javascript

 ````

 @class BoundaryGeometry
 @module XEO
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this BoundaryGeometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this BoundaryGeometry.
 @param [cfg.boundary] {Boundary3D} ID or instance of a {{#crossLink "Boundary3D"}}{{/crossLink}}
 @extends Component
 */
(function () {

    "use strict";

    XEO.BoundaryGeometry = XEO.Geometry.extend({

        type: "XEO.BoundaryGeometry",

        _init: function (cfg) {

            this._super(cfg);

            this.primitive = cfg.primitive || "lines";

            this.indices = [
                0, 1, 1, 2, 2, 3, 3, 0, 4,
                5, 5, 6, 6, 7, 7, 4, 0, 4,
                1, 5, 2, 6, 3, 7
            ];

            if (cfg.boundary) {
                this.boundary = cfg.boundary;

            } else if (cfg.obb) {
                this.obb = cfg.obb;

            } else if (cfg.aabb) {
                this.aabb = cfg.aabb;

            } else if (cfg.positions) {
                this.positions = cfg.positions;

            } else {
                this.positions = [
                    1.0, 1.0, 1.0,
                    1.0, -1.0, 1.0,
                    -1.0, -1.0, 1.0,
                    -1.0, 1.0, 1.0,
                    1.0, 1.0, -1.0,
                    1.0, -1.0, -1.0,
                    -1.0, -1.0, -1.0,
                    -1.0, 1.0, -1.0
                ];
            }
        },

        _props: {

            /**
             * The {{#crossLink "Boundary3D"}}{{/crossLink}} we are showing.
             *
             * Fires a {{#crossLink "BoundaryGeometry/boundary:event"}}{{/crossLink}} event on change.
             *
             * @property Boundary3D
             * @type Boundary3D
             */
            boundary: {

                set: function (value) {

                    // Unsubscribe from old boundary's events

                    var oldBoundary = this._children.boundary;

                    if (oldBoundary) {

                        if ((!value || (value.id !== undefined ? value.id : value) !== oldBoundary.id)) {
                            oldBoundary.off(this._onBoundaryUpdated);
                            oldBoundary.off(this._onBoundaryDestroyed);
                        }
                    }

                    /**
                     * Fired whenever this BoundaryGeometry's  {{#crossLink "BoundaryGeometry/boundary:property"}}{{/crossLink}} property changes.
                     *
                     * @event boundary
                     * @param value The property's new value
                     */
                    this._setChild("boundary", value);

                    var boundary = this._children.boundary;

                    if (boundary) {

                        var self = this;
                        var geometryDirty = false;

                        // Whenever the new boundary fires a change event,
                        // schedule a geometry rebuild for the next 'tick'.

                        this._onBoundaryUpdated = boundary.on("updated",
                            function () {
                                if (geometryDirty) {
                                    return;
                                }
                                geometryDirty = true;
                                XEO.scheduleTask(function () {
                                    self._setPositionsFromOBB(boundary.obb);
                                    geometryDirty = false;
                                });
                            });

                        this._onBoundaryDestroyed = boundary.on("destroyed",
                            function () {
                                self.boundary = null; // Unsubscribes from old boundary's events
                            });

                        this._setPositionsFromOBB(boundary.obb);
                    }
                },

                get: function () {
                    return this._children.boundary;
                }
            },

            /**
             * The {{#crossLink "Boundary3D"}}{{/crossLink}} we are showing.
             *
             * Fires a {{#crossLink "BoundaryGeometry/boundary:event"}}{{/crossLink}} event on change.
             *
             * @property Boundary3D
             * @type Boundary3D
             */
            obb: {

                set: function (value) {

                    if (!value) {
                        return;
                    }

                    if (this._children.boundary) {
                        this.boundary = null;
                    }

                    this._setPositionsFromOBB(value);
                }
            },

            /**
             * Assign to an Axis-aligned bounding-box
             *
             * @property aabb
             * @type Boundary3D
             */
            aabb: {

                set: function (value) {

                    if (!value) {
                        return;
                    }

                    if (this._children.boundary) {
                        this.boundary = null;
                    }

                    this._setPositionsFromAABB(value);
                }
            }
        },

        _setPositionsFromOBB: function (obb) {
            this.positions = [
                obb[0][0], obb[0][1], obb[0][2],
                obb[1][0], obb[1][1], obb[1][2],
                obb[2][0], obb[2][1], obb[2][2],
                obb[3][0], obb[3][1], obb[3][2],
                obb[4][0], obb[4][1], obb[4][2],
                obb[5][0], obb[5][1], obb[5][2],
                obb[6][0], obb[6][1], obb[6][2],
                obb[7][0], obb[7][1], obb[7][2]
            ];
        },

        _setPositionsFromAABB: function (aabb) {
            this.positions = [
                aabb.max[0], aabb.max[1], aabb.max[2],
                aabb.max[0], aabb.min[1], aabb.max[2],
                aabb.min[0], aabb.min[1], aabb.max[2],
                aabb.min[0], aabb.max[1], aabb.max[2],
                aabb.max[0], aabb.max[1], aabb.min[2],
                aabb.max[0], aabb.min[1], aabb.min[2],
                aabb.min[0], aabb.min[1], aabb.min[2],
                aabb.min[0], aabb.max[1], aabb.min[2]
            ];
        },

        _getJSON: function () {

            var json = {};

            if (this._children.boundary) {
                json.boundary = this._children.boundary.id;

            } else if (json.positions) {
                json.positions = this.positions;
            }

            return json;
        },

        _destroy: function () {

            if (this._children.boundary) {
                this._children.boundary.off(this._onBoundaryUpdated);
                this._children.boundary.off(this._onBoundaryDestroyed);
            }

            this._super();
        }
    });
})();
;/**
 A **TorusGeometry** defines torus-shaped geometry for attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Example

 ````javascript

 ````

 @class TorusGeometry
 @module XEO
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this TorusGeometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this TorusGeometry.
 @param [cfg.primitive="triangles"] {String} The primitive type. Accepted values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.
 @param [cfg.radius=1] {Number} The overall radius of the TorusGeometry.
 @param [cfg.tube=0.3] {Number} The tube radius of the TorusGeometry.
 @param [cfg.radialSegments=32] {Number} The number of radial segments that make up the TorusGeometry.
 @param [cfg.tubeSegments=24] {Number} The number of tubular segments that make up the TorusGeometry.
 @param [cfg.arc=Math.PI / 2.0] {Number} The length of the TorusGeometry's arc in degrees, where 360 is closed torus.
 @param [cfg.lod=1] {Number} Level-of-detail, in range [0..1].
 @extends Geometry
 */
(function () {

    "use strict";

    XEO.TorusGeometry = XEO.Geometry.extend({

        type: "XEO.TorusGeometry",

        _init: function (cfg) {

            this._super(cfg);

            this.lod = cfg.lod;
            this.radius = cfg.radius;
            this.tube = cfg.tube;
            this.radialSegments = cfg.radialSegments;
            this.tubeSegments = cfg.tubeSegments;
            this.arc = cfg.arc;
        },

        /**
         * Implement protected virtual template method {{#crossLink "Geometry/method:_update"}}{{/crossLink}},
         * to generate geometry data arrays.
         *
         * @protected
         */
        _update: function () {

            var radius = this._radius;
            var tube = this._tube;
            var radialSegments = Math.floor(this._radialSegments * this._lod);
            var tubeSegments = Math.floor(this._tubeSegments * this._lod);
            var arc = this._arc;

            if (radialSegments < 4) {
                radialSegments = 4;
            }

            if (tubeSegments < 4) {
                tubeSegments = 4;
            }

            var positions = [];
            var normals = [];
            var uvs = [];
            var indices = [];

            var u;
            var v;
            var centerX;
            var centerY;
            var centerZ = 0;
            var x;
            var y;
            var z;
            var vec;

            var i;
            var j;

            for (j = 0; j <= radialSegments; j++) {
                for (i = 0; i <= tubeSegments; i++) {

                    u = i / tubeSegments * arc;
                    v = j / radialSegments * Math.PI * 2;

                    centerX = radius * Math.cos(u);
                    centerY = radius * Math.sin(u);

                    x = (radius + tube * Math.cos(v) ) * Math.cos(u);
                    y = (radius + tube * Math.cos(v) ) * Math.sin(u);
                    z = tube * Math.sin(v);

                    positions.push(x);
                    positions.push(y);
                    positions.push(z);

                    uvs.push(1 - (i / tubeSegments));
                    uvs.push(1 - (j / radialSegments));

                    vec = XEO.math.normalizeVec3(XEO.math.subVec3([x, y, z], [centerX, centerY, centerZ], []), []);

                    normals.push(vec[0]);
                    normals.push(vec[1]);
                    normals.push(vec[2]);
                }
            }

            var a;
            var b;
            var c;
            var d;

            for (j = 1; j <= radialSegments; j++) {
                for (i = 1; i <= tubeSegments; i++) {

                    a = ( tubeSegments + 1 ) * j + i - 1;
                    b = ( tubeSegments + 1 ) * ( j - 1 ) + i - 1;
                    c = ( tubeSegments + 1 ) * ( j - 1 ) + i;
                    d = ( tubeSegments + 1 ) * j + i;

                    indices.push(a);
                    indices.push(b);
                    indices.push(c);

                    indices.push(c);
                    indices.push(d);
                    indices.push(a);
                }
            }

            this.positions = positions;
            this.normals = normals;
            this.uv = uvs;
            this.indices = indices;
        },

        _props: {

            /**
             * The TorusGeometry's level-of-detail factor.
             *
             * Fires a {{#crossLink "TorusGeometry/lod:event"}}{{/crossLink}} event on change.
             *
             * @property lod
             * @default 1
             * @type Number
             */
            lod: {

                set: function (value) {

                    value = value !== undefined ? value : 1;

                    if (this._lod === value) {
                        return;
                    }

                    if (value < 0 || value > 1) {
                        this.warn("clamping lod to [0..1]");
                        value = value < 0 ? 0 : 1;
                    }

                    this._lod = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this TorusGeometry's {{#crossLink "TorusGeometry/lod:property"}}{{/crossLink}} property changes.
                     * @event lod
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("lod", this._lod);
                },

                get: function () {
                    return this._lod;
                }
            },

            /**
             * The overall radius of the TorusGeometry.
             *
             * Fires a {{#crossLink "TorusGeometry/radius:event"}}{{/crossLink}} event on change.
             *
             * @property radius
             * @default 1
             * @type Number
             */
            radius: {

                set: function (value) {

                    value = value || 1;

                    if (this._radius === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative radius not allowed - will invert");
                        value = value * -1;
                    }

                    this._radius = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this TorusGeometry's {{#crossLink "TorusGeometry/radius:property"}}{{/crossLink}} property changes.
                     * @event radius
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("radius", this._radius);
                },

                get: function () {
                    return this._radius;
                }
            },


            /**
             * The tube radius of the TorusGeometry.
             *
             * Fires a {{#crossLink "TorusGeometry/tube:event"}}{{/crossLink}} event on change.
             *
             * @property tube
             * @default 0.3
             * @type Number
             */
            tube: {

                set: function (value) {

                    value = value || 0.3;

                    if (this._tube === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative tube not allowed - will invert");
                        value = value * -1;
                    }

                    this._tube = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this TorusGeometry's {{#crossLink "TorusGeometry/tube:property"}}{{/crossLink}} property changes.
                     * @event tube
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("tube", this._tube);
                },

                get: function () {
                    return this._tube;
                }
            },

            /**
             * The number of radial segments that make up the TorusGeometry.
             *
             * Fires a {{#crossLink "TorusGeometry/radialSegments:event"}}{{/crossLink}} event on change.
             *
             * @property radialSegments
             * @default 32
             * @type Number
             */
            radialSegments: {

                set: function (value) {

                    value = value || 32;

                    if (this._radialSegments === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative radialSegments not allowed - will invert");
                        value = value * -1;
                    }

                    this._radialSegments = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this TorusGeometry's {{#crossLink "TorusGeometry/radialSegments:property"}}{{/crossLink}} property changes.
                     * @event radialSegments
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("radialSegments", this._radialSegments);
                },

                get: function () {
                    return this._radialSegments;
                }
            },


            /**
             * The number of tubular segments that make up the TorusGeometry.
             *
             * Fires a {{#crossLink "TorusGeometry/tubeSegments:event"}}{{/crossLink}} event on change.
             *
             * @property tubeSegments
             * @default 24
             * @type Number
             */
            tubeSegments: {

                set: function (value) {

                    value = value || 24;

                    if (this._tubeSegments === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative tubeSegments not allowed - will invert");
                        value = value * -1;
                    }

                    this._tubeSegments = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this TorusGeometry's {{#crossLink "TorusGeometry/tubeSegments:property"}}{{/crossLink}} property changes.
                     * @event tubeSegments
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("tubeSegments", this._tubeSegments);
                },

                get: function () {
                    return this._tubeSegments;
                }
            },

            /**
             * The length of the TorusGeometry's arc in degrees, where 360 is closed torus.
             *
             * Fires a {{#crossLink "TorusGeometry/arc:event"}}{{/crossLink}} event on change.
             *
             * @property arc
             * @default Math.PI * 2
             * @type Number
             */
            arc: {

                set: function (value) {

                    value = value || Math.PI * 2;

                    if (this._arc === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative arc not allowed - will invert");
                        value = value * -1;
                    }

                    this._arc = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this TorusGeometry's {{#crossLink "TorusGeometry/arc:property"}}{{/crossLink}} property changes.
                     * @event arc
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("arc", this._arc);
                },

                get: function () {
                    return this._arc;
                }
            }
        },

        _getJSON: function () {
            return {
                // Don't save lod
                radius: this._radius,
                tube: this._tube,
                radialSegments: this._radialSegments,
                tubeSegments: this._tubeSegments,
                arc: this._arc
            };
        }
    });

})();
;/**
 A **SphereGeometry** defines spherical geometry for attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Example

 ````javascript

 ````

 @class SphereGeometry
 @module XEO
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this SphereGeometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this SphereGeometry.
 @param [cfg.primitive="triangles"] {String} The primitive type. Accepted values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.
 @param [cfg.radius=1] {Number}
 @param [cfg.heightSegments=24] {Number}
 @param [cfg.widthSegments=18] {Number}
 @param [cfg.lod=1] {Number} Level-of-detail, in range [0..1].
 @extends Geometry
 */
(function () {

    "use strict";

    XEO.SphereGeometry = XEO.Geometry.extend({

        type: "XEO.SphereGeometry",

        _init: function (cfg) {

            this._super(cfg);

            this.lod = cfg.lod;
            this.radius = cfg.radius;
            this.heightSegments = cfg.heightSegments;
            this.widthSegments = cfg.widthSegments;
        },

        /**
         * Implement protected virtual template method {{#crossLink "Geometry/method:_update"}}{{/crossLink}},
         * to generate geometry data arrays.
         *
         * @protected
         */
        _update: function () {

            var radius = this._radius;
            var heightSegments = Math.floor(this._lod * this._heightSegments);
            var widthSegments = Math.floor(this._lod * this._widthSegments);

            if (heightSegments < 18) {
                heightSegments = 18;
            }

            if (widthSegments < 18) {
                widthSegments = 18;
            }

            var positions = [];
            var normals = [];
            var uvs = [];
            var indices = [];

            var i;
            var j;

            var theta;
            var sinTheta;
            var cosTheta;

            var phi;
            var sinPhi;
            var cosPhi;

            var x;
            var y;
            var z;

            var u;
            var v;

            var first;
            var second;

            for (i = 0; i <= heightSegments; i++) {

                theta = i * Math.PI / heightSegments;
                sinTheta = Math.sin(theta);
                cosTheta = Math.cos(theta);

                for (j = 0; j <= widthSegments; j++) {

                    phi = j * 2 * Math.PI / widthSegments;
                    sinPhi = Math.sin(phi);
                    cosPhi = Math.cos(phi);

                    x = cosPhi * sinTheta;
                    y = cosTheta;
                    z = sinPhi * sinTheta;
                    u = 1.0 - j / widthSegments;
                    v = 1.0 - i / heightSegments;

                    normals.push(x);
                    normals.push(y);
                    normals.push(z);

                    uvs.push(u);
                    uvs.push(v);

                    positions.push(radius * x);
                    positions.push(radius * y);
                    positions.push(radius * z);
                }
            }

            for (i = 0; i < heightSegments; i++) {
                for (j = 0; j < widthSegments; j++) {

                    first = (i * (widthSegments + 1)) + j;
                    second = first + widthSegments + 1;

                    indices.push(first + 1);
                    indices.push(second + 1);
                    indices.push(second);
                    indices.push(first + 1);
                    indices.push(second);
                    indices.push(first);
                }
            }

            this.positions = positions;
            this.normals = normals;
            this.uv = uvs;
            this.indices = indices;
        },

        _props: {

            /**
             * The SphereGeometry's level-of-detail factor.
             *
             * Fires a {{#crossLink "SphereGeometry/lod:event"}}{{/crossLink}} event on change.
             *
             * @property lod
             * @default 1
             * @type Number
             */
            lod: {

                set: function (value) {

                    value = value !== undefined ? value : 1;

                    if (this._lod === value) {
                        return;
                    }

                    if (value < 0 || value > 1) {
                        this.warn("clamping lod to [0..1]");
                        value = value < 0 ? 0 : 1;
                    }

                    this._lod = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this SphereGeometry's {{#crossLink "SphereGeometry/lod:property"}}{{/crossLink}} property changes.
                     * @event lod
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("lod", this._lod);
                },

                get: function () {
                    return this._lod;
                }
            },

            /**
             * The SphereGeometry's radius.
             *
             * Fires a {{#crossLink "SphereGeometry/radius:event"}}{{/crossLink}} event on change.
             *
             * @property radius
             * @default 1
             * @type Number
             */
            radius: {

                set: function (value) {

                    value = value || 1;

                    if (this._radius === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative radius not allowed - will invert");
                        value = value * -1;
                    }

                    this._radius = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this SphereGeometry's {{#crossLink "SphereGeometry/radius:property"}}{{/crossLink}} property changes.
                     * @event radius
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("radius", this._radius);
                },

                get: function () {
                    return this._radius;
                }
            },


            /**
             * The SphereGeometry's number of latitude bands.
             *
             * Fires a {{#crossLink "SphereGeometry/heightSegments:event"}}{{/crossLink}} event on change.
             *
             * @property heightSegments
             * @default 18
             * @type Number
             */
            heightSegments: {

                set: function (value) {

                    value = value || 18;

                    if (this._heightSegments === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative heightSegments not allowed - will invert");
                        value = value * -1;
                    }

                    this._heightSegments = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this SphereGeometry's {{#crossLink "SphereGeometry/heightSegments:property"}}{{/crossLink}} property changes.
                     * @event heightSegments
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("heightSegments", this._heightSegments);
                },

                get: function () {
                    return this._heightSegments;
                }
            },

            /**
             * The SphereGeometry's number of longitude bands.
             *
             * Fires a {{#crossLink "SphereGeometry/widthSegments:event"}}{{/crossLink}} event on change.
             *
             * @property widthSegments
             * @default 24
             * @type Number
             */
            widthSegments: {

                set: function (value) {

                    value = value || 24;

                    if (this._widthSegments === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative widthSegments not allowed - will invert");
                        value = value * -1;
                    }

                    this._widthSegments = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this SphereGeometry's {{#crossLink "SphereGeometry/widthSegments:property"}}{{/crossLink}} property changes.
                     * @event widthSegments
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("widthSegments", this._widthSegments);
                },

                get: function () {
                    return this._widthSegments;
                }
            }
        },

        _getJSON: function () {
            return {
                // Don't save lod
                radius: this._radius,
                heightSegments: this._heightSegments,
                widthSegments: this._widthSegments
            };
        }
    });

})();
;/**
 A path geometry.

 @class PathGeometry
 @module geometry
 @extends Geometry
 */
XEO.PathGeometry = XEO.Geometry.extend({

    type: "XEO.PathGeometry",

    // Constructor

    _init: function (cfg) {

        this._super(cfg);

        this.path = cfg.path;
        this.divisions = cfg.divisions;
    },

    /**
     * Implement protected virtual template method {{#crossLink "Geometry/method:_update"}}{{/crossLink}},
     * to generate geometry data arrays.
     *
     * @protected
     */
    _update: function () {

        var path = this._children.path;

        if (!path) {
            return;
        }

        var points = path.getPoints(this._divisions);

        var positions = [];
        var point;

        for (var i = 0, len = points.length; i < len; i++) {

            point = points[i];

            positions.push(point[0]);
            positions.push(point[1]);
            positions.push(point[2]);
        }

        var indices = [];

        for (var i = 0, len = points.length - 1; i < len; i++) {
            indices.push(i);
            indices.push(i + 1);
        }

        this.primitive = "lines";
        this.positions = positions;
        this.indices = indices;
        this.normals = null;
        this.uv = null;
    },

    _props: {

        /**
         * The Path for this PathGeometry.
         *
         * Fires a {{#crossLink "PathGeometry/path:event"}}{{/crossLink}} event on change.
         *
         * @property path
         * @type {Path}
         */
        path: {

            set: function (value) {

                // Unsubscribe from old Curves's events

                var oldPath = this._children.path;

                if (oldPath && (!value || (value.id !== undefined ? value.id : value) !== oldPath.id)) {
                    oldPath.off(this._onPathCurves);
                }

                /**
                 * Fired whenever this CameraPaths's {{#crossLink "CameraPath/path:property"}}{{/crossLink}} property changes.
                 * @event path
                 * @param value The property's new value
                 */
                this._setChild("path", value);

                var newPath = this._children.path;

                if (newPath) {

                    // Subscribe to new Path's curves

                    var self = this;

                    this._onPathCurves = newPath.on("curves",
                        function () {
                            self._scheduleUpdate();
                        });
                }
            },

            get: function () {
                return this._children.path;
            }
        },

        /**
         * The number of segments in this PathGeometry.
         *
         * Fires a {{#crossLink "PathGeometry/divisions:event"}}{{/crossLink}} event on change.
         *
         * @property divisions
         * @default 6
         * @type {Number}
         */
        divisions: {

            set: function (value) {

                value = value || 6;

                this._divisions = value;

                this._scheduleUpdate();

                this.fire("divisions", this._divisions);
            },

            get: function () {
                return this._divisions;
            }
        }
    },

    _getJSON: function () {

        var json = {
            divisions: this._divisions
        };

        if (this._children.path) {
            json.path = this._children.path.id;
        }

        return json;
    },

    _destroy: function () {

        if (this._children.path) {
            this._children.path.off(this._onPathCurves);
        }

        this._super();
    }
});;/**
 A **Cylinder** defines cylindrical geometry for attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Example

 ````javascript

 ````

 @class CylinderGeometry
 @module XEO
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this CylinderGeometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this CylinderGeometry.
 @param [cfg.primitive="triangles"] {String} The primitive type. Accepted values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.
 @param [cfg.radiusTop=1] {Number} Radius of top.
 @param [cfg.radiusBottom=1] {Number} Radius of bottom.
 @param [cfg.height=1] {Number} Height.
 @param [cfg.radialSegments=60] {Number} Number of segments around the CylinderGeometry.
 @param [cfg.heightSegments=1] {Number} Number of vertical segments.
 @param [cfg.openEnded=false] {Boolean} Whether or not the CylinderGeometry has solid caps on the ends.
 @param [cfg.lod=1] {Number} Level-of-detail, in range [0..1].
 @extends Geometry
 */
(function () {

    "use strict";

    XEO.CylinderGeometry = XEO.Geometry.extend({

        type: "XEO.CylinderGeometry",

        _init: function (cfg) {

            this._super(cfg);

            this.lod = cfg.lod;
            this.radiusTop = cfg.radiusTop;
            this.radiusBottom = cfg.radiusBottom;
            this.height = cfg.height;
            this.radialSegments = cfg.radialSegments;
            this.heightSegments = cfg.heightSegments;
            this.openEnded = cfg.openEnded;
        },

        /**
         * Implement protected virtual template method {{#crossLink "Geometry/method:_update"}}{{/crossLink}},
         * to generate geometry data arrays.
         *
         * @protected
         */
        _update: function () {

            var radiusTop = this._radiusTop;
            var radiusBottom = this._radiusBottom;
            var height = this._height;
            var radialSegments = Math.floor(this._radialSegments * this._lod);
            var heightSegments = Math.floor(this._heightSegments * this._lod);

            if (radialSegments < 3) {
                radialSegments = 3;
            }

            if (heightSegments < 1) {
                heightSegments = 1;
            }

            var openEnded = this._openEnded;

            var heightHalf = height / 2;
            var heightLength = height / heightSegments;
            var radialAngle = (2.0 * Math.PI / radialSegments);
            var radialLength = 1.0 / radialSegments;
            var nextRadius = this._radiusBottom;
            var radiusChange = (radiusTop - radiusBottom) / heightSegments;

            var positions = [];
            var normals = [];
            var uvs = [];
            var indices = [];

            var h;
            var i;

            var x;
            var z;

            var currentRadius;
            var currentHeight;

            var center;
            var first;
            var second;

            var startIndex;
            var tu;
            var tv;

            // create vertices
            var normalY = (90.0 - (Math.atan(height / (radiusBottom - radiusTop))) * 180 / Math.PI) / 90.0;

            for (h = 0; h <= heightSegments; h++) {
                currentRadius = radiusTop - h * radiusChange;
                currentHeight = heightHalf - h * heightLength;

                for (i = 0; i <= radialSegments; i++) {
                    x = Math.sin(i * radialAngle);
                    z = Math.cos(i * radialAngle);

                    normals.push(currentRadius * x);
                    normals.push(normalY); //todo
                    normals.push(currentRadius * z);
                    uvs.push( (i * radialLength));
                    uvs.push(1-  h * 1 / heightSegments);
                    positions.push(currentRadius * x);
                    positions.push(currentHeight);
                    positions.push(currentRadius * z);
                }
            }

            // create faces
            for (h = 0; h < heightSegments; h++) {
                for (i = 0; i <= radialSegments; i++) {
                    first = h * (radialSegments + 1) + i;
                    second = first + radialSegments;
                    indices.push(first);
                    indices.push(second);
                    indices.push(second + 1);

                    indices.push(first);
                    indices.push(second + 1);
                    indices.push(first + 1);
                }
            }

            // create top cap
            if (!openEnded && radiusTop > 0) {
                startIndex = (positions.length / 3);

                // top center
                normals.push(0.0);
                normals.push(1.0);
                normals.push(0.0);
                uvs.push(0.5);
                uvs.push(0.5);
                positions.push(0);
                positions.push(heightHalf);
                positions.push(0);

                // top triangle fan
                for (i = 0; i <= radialSegments; i++) {
                    x = Math.sin(i * radialAngle);
                    z = Math.cos(i * radialAngle);
                    tu = (0.5 * Math.sin(i * radialAngle)) + 0.5;
                    tv = (0.5 * Math.cos(i * radialAngle)) + 0.5;

                    normals.push(radiusTop * x);
                    normals.push(1.0);
                    normals.push(radiusTop * z);
                    uvs.push(tu);
                    uvs.push(tv);
                    positions.push(radiusTop * x);
                    positions.push(heightHalf);
                    positions.push(radiusTop * z);
                }

                for (i = 0; i < radialSegments; i++) {
                    center = startIndex;
                    first = startIndex + 1 + i;
                    indices.push(first);
                    indices.push(first + 1);
                    indices.push(center);
                }
            }

            // create bottom cap
            if (!openEnded && radiusBottom > 0) {
                startIndex = (positions.length / 3);

                // top center
                normals.push(0.0);
                normals.push(-1.0);
                normals.push(0.0);
                uvs.push(0.5);
                uvs.push(0.5);
                positions.push(0);
                positions.push(0 - heightHalf);
                positions.push(0);

                // top triangle fan
                for (i = 0; i <= radialSegments; i++) {
                    x = Math.sin(i * radialAngle);
                    z = Math.cos(i * radialAngle);
                    tu = (0.5 * Math.sin(i * radialAngle)) + 0.5;
                    tv = (0.5 * Math.cos(i * radialAngle)) + 0.5;

                    normals.push(radiusBottom * x);
                    normals.push(-1.0);
                    normals.push(radiusBottom * z);
                    uvs.push(tu);
                    uvs.push(tv);
                    positions.push(radiusBottom * x);
                    positions.push(0 - heightHalf);
                    positions.push(radiusBottom * z);
                }

                for (i = 0; i < radialSegments; i++) {
                    center = startIndex;
                    first = startIndex + 1 + i;
                    indices.push(center);
                    indices.push(first + 1);
                    indices.push(first);
                }
            }

            this.positions = positions;
            this.normals = normals;
            this.uv = uvs;
            this.indices = indices;
        },

        _props: {

            /**
             * The CylinderGeometry's level-of-detail factor.
             *
             * Fires a {{#crossLink "CylinderGeometry/lod:event"}}{{/crossLink}} event on change.
             *
             * @property lod
             * @default 1
             * @type Number
             */
            lod: {

                set: function (value) {

                    value = value !== undefined ? value : 1;

                    if (this._lod === value) {
                        return;
                    }

                    if (value < 0 || value > 1) {
                        this.warn("clamping lod to [0..1]");
                        value = value < 0 ? 0 : 1;
                    }

                    this._lod = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this CylinderGeometry's {{#crossLink "CylinderGeometry/lod:property"}}{{/crossLink}} property changes.
                     * @event lod
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("lod", this._lod);
                },

                get: function () {
                    return this._lod;
                }
            },

            /**
             * The CylinderGeometry's top radius.
             *
             * Fires a {{#crossLink "CylinderGeometry/radiusTop:event"}}{{/crossLink}} event on change.
             *
             * @property radiusTop
             * @default 1
             * @type Number
             */
            radiusTop: {

                set: function (value) {

                    value = value !== undefined ? value : 1;

                    if (this._radiusTop === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative radiusTop not allowed - will invert");
                        value = value * -1;
                    }

                    this._radiusTop = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this CylinderGeometry's {{#crossLink "CylinderGeometry/radiusTop:property"}}{{/crossLink}} property changes.
                     * @event radiusTop
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("radiusTop", this._radiusTop);
                },

                get: function () {
                    return this._radiusTop;
                }
            },

            /**
             * The CylinderGeometry's bottom radius.
             *
             * Fires a {{#crossLink "CylinderGeometry/radiusBottom:event"}}{{/crossLink}} event on change.
             *
             * @property radiusBottom
             * @default 1
             * @type Number
             */
            radiusBottom: {

                set: function (value) {

                    value = value !== undefined ? value : 1;

                    if (this._radiusBottom === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative radiusBottom not allowed - will invert");
                        value = value * -1;
                    }

                    this._radiusBottom = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this CylinderGeometry's {{#crossLink "CylinderGeometry/radiusBottom:property"}}{{/crossLink}} property changes.
                     * @event radiusBottom
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("radiusBottom", this._radiusBottom);
                },

                get: function () {
                    return this._radiusBottom;
                }
            },

            /**
             * The CylinderGeometry's height.
             *
             * Fires a {{#crossLink "CylinderGeometry/height:event"}}{{/crossLink}} event on change.
             *
             * @property height
             * @default 1
             * @type Number
             */
            height: {

                set: function (value) {

                    value = value || 1;

                    if (this._height === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative height not allowed - will invert");
                        value = value * -1;
                    }

                    this._height = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this CylinderGeometry's {{#crossLink "CylinderGeometry/height:property"}}{{/crossLink}} property changes.
                     * @event height
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("height", this._height);
                },

                get: function () {
                    return this._height;
                }
            },

            /**
             * The CylinderGeometry's radial segments.
             *
             * Fires a {{#crossLink "CylinderGeometry/radialSegments:event"}}{{/crossLink}} event on change.
             *
             * @property radialSegments
             * @default 60
             * @type Number
             */
            radialSegments: {

                set: function (value) {

                    value = value || 60;

                    if (this._radialSegments === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative radialSegments not allowed - will invert");
                        value = value * -1;
                    }

                    this._radialSegments = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this CylinderGeometry's {{#crossLink "CylinderGeometry/radialSegments:property"}}{{/crossLink}} property changes.
                     * @event radialSegments
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("radialSegments", this._radialSegments);
                },

                get: function () {
                    return this._radialSegments;
                }
            },

            /**
             * The CylinderGeometry's height segments.
             *
             * Fires a {{#crossLink "CylinderGeometry/heightSegments:event"}}{{/crossLink}} event on change.
             *
             * @property heightSegments
             * @default 1
             * @type Number
             */
            heightSegments: {

                set: function (value) {

                    value = value || 1;

                    if (this._heightSegments === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative heightSegments not allowed - will invert");
                        value = value * -1;
                    }

                    this._heightSegments = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this CylinderGeometry's {{#crossLink "CylinderGeometry/heightSegments:property"}}{{/crossLink}} property changes.
                     * @event heightSegments
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("heightSegments", this._heightSegments);
                },

                get: function () {
                    return this._heightSegments;
                }
            },

            /**
             * Indicates whether this CylinderGeometry's is open-ended.
             *
             * Fires a {{#crossLink "CylinderGeometry/openEnded:event"}}{{/crossLink}} event on change.
             *
             * @property openEnded
             * @default false
             * @type Boolean
             */
            openEnded: {

                set: function (value) {

                    value = value === undefined ? false : value;

                    if (this._openEnded === value) {
                        return;
                    }

                    this._openEnded = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this CylinderGeometry's {{#crossLink "CylinderGeometry/openEnded:property"}}{{/crossLink}} property changes.
                     * @event openEnded
                     * @type Boolean
                     * @param value The property's new value
                     */
                    this.fire("openEnded", this._openEnded);
                },

                get: function () {
                    return this._openEnded;
                }
            }
        },


        _getJSON: function () {
            return {
                // Don't save lod
                radiusTop: this._radiusTop,
                radiusBottom: this._radiusBottom,
                height: this._height,
                radialSegments: this._radialSegments,
                heightSegments: this._heightSegments,
                openEnded: this._openEnded
            };
        }
    });

})();
;/**
 A **PlaneGeometry** defines a plane geometry for attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Example

 ````javascript

 ````

 @class PlaneGeometry
 @module XEO
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this PlaneGeometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this PlaneGeometry.
 @param [cfg.primitive="triangles"] {String} The primitive type. Accepted values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.
 @param [cfg.xSize=1] {Number} Dimension on the X-axis.
 @param [cfg.ySize=1] {Number} Dimension on the Y-axis.
 @param [cfg.xSegments=1] {Number} Number of segments on the X-axis.
 @param [cfg.ySegments=1] {Number} Number of segments on the Y-axis.

 @param [cfg.lod=1] {Number} Level-of-detail, in range [0..1].
 @extends Geometry
 */
(function () {

    "use strict";

    XEO.PlaneGeometry = XEO.Geometry.extend({

        type: "XEO.PlaneGeometry",

        _init: function (cfg) {

            this._super(cfg);

            this.xSize = cfg.xSize;
            this.ySize = cfg.ySize;

            this.xSegments = cfg.xSegments;
            this.ySegments = cfg.ySegments;

            this.lod = cfg.lod;

            this.autoNormals = cfg.autoNormals !== false;
        },

        /**
         * Implement protected virtual template method {{#crossLink "Geometry/method:_update"}}{{/crossLink}},
         * to generate geometry data arrays.
         *
         * @protected
         */
        _update: function () {

            // Geometry needs rebuild

            var width = this._xSize;
            var height = this._ySize;

            var xSegments = Math.floor(this._lod * this._xSegments);
            var ySegments = Math.floor(this._lod * this._ySegments);

            if (ySegments < 1) {
                ySegments = 1;
            }

            if (ySegments < 1) {
                ySegments = 1;
            }

            var halfWidth = width / 2;
            var halfHeight = height / 2;

            var planeX = Math.floor(xSegments) || 1;
            var planeY = Math.floor(ySegments) || 1;

            var planeX1 = planeX + 1;
            var planeY1 = planeY + 1;

            var segmentWidth = width / planeX;
            var segmentHeight = height / planeY;

            var positions = new Float32Array(planeX1 * planeY1 * 3);
            var normals = new Float32Array(planeX1 * planeY1 * 3);
            var uvs = new Float32Array(planeX1 * planeY1 * 2);

            var offset = 0;
            var offset2 = 0;

            for (var iy = 0; iy < planeY1; iy++) {

                var y = iy * segmentHeight - halfHeight;

                for (var ix = 0; ix < planeX1; ix++) {

                    var x = ix * segmentWidth - halfWidth;

                    positions[offset] = x;
                    positions[offset + 1] = -y;

                    normals[offset + 2] = -1;

                    uvs[offset2] = (planeX - ix) / planeX;
                    uvs[offset2 + 1] = ( (planeY - iy) / planeY );

                    offset += 3;
                    offset2 += 2;
                }
            }

            offset = 0;

            var indices = new ( ( positions.length / 3 ) > 65535 ? Uint32Array : Uint16Array )(planeX * planeY * 6);

            for (var iy = 0; iy < planeY; iy++) {

                for (var ix = 0; ix < planeX; ix++) {

                    var a = ix + planeX1 * iy;
                    var b = ix + planeX1 * ( iy + 1 );
                    var c = ( ix + 1 ) + planeX1 * ( iy + 1 );
                    var d = ( ix + 1 ) + planeX1 * iy;

                    indices[offset] = d;
                    indices[offset + 1] = b;
                    indices[offset + 2] = a;

                    indices[offset + 3] = d;
                    indices[offset + 4] = c;
                    indices[offset + 5] = b;

                    offset += 6;
                }
            }

            this.positions = positions;
            this.normals = normals;
            this.uv = uvs;
            this.indices = indices;
        },


        _props: {

            /**
             * The PlaneGeometry's level-of-detail factor.
             *
             * Fires a {{#crossLink "PlaneGeometry/lod:event"}}{{/crossLink}} event on change.
             *
             * @property lod
             * @default 1
             * @type Number
             */
            lod: {

                set: function (value) {

                    value = value !== undefined ? value : 1;

                    if (this._lod === value) {
                        return;
                    }

                    if (value < 0 || value > 1) {
                        this.warn("clamping lod to [0..1]");
                        value = value < 0 ? 0 : 1;
                    }

                    this._lod = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this PlaneGeometry's {{#crossLink "PlaneGeometry/lod:property"}}{{/crossLink}} property changes.
                     * @event lod
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("lod", this._lod);
                },

                get: function () {
                    return this._lod;
                }
            },

            /**
             * The PlaneGeometry's dimension on the X-axis.
             *
             * Fires a {{#crossLink "PlaneGeometry/xSize:event"}}{{/crossLink}} event on change.
             *
             * @property xSize
             * @default 1
             * @type Number
             */
            xSize: {

                set: function (value) {

                    value = value || 1;

                    if (this._xSize === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative xSize not allowed - will invert");
                        value = value * -1;
                    }

                    this._xSize = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this PlaneGeometry's {{#crossLink "PlaneGeometry/xSize:property"}}{{/crossLink}} property changes.
                     * @event xSize
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("xSize", this._xSize);
                },

                get: function () {
                    return this._xSize;
                }
            },

            /**
             * The PlaneGeometry's dimension on the Y-axis.
             *
             * Fires a {{#crossLink "PlaneGeometry/ySize:event"}}{{/crossLink}} event on change.
             *
             * @property ySize
             * @default 1.0
             * @type Number
             */
            ySize: {

                set: function (value) {

                    value = value || 1.0;

                    if (this._ySize === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative ySize not allowed - will invert");
                        value = value * -1;
                    }

                    this._ySize = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this PlaneGeometry's {{#crossLink "PlaneGeometry/ySize:property"}}{{/crossLink}} property changes.
                     * @event ySize
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("ySize", this._ySize);
                },

                get: function () {
                    return this._ySize;
                }
            },

            /**
             * The PlaneGeometry's number of segments on the X-axis.
             *
             * Fires a {{#crossLink "PlaneGeometry/xSegments:event"}}{{/crossLink}} event on change.
             *
             * @property xSegments
             * @default 1
             * @type Number
             */
            xSegments: {

                set: function (value) {

                    value = value || 1;

                    if (this._xSegments === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative xSegments not allowed - will invert");
                        value = value * -1;
                    }

                    this._xSegments = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this PlaneGeometry's {{#crossLink "PlaneGeometry/xSegments:property"}}{{/crossLink}} property changes.
                     * @event xSegments
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("xSegments", this._xSegments);
                },

                get: function () {
                    return this._xSegments;
                }
            },

            /**
             * The PlaneGeometry's number of segments on the Y-axis.
             *
             * Fires a {{#crossLink "PlaneGeometry/ySegments:event"}}{{/crossLink}} event on change.
             *
             * @property ySegments
             * @default 1
             * @type Number
             */
            ySegments: {

                set: function (value) {

                    value = value || 1;

                    if (this._ySegments === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative ySegments not allowed - will invert");
                        value = value * -1;
                    }

                    this._ySegments = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this PlaneGeometry's {{#crossLink "PlaneGeometry/ySegments:property"}}{{/crossLink}} property changes.
                     * @event ySegments
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("ySegments", this._ySegments);
                },

                get: function () {
                    return this._ySegments;
                }
            }
        },

        _getJSON: function () {
            return {
                xSize: this._xSize,
                ySize: this._ySize,
                xSegments: this._xSegments,
                ySegments: this._ySegments
            };
        }
    });

})();
;/**
 A **LatheGeometry** is a {{#crossLink "Geometry"}}{{/crossLink}} that's defined as the revolution of a profile about an exis.

 ## Example

 ````javascript

 ````

 @class LatheGeometry
 @module XEO
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this LatheGeometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this LatheGeometry.
 @param [cfg.primitive="triangles"] {String} The primitive type. Accepted values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.
 @param [cfg.points=[]] Profile points.
 @param [cfg.segments=4] {Number} Number of revolution segments.
 @param [cfg.phiStart=0] {Number} Angle in degrees at which revolution starts.
 @param [cfg.phiLength=360] {Number} Length of revolution in degrees.
 @param [cfg.lod=1] {Number} Level-of-detail, in range [0..1].
 @extends Geometry
 */
(function () {

    "use strict";

    XEO.LatheGeometry = XEO.Geometry.extend({

        type: "XEO.LatheGeometry",

        _init: function (cfg) {

            this._super(cfg);

            this.points = cfg.points;
            this.segments = cfg.segments;
            this.phiStart = cfg.phiStart;
            this.phiLength = cfg.phiLength;
            this.lod = cfg.lod;
            this.autoNormals = cfg.autoNormals !== false;
        },

        /**
         * Implement protected virtual template method {{#crossLink "Geometry/method:_update"}}{{/crossLink}},
         * to generate geometry data arrays.
         *
         * @protected
         */
        _update: function () {

            var positions = [];
            var uvs = [];
            var indices = [];
            var segments = Math.floor(this._lod * this._segments);
            if (segments < 4) {
                segments = 4;
            }
            var phiStart = this._phiStart * XEO.math.DEGTORAD;
            var phiLength = this._phiLength * XEO.math.DEGTORAD;
            var points = this._points;
            var inversePointLength = 1.0 / ( points.length - 1 );
            var inverseSegments = 1.0 / segments;

            for (var i = 0, il = segments; i <= il; i++) {

                var phi = phiStart + i * inverseSegments * phiLength;

                var c = Math.cos(phi);
                var s = Math.sin(phi);

                for (var j = 0, jl = points.length; j < jl; j++) {

                    var pt = points[j];

                    positions.push(c * pt[0] - s * pt[1]);
                    positions.push(s * pt[0] + c * pt[1]);
                    positions.push(pt[2]);
                }
            }

            var np = points.length;

            for (var i = 0, il = segments; i < il; i++) {

                for (var j = 0, jl = points.length - 1; j < jl; j++) {

                    var base = j + np * i;
                    var a = base;
                    var b = base + np;
                    var c = base + 1 + np;
                    var d = base + 1;

                    var u0 = i * inverseSegments;
                    var v0 = j * inversePointLength;
                    var u1 = u0 + inverseSegments;
                    var v1 = v0 + inversePointLength;

                    indices.push(d);
                    indices.push(b);
                    indices.push(a);

                    //uvs.push(u0);
                    //uvs.push(v0);
                    //
                    //uvs.push(u1);
                    //uvs.push(v0);
                    //
                    //uvs.push(u0);
                    //uvs.push(v1);

                    indices.push(d);
                    indices.push(c);
                    indices.push(b);

                    //uvs.push(u1);
                    //uvs.push(v0);
                    //
                    //uvs.push(u1);
                    //uvs.push(v1);
                    //
                    //uvs.push(u0);
                    //uvs.push(v1);
                }
            }

            this.positions = positions;
            //   this.normals = positions;
            //  this.uv = positions;
            this.indices = indices;
        },

        _props: {

            /**
             Profile points on this LatheGeometry.

             Fires a {{#crossLink "LatheGeometry/points:event"}}{{/crossLink}} event on change.

             @property points
             @default []
             @type Array(Number)
             */
            points: {

                set: function (value) {

                    this._points = value || [];

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this LatheGeometry's
                     * {{#crossLink "LatheGeometry/points:property"}}{{/crossLink}} property changes.
                     * @event points
                     * @param value The property's new value
                     */
                    this.fire("points", this._points);
                },

                get: function () {
                    return this._points;
                }
            },

            /**
             * The LatheGeometry's level-of-detail factor.
             *
             * Fires a {{#crossLink "LatheGeometry/lod:event"}}{{/crossLink}} event on change.
             *
             * @property lod
             * @default 1
             * @type Number
             */
            lod: {

                set: function (value) {

                    value = value !== undefined ? value : 1;

                    if (this._lod === value) {
                        return;
                    }

                    if (value < 0 || value > 1) {
                        this.warn("clamping lod to [0..1]");
                        value = value < 0 ? 0 : 1;
                    }

                    this._lod = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this LatheGeometry's {{#crossLink "LatheGeometry/lod:property"}}{{/crossLink}} property changes.
                     * @event lod
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("lod", this._lod);
                },

                get: function () {
                    return this._lod;
                }
            },

            /**
             * Angle at which this LatheGeometry's rotation starts.
             *
             * Fires a {{#crossLink "LatheGeometry/phiStart:event"}}{{/crossLink}} event on change.
             *
             * @property phiStart
             * @default 0
             * @type Number
             */
            phiStart: {

                set: function (value) {

                    value = value || 0;

                    if (this._phiStart === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative phiStart not allowed - will invert");
                        value = value * -1;
                    }

                    this._phiStart = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this LatheGeometry's {{#crossLink "LatheGeometry/phiStart:property"}}{{/crossLink}} property changes.
                     * @event phiStart
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("phiStart", this._phiStart);
                },

                get: function () {
                    return this._phiStart;
                }
            },

            /**
             * Angle at which this LatheGeometry's rotation starts.
             *
             * Fires a {{#crossLink "LatheGeometry/phiLength:event"}}{{/crossLink}} event on change.
             *
             * @property phiLength
             * @default 1
             * @type Number
             */
            phiLength: {

                set: function (value) {

                    value = value || 1;

                    if (this._phiLength === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative phiLength not allowed - will invert");
                        value = value * -1;
                    }

                    this._phiLength = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this LatheGeometry's {{#crossLink "LatheGeometry/phiLength:property"}}{{/crossLink}} property changes.
                     * @event phiLength
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("phiLength", this._phiLength);
                },

                get: function () {
                    return this._phiLength;
                }
            },

            /**
             * The LatheGeometry's number of segments of rotation.
             *
             * Fires a {{#crossLink "LatheGeometry/segments:event"}}{{/crossLink}} event on change.
             *
             * @property segments
             * @default 4
             * @type Number
             */
            segments: {

                set: function (value) {

                    value = Math.floor(value || 4);

                    if (this._segments === value) {
                        return;
                    }

                    if (value < 0) {
                        this.warn("negative segments not allowed - will invert");
                        value = value * -1;
                    }

                    this._segments = value;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this LatheGeometry's {{#crossLink "LatheGeometry/segments:property"}}{{/crossLink}} property changes.
                     * @event segments
                     * @type Number
                     * @param value The property's new value
                     */
                    this.fire("segments", this._segments);
                },

                get: function () {
                    return this._segments;
                }
            }
        },

        _getJSON: function () {
            return {
                points: this._points,
                phiStart: this._phiStart,
                phiLength: this._phiLength,
                segments: this._segments
            };
        }
    });

})();
;/**
 * Components for managing collections of components.
 *
 * @module XEO
 * @submodule collections
 */;/**
 A **Collection** is a general-purpose group of {{#crossLink "Component"}}Components{{/crossLink}}.

 ## Overview

 <ul>
 <li>A {{#crossLink "Component"}}Component{{/crossLink}} can be included in more than one Collection.</li>
 <li>{{#crossLink "Component"}}Components{{/crossLink}} can be added to a Collection by instance, ID or type.</li>
 <li>A Collection supports iteration over its {{#crossLink "Component"}}Components{{/crossLink}}.</li>
 <li>A {{#crossLink "Model"}}Model{{/crossLink}} stores the {{#crossLink "Component"}}Components{{/crossLink}} it has loaded in a Collection.</li>
 <li>A {{#crossLink "CollectionBoundary"}}CollectionBoundary{{/crossLink}} can be used to track the World-space bounding box that encloses a Collection.</li>
 </ul>

 <img src="../../../assets/images/Collection.png"></img>

 ## Example


 ````javascript
 var material = new XEO.PhongMaterial({
     id: "myMaterial",
     diffuse: [0.5, 0.5, 0.0]
 });

 var geometry = new XEO.BoxGeometry();

 var Entity = new XEO.Entity({
    id: "myEntity",
    material: material,
    geometry: geometry
 });

 // Our first collection contains the Material, added by ID,
 // plus the Geometry and Entity, both added by instance.

 var collection1 = new XEO.Collection({ // Initialize with three components
    components: [
        "myMaterial",
        geometry,
        Entity
    ]
 });

 // Our second Collection includes the geometry, added by instance,
 // and the Entity, added by type. If there were more than
 // one Entity in the scene, then that type would ensure
 // that all the Entities were in the Collection.

 var collection2 = new XEO.Collection();

 collection2.add([  // Add two components
 geometry,
 "XEO.Entity",
 ]);

 // We can iterate over the components in a Collection like so:

 collection1.iterate(
 function(component) {
        //..
    });

 // And remove components from a Collection
 // by instance, ID or type:

 collection1.remove("myMaterial"); // Remove one component by ID
 collection1.remove([geometry, Entity]); // Remove two components by instance

 collection2.remove("XEO.Geometry"); // Remove all Geometries
 ````

 TODO

 @class Collection
 @module XEO
 @submodule collections
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}{{/crossLink}}.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Component} Optional map of user-defined metadata to attach to this Collection.
 @param [cfg.components] {{Array of String|Component}} Array of {{#crossLink "Component"}}{{/crossLink}} IDs or instances.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Collection = XEO.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "XEO.Collection",

        _init: function (cfg) {

            /**
             * The {{#crossLink "Components"}}{{/crossLink}} within this Collection, mapped to their IDs.
             *
             * Fires an {{#crossLink "Collection/updated:event"}}{{/crossLink}} event on change.
             *
             * @property components
             * @type {{String:Component}}
             */
            this.components = {};

            /**
             * The number of {{#crossLink "Components"}}{{/crossLink}} within this Collection.
             *
             * @property numComponents
             * @type Number
             */
            this.numComponents = 0;

            /**
             * A map of maps; for each {{#crossLink "Component"}}{{/crossLink}} type in this Collection,
             * a map to IDs to {{#crossLink "Component"}}{{/crossLink}} instances, eg.
             *
             * ````
             * "XEO.Geometry": {
             *   "alpha": <XEO.Geometry>,
             *   "beta": <XEO.Geometry>
             * },
             * "XEO.Rotate": {
             *   "charlie": <XEO.Rotate>,
             *   "delta": <XEO.Rotate>,
             *   "echo": <XEO.Rotate>,
             * },
             * //...
             * ````
             *
             * @property types
             * @type {String:{String:XEO.Component}}
             */
            this.types = {};

            // Subscriptions to "destroyed" events from components
            this._destroyedSubs = {};

            if (cfg.components) {
                this.add(cfg.components);
            }
        },

        /**
         * Adds one or more {{#crossLink "Component"}}Components{{/crossLink}}s to this Collection.
         *
         * The {{#crossLink "Component"}}Component(s){{/crossLink}} may be specified by instance, ID or type.
         *
         * See class comment for usage examples.
         *
         * The {{#crossLink "Component"}}Components{{/crossLink}} must be in the same {{#crossLink "Scene"}}{{/crossLink}} as this Collection.
         *
         * Fires an {{#crossLink "Collection/added:event"}}{{/crossLink}} event.
         *
         * @method add
         * @param {Array of Component} components Array of {{#crossLink "Component"}}Components{{/crossLink}} instances.
         */
        add: function (components) {

            components = XEO._isArray(components) ? components : [components];

            for (var i = 0, len = components.length; i < len; i++) {
                this._add(components[i]);
            }
        },

        _add: function (c) {

            var componentId;
            var component;
            var type;
            var types;

            if (c.type) {

                // Component instance

                component = c;

            } else if (XEO._isNumeric(c) || XEO._isString(c)) {

                if (this.scene.types[c]) {

                    // Component type

                    type = c;

                    types = this.scene.types[type];

                    if (!types) {
                        this.warn("Component type not found: '" + type + "'");
                        return;
                    }

                    for (componentId in types) {
                        if (types.hasOwnProperty(componentId)) {
                            this._add(types[componentId]);
                        }
                    }

                    return;

                } else {

                    // Component ID

                    component = this.scene.components[c];

                    if (!component) {
                        this.warn("Component not found: " + XEO._inQuotes(c));
                        return;
                    }
                }

            } else {

                return;
            }

            if (component.scene != this.scene) {

                // Component in wrong Scene

                this.warn("Attempted to add component from different XEO.Scene: " + XEO._inQuotes(component.id));
                return;
            }

            // Add component to this map

            if (this.components[component.id]) {

                // Component already in this Collection
                return;
            }

            this.components[component.id] = component;

            // Register component for its type

            types = this.types[component.type];

            if (!types) {
                types = this.types[type] = {};
            }

            types[component.id] = component;

            this.numComponents++;

            // Remove component when it's destroyed

            var self = this;

            this._destroyedSubs[component.id] = component.on("destroyed",
                function (component) {
                    self._remove(component);
                });

            /**
             * Fired whenever an individual {{#crossLink "Component"}}{{/crossLink}} is added to this {{#crossLink "Collection"}}{{/crossLink}}.
             * @event added
             * @param value {Component} The {{#crossLink "Component"}}{{/crossLink}} that was added.
             */
            this.fire("added", component);

            if (!this._dirty) {
                this._scheduleUpdate();
            }
        },

        _scheduleUpdate: function () {
            if (!this._dirty) {
                this._dirty = true;
                XEO.scheduleTask(this._notifyUpdated, this);
            }
        },

        _notifyUpdated: function () {

            /* Fired on the next {{#crossLink "Scene/tick.animate:event"}}{{/crossLink}} whenever
             * {{#crossLink "Component"}}Components{{/crossLink}} were added or removed since the
             * last {{#crossLink "Scene/tick.animate:event"}}{{/crossLink}} event, to provide a batched change event
             * for subscribers who don't want to react to every individual addition or removal on this Collection.
             *
             * @event updated
             */
            this.fire("updated");
            this._dirty = false;
        },

        /**
         * Removes all {{#crossLink "Component"}}Components{{/crossLink}} from this Collection.
         *
         * Fires an {{#crossLink "Collection/updated:event"}}{{/crossLink}} event.
         *
         * @method clear
         */
        clear: function () {

            this.iterate(function (component) {
                this._remove(component);
            });
        },

        /**
         * Destroys all {{#crossLink "Component"}}Components{{/crossLink}} in this Collection.
         *
         * @method destroyAll
         */
        destroyAll: function () {

            this.iterate(function (component) {
                component.destroy();
            });
        },

        /**
         * Removes one or more {{#crossLink "Component"}}Components{{/crossLink}} from this Collection.
         *
         * The {{#crossLink "Component"}}Component(s){{/crossLink}} may be specified by instance, ID or type.
         *
         * See class comment for usage examples.
         *
         * Fires a {{#crossLink "Collection/removed:event"}}{{/crossLink}} event.
         *
         * @method remove
         * @param {Array of Components} components Array of {{#crossLink "Component"}}Components{{/crossLink}} instances.
         */
        remove: function (components) {

            components = XEO._isArray(components) ? components : [components];

            for (var i = 0, len = components.length; i < len; i++) {
                this._remove(components[i]);
            }
        },

        _remove: function (component) {

            var componentId = component.id;

            if (component.scene != this.scene) {
                this.warn("Attempted to remove component that's not in same XEO.Scene: '" + componentId + "'");
                return;
            }

            delete this.components[componentId];

            // Unsubscribe from component destruction

            component.off(this._destroyedSubs[componentId]);

            delete this._destroyedSubs[componentId];

            // Unregister component for its type

            var types = this.types[component.type];

            if (types) {
                delete types[component.id];
            }

            this.numComponents--;

            /**
             * Fired whenever an individual {{#crossLink "Component"}}{{/crossLink}} is removed from this {{#crossLink "Collection"}}{{/crossLink}}.
             * @event removed
             * @param value {Component} The {{#crossLink "Component"}}{{/crossLink}} that was removed.
             */
            this.fire("removed", component);

            if (!this._dirty) {
                this._scheduleUpdate();
            }
        },

        /**
         * Iterates with a callback over the {{#crossLink "Component"}}Components{{/crossLink}} in this Collection.
         *
         * @method iterate
         * @param {Function} callback Callback called for each {{#crossLink "Component"}}{{/crossLink}}.
         * @param {Object} [scope=this] Optional scope for the callback, defaults to this Collection.
         */
        iterate: function (callback, scope) {
            scope = scope || this;
            for (var componentId in this.components) {
                if (this.components.hasOwnProperty(componentId)) {
                    callback.call(scope, this.components[componentId]);
                }
            }
        },

        _getJSON: function () {

            var componentIds = [];

            for (var componentId in this.components) {
                if (this.components.hasOwnProperty(componentId)) {
                    componentIds.push(this.components[componentId].id); // Don't convert numbers into strings
                }
            }

            return {
                components: componentIds
            };
        },

        _destroy: function () {

            this.clear();
        }
    });

})();;/**
 * Components for capturing user input.
 *
 * @module XEO
 * @submodule input
 */;/**
 Publishes key and mouse events that occur on the parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}}.

 ## Overview

 <ul>
 <li>Each {{#crossLink "Scene"}}{{/crossLink}} provides an Input on itself as a read-only property.</li>
 </ul>

 <img src="../../../assets/images/Input.png"></img>

 ## Example

 In this example, we're subscribing to some mouse and key events that will occur on
 a {{#crossLink "Scene"}}Scene's{{/crossLink}} {{#crossLink "Canvas"}}Canvas{{/crossLink}}.

 ````javascript
 var myScene = new XEO.Scene();

 var input = myScene.input;

 // We'll save a handle to this subscription
 // to show how to unsubscribe, further down
 var handle = input.on("mousedown", function(coords) {
       console.log("Mouse down at: x=" + coords[0] + ", y=" + coords[1]);
 });

 input.on("mouseup", function(coords) {
       console.log("Mouse up at: x=" + coords[0] + ", y=" + coords[1]);
 });

 input.on("mouseclicked", function(coords) {
      console.log("Mouse clicked at: x=" + coords[0] + ", y=" + coords[1]);
 });

 input.on("dblclick", function(coords) {
       console.log("Double-click at: x=" + coords[0] + ", y=" + coords[1]);
 });

 input.on("keydown", function(keyCode) {
        switch (keyCode) {

            case this.KEY_A:
               console.log("The 'A' key is down");
               break;

            case this.KEY_B:
               console.log("The 'B' key is down");
               break;

            case this.KEY_C:
               console.log("The 'C' key is down");
               break;

            default:
               console.log("Some other key is down");
       }
     });

 input.on("keyup", function(keyCode) {
        switch (keyCode) {

            case this.KEY_A:
               console.log("The 'A' key is up");
               break;

            case this.KEY_B:
               console.log("The 'B' key is up");
               break;

            case this.KEY_C:
               console.log("The 'C' key is up");
               break;

            default:
               console.log("Some other key is up");
        }
     });

 // TODO: ALT and CTRL keys etc
 ````

 ### Unsubscribing from Events

 In the snippet above, we saved a handle to one of our event subscriptions.

 We can then use that handle to unsubscribe again, like this:

 ````javascript
 input.off(handle);
 ````

 @class Input
 @module XEO
 @submodule input
 @extends Component
 */
(function () {

    "use strict";

    XEO.Input = XEO.Component.extend({

        type: "XEO.Input",

        serializable: false,

        _init: function (cfg) {

            var self = this;

            // True when ALT down
            this.altDown = false;

            /** True whenever CTRL is down
             *
             * @type {boolean}
             */
            this.ctrlDown = false;

            /** True whenever left mouse button is down
             *
             * @type {boolean}
             */
            this.mouseDownLeft = false;

            /** True whenever middle mouse button is down
             *
             * @type {boolean}
             */
            this.mouseDownMiddle = false;

            /** True whenever right mouse button is down
             *
             * @type {boolean}
             */
            this.mouseDownRight = false;

            /** Flag for each key that's down
             *
             * @type {boolean}
             */
            this.keyDown = [];

            /** True while input enabled
             *
             * @type {boolean}
             */
            this.enabled = true;

            // Capture input events and publish them on this component

            document.addEventListener("keydown",
                this._keyDownListener = function (e) {

                    if (!self.enabled) {
                        return;
                    }

                    if (e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA") {

                        if (e.ctrlKey) {
                            self.ctrlDown = true;

                        } else if (e.altKey) {
                            self.altDown = true;

                        } else {
                            self.keyDown[e.keyCode] = true;

                            /**
                             * Fired whenever a key is pressed while the parent
                             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}} has input focus.
                             * @event keydown
                             * @param value {Number} The key code, for example {{#crossLink "Input/KEY_LEFT_ARROW:property"}}{{/crossLink}},
                             */
                            self.fire("keydown", e.keyCode, true);
                        }
                    }
                }, true);


            document.addEventListener("keyup",
                this._keyUpListener = function (e) {

                    if (!self.enabled) {
                        return;
                    }

                    if (e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA") {

                        if (e.ctrlKey) {
                            self.ctrlDown = false;

                        } else if (e.altKey) {
                            self.altDown = false;

                        } else {
                            self.keyDown[e.keyCode] = false;

                            /**
                             * Fired whenever a key is released while the parent
                             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}} has input focus.
                             * @event keyup
                             * @param value {Number} The key code, for example {{#crossLink "Input/KEY_LEFT_ARROW:property"}}{{/crossLink}},
                             */
                            self.fire("keyup", e.keyCode, true);
                        }
                    }
                });

            cfg.element.addEventListener("mousedown",
                this._mouseDownListener = function (e) {

                    if (!self.enabled) {
                        return;
                    }

                    switch (e.which) {

                        case 1:// Left button
                            self.mouseDownLeft = true;
                            break;

                        case 2:// Middle/both buttons
                            self.mouseDownMiddle = true;
                            break;

                        case 3:// Right button
                            self.mouseDownRight = true;
                            break;

                        default:
                            break;
                    }

                    var coords = self._getClickCoordsWithinElement(e);

                    /**
                     * Fired whenever the mouse is pressed over the parent
                     * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}}.
                     * @event mousedown
                     * @param value {[Number, Number]} The mouse coordinates within the {{#crossLink "Canvas"}}Canvas{{/crossLink}},
                     */
                    self.fire("mousedown", coords, true);
                });

            cfg.element.addEventListener("mouseup",
                this._mouseUpListener = function (e) {

                    if (!self.enabled) {
                        return;
                    }

                    switch (e.which) {

                        case 1:// Left button
                            self.mouseDownLeft = false;
                            break;

                        case 2:// Middle/both buttons
                            self.mouseDownMiddle = false;
                            break;

                        case 3:// Right button
                            self.mouseDownRight = false;
                            break;

                        default:
                            break;
                    }

                    var coords = self._getClickCoordsWithinElement(e);

                    /**
                     * Fired whenever the mouse is released over the parent
                     * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}}.
                     * @event mouseup
                     * @param value {[Number, Number]} The mouse coordinates within the {{#crossLink "Canvas"}}Canvas{{/crossLink}},
                     */
                    self.fire("mouseup", coords, true);
                });

            cfg.element.addEventListener("dblclick",
                this._dblClickListener = function (e) {

                    if (!self.enabled) {
                        return;
                    }

                    switch (e.which) {

                        case 1:// Left button
                            self.mouseDownLeft = false;
                            self.mouseDownRight = false;
                            break;

                        case 2:// Middle/both buttons
                            self.mouseDownMiddle = false;
                            break;

                        case 3:// Right button
                            self.mouseDownLeft = false;
                            self.mouseDownRight = false;
                            break;

                        default:
                            break;
                    }

                    var coords = self._getClickCoordsWithinElement(e);

                    /**
                     * Fired whenever the mouse is double-clicked over the parent
                     * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}}.
                     * @event dblclick
                     * @param value {[Number, Number]} The mouse coordinates within the {{#crossLink "Canvas"}}Canvas{{/crossLink}},
                     */
                    self.fire("dblclick", coords, true);
                });

            cfg.element.addEventListener("mousemove",
                this._mouseMoveListener = function (e) {

                    if (!self.enabled) {
                        return;
                    }

                    var coords = self._getClickCoordsWithinElement(e);

                    /**
                     * Fired whenever the mouse is moved over the parent
                     * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}}.
                     * @event mousedown
                     * @param value {[Number, Number]} The mouse coordinates within the {{#crossLink "Canvas"}}Canvas{{/crossLink}},
                     */
                    self.fire("mousemove", coords, true);
                });

            cfg.element.addEventListener("mousewheel",
                this._mouseWheelListener = function (e, d) {
                    if (!self.enabled) {
                        return;
                    }

                    var e = window.event || e; // old IE support
                    var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));

                    /**
                     * Fired whenever the mouse wheel is moved over the parent
                     * {{#crossLink "Viewer"}}Viewer{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}}.
                     * @event mousewheel
                     * @param delta {Number} The mouse wheel delta,
                     */
                    self.fire("mousewheel", delta, true);
                });

            // mouseclicked

            (function () {

                var downX;
                var downY;

                // Tolerance between down and up positions for a mouse click
                var tolerance = 2;

                self.on("mousedown",
                    function (params) {
                        downX = params[0];
                        downY = params[1];
                    });

                self.on("mouseup",
                    function (params) {

                        if (downX >= (params[0] - tolerance) &&
                            downX <= (params[0] + tolerance) &&
                            downY >= (params[1] - tolerance) &&
                            downY <= (params[1] + tolerance)) {

                            /**
                             * Fired whenever the mouse is clicked over the parent
                             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}}.
                             * @event mouseclicked
                             * @param value {[Number, Number]} The mouse coordinates within the {{#crossLink "Canvas"}}Canvas{{/crossLink}},
                             */
                            self.fire("mouseclicked", params, true);
                        }
                    });
            })();
        },

        _getClickCoordsWithinElement: function (event) {
            var coords = [0, 0];
            if (!event) {
                event = window.event;
                coords.x = event.x;
                coords.y = event.y;
            }
            else {
                var element = event.target;
                var totalOffsetLeft = 0;
                var totalOffsetTop = 0;

                while (element.offsetParent) {
                    totalOffsetLeft += element.offsetLeft;
                    totalOffsetTop += element.offsetTop;
                    element = element.offsetParent;
                }
                coords[0] = event.pageX - totalOffsetLeft;
                coords[1] = event.pageY - totalOffsetTop;
            }
            return coords;
        },

        /**
         * Enable or disable all input handlers
         *
         * @param enable
         */
        setEnabled: function (enable) {
            if (this.enabled !== enable) {
                this.fire("enabled", this.enabled = enable);
            }
        },

        // Key codes

        /**
         * Code for the BACKSPACE key.
         * @property KEY_BACKSPACE
         * @final
         * @type Number
         */
        KEY_BACKSPACE: 8,

        /**
         * Code for the TAB key.
         * @property KEY_TAB
         * @final
         * @type Number
         */
        KEY_TAB: 9,

        /**
         * Code for the ENTER key.
         * @property KEY_ENTER
         * @final
         * @type Number
         */
        KEY_ENTER: 13,

        /**
         * Code for the SHIFT key.
         * @property KEY_SHIFT
         * @final
         * @type Number
         */
        KEY_SHIFT: 16,

        /**
         * Code for the CTRL key.
         * @property KEY_CTRL
         * @final
         * @type Number
         */
        KEY_CTRL: 17,

        /**
         * Code for the ALT key.
         * @property KEY_ALT
         * @final
         * @type Number
         */
        KEY_ALT: 18,

        /**
         * Code for the PAUSE_BREAK key.
         * @property KEY_PAUSE_BREAK
         * @final
         * @type Number
         */
        KEY_PAUSE_BREAK: 19,

        /**
         * Code for the CAPS_LOCK key.
         * @property KEY_CAPS_LOCK
         * @final
         * @type Number
         */
        KEY_CAPS_LOCK: 20,

        /**
         * Code for the ESCAPE key.
         * @property KEY_ESCAPE
         * @final
         * @type Number
         */
        KEY_ESCAPE: 27,

        /**
         * Code for the PAGE_UP key.
         * @property KEY_PAGE_UP
         * @final
         * @type Number
         */
        KEY_PAGE_UP: 33,

        /**
         * Code for the PAGE_DOWN key.
         * @property KEY_PAGE_DOWN
         * @final
         * @type Number
         */
        KEY_PAGE_DOWN: 34,

        /**
         * Code for the END key.
         * @property KEY_END
         * @final
         * @type Number
         */
        KEY_END: 35,

        /**
         * Code for the HOME key.
         * @property KEY_HOME
         * @final
         * @type Number
         */
        KEY_HOME: 36,

        /**
         * Code for the LEFT_ARROW key.
         * @property KEY_LEFT_ARROW
         * @final
         * @type Number
         */
        KEY_LEFT_ARROW: 37,

        /**
         * Code for the UP_ARROW key.
         * @property KEY_UP_ARROW
         * @final
         * @type Number
         */
        KEY_UP_ARROW: 38,

        /**
         * Code for the RIGHT_ARROW key.
         * @property KEY_RIGHT_ARROW
         * @final
         * @type Number
         */
        KEY_RIGHT_ARROW: 39,

        /**
         * Code for the DOWN_ARROW key.
         * @property KEY_DOWN_ARROW
         * @final
         * @type Number
         */
        KEY_DOWN_ARROW: 40,

        /**
         * Code for the INSERT key.
         * @property KEY_INSERT
         * @final
         * @type Number
         */
        KEY_INSERT: 45,

        /**
         * Code for the DELETE key.
         * @property KEY_DELETE
         * @final
         * @type Number
         */
        KEY_DELETE: 46,

        /**
         * Code for the 0 key.
         * @property KEY_NUM_0
         * @final
         * @type Number
         */
        KEY_NUM_0: 48,

        /**
         * Code for the 1 key.
         * @property KEY_NUM_1
         * @final
         * @type Number
         */
        KEY_NUM_1: 49,

        /**
         * Code for the 2 key.
         * @property KEY_NUM_2
         * @final
         * @type Number
         */
        KEY_NUM_2: 50,

        /**
         * Code for the 3 key.
         * @property KEY_NUM_3
         * @final
         * @type Number
         */
        KEY_NUM_3: 51,

        /**
         * Code for the 4 key.
         * @property KEY_NUM_4
         * @final
         * @type Number
         */
        KEY_NUM_4: 52,

        /**
         * Code for the 5 key.
         * @property KEY_NUM_5
         * @final
         * @type Number
         */
        KEY_NUM_5: 53,

        /**
         * Code for the 6 key.
         * @property KEY_NUM_6
         * @final
         * @type Number
         */
        KEY_NUM_6: 54,

        /**
         * Code for the 7 key.
         * @property KEY_NUM_7
         * @final
         * @type Number
         */
        KEY_NUM_7: 55,

        /**
         * Code for the 8 key.
         * @property KEY_NUM_8
         * @final
         * @type Number
         */
        KEY_NUM_8: 56,

        /**
         * Code for the 9 key.
         * @property KEY_NUM_9
         * @final
         * @type Number
         */
        KEY_NUM_9: 57,

        /**
         * Code for the A key.
         * @property KEY_A
         * @final
         * @type Number
         */
        KEY_A: 65,

        /**
         * Code for the B key.
         * @property KEY_B
         * @final
         * @type Number
         */
        KEY_B: 66,

        /**
         * Code for the C key.
         * @property KEY_C
         * @final
         * @type Number
         */
        KEY_C: 67,

        /**
         * Code for the D key.
         * @property KEY_D
         * @final
         * @type Number
         */
        KEY_D: 68,

        /**
         * Code for the E key.
         * @property KEY_E
         * @final
         * @type Number
         */
        KEY_E: 69,

        /**
         * Code for the F key.
         * @property KEY_F
         * @final
         * @type Number
         */
        KEY_F: 70,

        /**
         * Code for the G key.
         * @property KEY_G
         * @final
         * @type Number
         */
        KEY_G: 71,

        /**
         * Code for the H key.
         * @property KEY_H
         * @final
         * @type Number
         */
        KEY_H: 72,

        /**
         * Code for the I key.
         * @property KEY_I
         * @final
         * @type Number
         */
        KEY_I: 73,

        /**
         * Code for the J key.
         * @property KEY_J
         * @final
         * @type Number
         */
        KEY_J: 74,

        /**
         * Code for the K key.
         * @property KEY_K
         * @final
         * @type Number
         */
        KEY_K: 75,

        /**
         * Code for the L key.
         * @property KEY_L
         * @final
         * @type Number
         */
        KEY_L: 76,

        /**
         * Code for the M key.
         * @property KEY_M
         * @final
         * @type Number
         */
        KEY_M: 77,

        /**
         * Code for the N key.
         * @property KEY_N
         * @final
         * @type Number
         */
        KEY_N: 78,

        /**
         * Code for the O key.
         * @property KEY_O
         * @final
         * @type Number
         */
        KEY_O: 79,

        /**
         * Code for the P key.
         * @property KEY_P
         * @final
         * @type Number
         */
        KEY_P: 80,

        /**
         * Code for the Q key.
         * @property KEY_Q
         * @final
         * @type Number
         */
        KEY_Q: 81,

        /**
         * Code for the R key.
         * @property KEY_R
         * @final
         * @type Number
         */
        KEY_R: 82,

        /**
         * Code for the S key.
         * @property KEY_S
         * @final
         * @type Number
         */
        KEY_S: 83,

        /**
         * Code for the T key.
         * @property KEY_T
         * @final
         * @type Number
         */
        KEY_T: 84,

        /**
         * Code for the U key.
         * @property KEY_U
         * @final
         * @type Number
         */
        KEY_U: 85,

        /**
         * Code for the V key.
         * @property KEY_V
         * @final
         * @type Number
         */
        KEY_V: 86,

        /**
         * Code for the W key.
         * @property KEY_W
         * @final
         * @type Number
         */
        KEY_W: 87,

        /**
         * Code for the X key.
         * @property KEY_X
         * @final
         * @type Number
         */
        KEY_X: 88,

        /**
         * Code for the Y key.
         * @property KEY_Y
         * @final
         * @type Number
         */
        KEY_Y: 89,

        /**
         * Code for the Z key.
         * @property KEY_Z
         * @final
         * @type Number
         */
        KEY_Z: 90,

        /**
         * Code for the LEFT_WINDOW key.
         * @property KEY_LEFT_WINDOW
         * @final
         * @type Number
         */
        KEY_LEFT_WINDOW: 91,

        /**
         * Code for the RIGHT_WINDOW key.
         * @property KEY_RIGHT_WINDOW
         * @final
         * @type Number
         */
        KEY_RIGHT_WINDOW: 92,

        /**
         * Code for the SELECT key.
         * @property KEY_SELECT
         * @final
         * @type Number
         */
        KEY_SELECT_KEY: 93,

        /**
         * Code for the number pad 0 key.
         * @property KEY_NUMPAD_0
         * @final
         * @type Number
         */
        KEY_NUMPAD_0: 96,

        /**
         * Code for the number pad 1 key.
         * @property KEY_NUMPAD_1
         * @final
         * @type Number
         */
        KEY_NUMPAD_1: 97,

        /**
         * Code for the number pad 2 key.
         * @property KEY_NUMPAD 2
         * @final
         * @type Number
         */
        KEY_NUMPAD_2: 98,

        /**
         * Code for the number pad 3 key.
         * @property KEY_NUMPAD_3
         * @final
         * @type Number
         */
        KEY_NUMPAD_3: 99,

        /**
         * Code for the number pad 4 key.
         * @property KEY_NUMPAD_4
         * @final
         * @type Number
         */
        KEY_NUMPAD_4: 100,

        /**
         * Code for the number pad 5 key.
         * @property KEY_NUMPAD_5
         * @final
         * @type Number
         */
        KEY_NUMPAD_5: 101,

        /**
         * Code for the number pad 6 key.
         * @property KEY_NUMPAD_6
         * @final
         * @type Number
         */
        KEY_NUMPAD_6: 102,

        /**
         * Code for the number pad 7 key.
         * @property KEY_NUMPAD_7
         * @final
         * @type Number
         */
        KEY_NUMPAD_7: 103,

        /**
         * Code for the number pad 8 key.
         * @property KEY_NUMPAD_8
         * @final
         * @type Number
         */
        KEY_NUMPAD_8: 104,

        /**
         * Code for the number pad 9 key.
         * @property KEY_NUMPAD_9
         * @final
         * @type Number
         */
        KEY_NUMPAD_9: 105,

        /**
         * Code for the MULTIPLY key.
         * @property KEY_MULTIPLY
         * @final
         * @type Number
         */
        KEY_MULTIPLY: 106,

        /**
         * Code for the ADD key.
         * @property KEY_ADD
         * @final
         * @type Number
         */
        KEY_ADD: 107,

        /**
         * Code for the SUBTRACT key.
         * @property KEY_SUBTRACT
         * @final
         * @type Number
         */
        KEY_SUBTRACT: 109,

        /**
         * Code for the DECIMAL POINT key.
         * @property KEY_DECIMAL_POINT
         * @final
         * @type Number
         */
        KEY_DECIMAL_POINT: 110,

        /**
         * Code for the DIVIDE key.
         * @property KEY_DIVIDE
         * @final
         * @type Number
         */
        KEY_DIVIDE: 111,

        /**
         * Code for the F1 key.
         * @property KEY_F1
         * @final
         * @type Number
         */
        KEY_F1: 112,

        /**
         * Code for the F2 key.
         * @property KEY_F2
         * @final
         * @type Number
         */
        KEY_F2: 113,

        /**
         * Code for the F3 key.
         * @property KEY_F3
         * @final
         * @type Number
         */
        KEY_F3: 114,

        /**
         * Code for the F4 key.
         * @property KEY_F4
         * @final
         * @type Number
         */
        KEY_F4: 115,

        /**
         * Code for the F5 key.
         * @property KEY_F5
         * @final
         * @type Number
         */
        KEY_F5: 116,

        /**
         * Code for the F6 key.
         * @property KEY_F6
         * @final
         * @type Number
         */
        KEY_F6: 117,

        /**
         * Code for the F7 key.
         * @property KEY_F7
         * @final
         * @type Number
         */
        KEY_F7: 118,

        /**
         * Code for the F8 key.
         * @property KEY_F8
         * @final
         * @type Number
         */
        KEY_F8: 119,

        /**
         * Code for the F9 key.
         * @property KEY_F9
         * @final
         * @type Number
         */
        KEY_F9: 120,

        /**
         * Code for the F10 key.
         * @property KEY_F10
         * @final
         * @type Number
         */
        KEY_F10: 121,

        /**
         * Code for the F11 key.
         * @property KEY_F11
         * @final
         * @type Number
         */
        KEY_F11: 122,

        /**
         * Code for the F12 key.
         * @property KEY_F12
         * @final
         * @type Number
         */
        KEY_F12: 123,

        /**
         * Code for the NUM_LOCK key.
         * @property KEY_NUM_LOCK
         * @final
         * @type Number
         */
        KEY_NUM_LOCK: 144,

        /**
         * Code for the SCROLL_LOCK key.
         * @property KEY_SCROLL_LOCK
         * @final
         * @type Number
         */
        KEY_SCROLL_LOCK: 145,

        /**
         * Code for the SEMI_COLON key.
         * @property KEY_SEMI_COLON
         * @final
         * @type Number
         */
        KEY_SEMI_COLON: 186,

        /**
         * Code for the EQUAL_SIGN key.
         * @property KEY_EQUAL_SIGN
         * @final
         * @type Number
         */
        KEY_EQUAL_SIGN: 187,

        /**
         * Code for the COMMA key.
         * @property KEY_COMMA
         * @final
         * @type Number
         */
        KEY_COMMA: 188,

        /**
         * Code for the DASH key.
         * @property KEY_DASH
         * @final
         * @type Number
         */
        KEY_DASH: 189,

        /**
         * Code for the PERIOD key.
         * @property KEY_PERIOD
         * @final
         * @type Number
         */
        KEY_PERIOD: 190,

        /**
         * Code for the FORWARD_SLASH key.
         * @property KEY_FORWARD_SLASH
         * @final
         * @type Number
         */
        KEY_FORWARD_SLASH: 191,

        /**
         * Code for the GRAVE_ACCENT key.
         * @property KEY_GRAVE_ACCENT
         * @final
         * @type Number
         */
        KEY_GRAVE_ACCENT: 192,

        /**
         * Code for the OPEN_BRACKET key.
         * @property KEY_OPEN_BRACKET
         * @final
         * @type Number
         */
        KEY_OPEN_BRACKET: 219,

        /**
         * Code for the BACK_SLASH key.
         * @property KEY_BACK_SLASH
         * @final
         * @type Number
         */
        KEY_BACK_SLASH: 220,

        /**
         * Code for the CLOSE_BRACKET key.
         * @property KEY_CLOSE_BRACKET
         * @final
         * @type Number
         */
        KEY_CLOSE_BRACKET: 221,

        /**
         * Code for the SINGLE_QUOTE key.
         * @property KEY_SINGLE_QUOTE
         * @final
         * @type Number
         */
        KEY_SINGLE_QUOTE: 222,

        /**
         * Code for the SPACE key.
         * @property KEY_SPACE
         * @final
         * @type Number
         */
        KEY_SPACE: 32,


        _destroy: function () {
            document.removeEventListener("keydown", this._keyDownListener);
            document.removeEventListener("keyup", this._keyUpListener);
        }
    });

})();
;/**
 * Components for defining light sources.
 *
 * @module XEO
 * @submodule lighting
 */;/**
 A **Lights** defines a group of light sources that illuminate attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 A Lights may contain a virtually unlimited number of three types of light source:

 <ul>
 <li>{{#crossLink "AmbientLight"}}AmbientLight{{/crossLink}}s, which are fixed-intensity and fixed-color, and
 affect all the {{#crossLink "Entity"}}Entities{{/crossLink}} equally,</li>
 <li>{{#crossLink "PointLight"}}PointLight{{/crossLink}}s, which emit light that
 originates from a single point and spreads outward in all directions, and </li>
 <li>{{#crossLink "DirLight"}}DirLight{{/crossLink}}s, which illuminate all the
 {{#crossLink "Entity"}}Entities{{/crossLink}} equally from a given direction</li>
 </ul>

 <img src="../../../assets/images/Lights.png"></img>

 ## Example

 In this example we have an {{#crossLink "Entity"}}{{/crossLink}} that has a {{#crossLink "Geometry"}}{{/crossLink}},
 a {{#crossLink "PhongMaterial"}}{{/crossLink}} and a {{#crossLink "Lights"}}{{/crossLink}}. The {{#crossLink "Lights"}}{{/crossLink}}
 contains an {{#crossLink "AmbientLight"}}{{/crossLink}}, a {{#crossLink "DirLight"}}{{/crossLink}} and a {{#crossLink "PointLight"}}{{/crossLink}}.


 ```` javascript
 var scene = new XEO.Scene();

 var material = new XEO.PhongMaterial(scene, {
    ambient:    [0.3, 0.3, 0.3],
    diffuse:    [0.7, 0.7, 0.7],
    specular:   [1. 1, 1],
    shininess:  30
});

 var ambientLight = new XEO.AmbientLight(scene, {
    color: [0.7, 0.7, 0.7],
    intensity:   1.0
});

 var dirLight = new XEO.DirLight(scene, {
    dir:        [-1, -1, -1],
    color:    [0.5, 0.7, 0.5],
    intensity:   1.0,
    space:      "view"
});

 var pointLight = new XEO.PointLight(scene, {
    pos: [0, 100, 100],
    color: [0.5, 0.7, 0.5],
    intensity: [1.0, 1.0, 1.0],
    constantAttenuation: 0,
    linearAttenuation: 0,
    quadraticAttenuation: 0,
    space: "view"
});

 var lights = new XEO.Lights(scene, {
    lights: [
        ambientLight,
        dirLight,
        pointLight
    ]
});

 var geometry = new XEO.Geometry(scene);  // Defaults to a 2x2x2 box

 var entity = new XEO.Entity(scene, {
    lights: lights,
    material: material,
    geometry: geometry
});
 ````


 @class Lights
 @constructor
 @module XEO
 @submodule lighting
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Lights in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Lights.
 @param [cfg.lights] {{Array of String|Entity}} Array of light source IDs or instances.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Lights = XEO.Component.extend({

        type: "XEO.Lights",

        _init: function (cfg) {

            // Renderer state contains the states of the child light source components
            this._state = new XEO.renderer.Lights({
                lights: [],
                hash: ""
            });

            this._dirty = true;

            // Array of child light source components
            this._lights = [];

            // Subscriptions to "dirty" events from child light source components
            this._dirtySubs = [];

            // Subscriptions to "destroyed" events from child light source components
            this._destroyedSubs = [];

            // Add initial light source components
            this.lights = cfg.lights;
        },

        _props: {

            /**
             The light sources in this Lights.

             Fires a {{#crossLink "Lights/lights:event"}}{{/crossLink}} event on change.

             @property lights
             @default []
             @type {{Array of AmbientLight, PointLight and DirLight}}
             */
            lights: {

                set: function (value) {

                    value = value || [];

                    var light;
                    var i;
                    var len;

                    // Unsubscribe from events on old lights

                    for (i = 0, len = this._lights.length; i < len; i++) {

                        light = this._lights[i];

                        light.off(this._dirtySubs[i]);
                        light.off(this._destroyedSubs[i]);
                    }

                    this._lights = [];

                    this._dirtySubs = [];
                    this._destroyedSubs = [];

                    var self = this;

                    function lightDirty() {
                        self.fire("dirty", true);
                    }

                    function lightDestroyed() {

                        var id = this.id; // Light ID

                        for (var i = 0, len = self._lights.length; i < len; i++) {

                            if (self._lights[i].id === id) {

                                self._lights = self._lights.slice(i, i + 1);
                                self._dirtySubs = self._dirtySubs.slice(i, i + 1);
                                self._destroyedSubs = self._destroyedSubs.slice(i, i + 1);

                                self._dirty = true;

                                self.fire("dirty", true);
                                self.fire("lights", self._lights);

                                return;
                            }
                        }
                    }

                    for (i = 0, len = value.length; i < len; i++) {

                        light = value[i];

                        if (XEO._isNumeric(light) || XEO._isString(light)) {

                            // ID given for light - find the light component

                            var id = light;

                            light = this.scene.components[id];

                            if (!light) {
                                this.error("Component not found: " + XEO._inQuotes(id));
                                continue;
                            }
                        }

                        var type = light.type;

                        if (type !== "XEO.AmbientLight" && type != "XEO.DirLight" && type != "XEO.PointLight") {
                            this.error("Component " + XEO._inQuotes(light.id) + " is not an XEO.AmbientLight, XEO.DirLight or XEO.PointLight ");
                            continue;
                        }

                        this._lights.push(light);

                        this._dirtySubs.push(light.on("dirty", lightDirty));

                        this._destroyedSubs.push(light.on("destroyed", lightDestroyed));
                    }

                    this._dirty = true;

                    this.fire("dirty", true);
                    this.fire("lights", this._lights);
                },

                get: function () {
                    return this._lights;
                }
            }
        },

        _compile: function () {

            var state = this._state;

            if (this._dirty) {

                state.lights = [];

                for (var i = 0, len = this._lights.length; i < len; i++) {
                    state.lights.push(this._lights[i]._state);
                }

                this._makeHash();

                this._dirty = false;
            }

            this._renderer.lights = state;
        },

        _makeHash: function () {

            var lights = this._state.lights;

            if (lights.length === 0) {
                return ";";
            }

            var hash = [];
            var light;

            for (var i = 0, len = lights.length; i < len; i++) {

                light = lights[i];

                hash.push(light.type);
                hash.push((light.space === "world") ? "w" : "v");
            }

            hash.push(";");

            this._state.hash = hash.join("");
        },

        _getJSON: function () {

            var lightIds = [];

            for (var i = 0, len = this._lights.length; i < len; i++) {
                lightIds.push(this._lights[i].id);
            }

            return {
                lights: lightIds
            };
        },

        _destroy: function () {

            var i;
            var len;
            var light;

            for (i = 0, len = this._lights.length; i < len; i++) {

                light = this._lights[i];

                light.off(this._dirtySubs[i]);
                light.off(this._destroyedSubs[i]);
            }

            this._state.destroy();
        }
    });
})();
;/**

 An **AmbientLight** defines an ambient light source of fixed intensity and color that affects all attached {{#crossLink "Entity"}}Entities{{/crossLink}}
 equally.

 <ul>
 <li>AmbientLights are grouped, along with other light source types, within
 {{#crossLink "Lights"}}Lights{{/crossLink}} components, which are attached to {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>
 <li>When the {{#crossLink "Entity"}}Entities{{/crossLink}} have {{#crossLink "PhongMaterial"}}PhongMaterials{{/crossLink}},
 AmbientLight {{#crossLink "AmbientLight/color:property"}}color{{/crossLink}} is multiplied by
 {{#crossLink "PhongMaterial"}}PhongMaterial{{/crossLink}} {{#crossLink "PhongMaterial/ambient:property"}}{{/crossLink}}.</li>
 <li>See <a href="Shader.html#inputs">Shader Inputs</a> for the variables that AmbientLights create within xeoEngine's shaders.</li>
 </ul>

 <img src="../../../assets/images/AmbientLight.png"></img>

 ### Example

 In this example we have
 <ul>
 <li>a {{#crossLink "PhongMaterial"}}{{/crossLink}},</li>
 <li>an AmbientLight,</li>
 <li>a {{#crossLink "Lights"}}{{/crossLink}} containing the AmbientLight,</li>
 <li>a {{#crossLink "Geometry"}}{{/crossLink}} that is the default box shape, and
 <li>an {{#crossLink "Entity"}}{{/crossLink}} attached to all of the above.</li>
 </ul>

 ```` javascript
 var scene = new XEO.Scene();

 var material = new XEO.PhongMaterial(scene, {
    ambient: [0.3, 0.3, 0.3],
    diffuse: [1, 1, 1],
    specular: [1.1, 1],
    shininess: 30
 });

 // Within xeoEngine's lighting calculations, the AmbientLight's
 // ambient color will be multiplied by the Material's ambient color

 var ambientLight = new XEO.AmbientLight(scene, {
    color: [0.7, 0.7, 0.7]
 });

 var lights = new XEO.Lights(scene, {
    lights: [
        ambientLight
    ]
 });

 var geometry = new XEO.Geometry(scene);  // Defaults to a 2x2x2 box

 var entity = new XEO.Entity(scene, {
    lights: lights,
    material: material,
    geometry: geometry
 });

 ````
 As with all components, we can observe and change properties on AmbientLights like so:

 ````Javascript
 // Attach a change listener to a property
 var handle = ambientLight.on("color",
 function(value) {
            // Property value has changed
    });


 ambientLight.color = [0.6, 0.6, 0.6]; // Fires the change listener


 ambientLight.off(handle); // Detach the change listener
 ````

 @class AmbientLight
 @module XEO
 @submodule lighting
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this AmbientLight within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted
 @param [cfg] {*} AmbientLight configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this AmbientLight.
 @param [cfg.color=[0.7, 0.7, 0.8]] {Array(Number)} The color of this AmbientLight.
 @extends Component
 */
(function () {

    "use strict";

    XEO.AmbientLight = XEO.Component.extend({

        type: "XEO.AmbientLight",

        _init: function (cfg) {

            this._state = {
                type: "ambient",
                color: [0.7, 0.7, 0.7],
                intensity: 1.0
            };

            this.color = cfg.color;
            this.intensity = cfg.intensity;
        },

        _props: {

            /**
             The color of this AmbientLight.

             Fires an {{#crossLink "AmbientLight/color:event"}}{{/crossLink}} event on change.

             @property color
             @default [0.7, 0.7, 0.8]
             @type Array(Number)
             */
            color: {

                set: function (value) {

                    this._state.color = value || [ 0.7, 0.7, 0.8 ];

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this AmbientLight's {{#crossLink "AmbientLight/color:property"}}{{/crossLink}} property changes.

                     @event color
                     @param value The property's new value
                     */
                    this.fire("color", this._state.color);
                },

                get: function () {
                    return this._state.color;
                }
            },

            /**
             The intensity of this AmbientLight.

             Fires a {{#crossLink "AmbientLight/intensity:event"}}{{/crossLink}} event on change.

             @property intensity
             @default 1.0
             @type Number
             */
            intensity: {

                set: function (value) {

                    this._state.intensity = value !== undefined ? value :  1.0;

                    this._renderer.imageDirty = true;

                    /**
                     * Fired whenever this AmbientLight's  {{#crossLink "AmbientLight/intensity:property"}}{{/crossLink}} property changes.
                     * @event intensity
                     * @param value The property's new value
                     */
                    this.fire("intensity", this._state.intensity);
                },

                get: function () {
                    return this._state.intensity;
                }
            }
        },

        _getJSON: function () {
            return {
                color: this._state.color,
                intensity: this._state.intensity
            };
        }
    });

})();
;/**
 A **DirLight** is a directional light source that illuminates all attached {{#crossLink "Entity"}}Entities{{/crossLink}} equally
 from a given direction.

 ## Overview

 <ul>
 <li>DirLights are grouped, along with other light source types, within {{#crossLink "Lights"}}Lights{{/crossLink}} components,
 which are attached to {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>
 <li>DirLights have a direction, but no position.</li>
 <li>DirLights may be defined in either **World** or **View** coordinate space. When in World-space, their direction
 is relative to the World coordinate system, and will appear to move as the {{#crossLink "Camera"}}{{/crossLink}} moves.
 When in View-space, their direction is relative to the View coordinate system, and will behave as if fixed to the viewer's
 head as the {{#crossLink "Camera"}}{{/crossLink}} moves.</li>
 <li>See <a href="Shader.html#inputs">Shader Inputs</a> for the variables that DirLights create within xeoEngine's shaders.</li>
 </ul>

 <img src="../../../assets/images/DirLight.png"></img>

 ## Example

 ```` javascript
 var entity = new XEO.Entity({

    lights: new XEO.Lights({
        lights: [
            new XEO.DirLight(scene, {
                dir:         [-1, -1, -1],
                color:       [0.5, 0.7, 0.5],
                intensity:   1.0,
                space:      "view"  // Other option is "world", for World-space
            })
        ]
    }),

    material: new XEO.PhongMaterial({
        ambient:    [0.3, 0.3, 0.3],
        diffuse:    [0.7, 0.7, 0.7],
        specular:   [1. 1, 1],
        shininess:  30
    }),

    geometry: new XEO.BoxGeometry()
});
 ````

 @class DirLight
 @module XEO
 @submodule lighting
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this DirLight within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted
 @param [cfg] {*} The DirLight configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this DirLight.
 @param [cfg.dir=[1.0, 1.0, 1.0]] {Array(Number)} A unit vector indicating the direction of illumination, given in either World or View space, depending on the value of the **space** parameter.
 @param [cfg.color=[0.7, 0.7, 0.8 ]] {Array(Number)} The color of this DirLight.
 @param [cfg.intensity=1.0 ] {Number} The intensity of this DirLight.
 @param [cfg.space="view"] {String} The coordinate system the DirLight is defined in - "view" or "space".

 @extends Component
 */
(function () {

    "use strict";

    XEO.DirLight = XEO.Component.extend({

        type: "XEO.DirLight",

        _init: function (cfg) {

            this._state = {
                type: "dir",
                dir: [0,0,-1],
                color: [0.7, 0.7, 0.8],
                intensity: 1.0,
                space: "view"
            };

            this.dir = cfg.dir;
            this.color = cfg.color;
            this.intensity = cfg.intensity;
            this.space = cfg.space;
        },

        _props: {

            /**
             The direction of this DirLight.

             Fires a {{#crossLink "DirLight/dir:event"}}{{/crossLink}} event on change.

             @property dir
             @default [1.0, 1.0, 1.0]
             @type Array(Number)
             */
            dir: {

                set: function (value) {

                    value = value || [ 1.0, 1.0, 1.0 ];

                    var dir = this._state.dir;

                    dir[0] = value[0];
                    dir[1] = value[1];
                    dir[2] = value[2];

                    this._renderer.imageDirty = true;

                    /**
                     * Fired whenever this DirLight's  {{#crossLink "DirLight/dir:property"}}{{/crossLink}} property changes.
                     * @event dir
                     * @param value The property's new value
                     */
                    this.fire("dir", dir);
                },

                get: function () {
                    return this._state.dir;
                }
            },

            /**
             The color of this DirLight.

             Fires a {{#crossLink "DirLight/color:event"}}{{/crossLink}} event on change.

             @property color
             @default [0.7, 0.7, 0.8]
             @type Array(Number)
             */
            color: {

                set: function (value) {

                    value = value || [0.7, 0.7, 0.8 ];

                    var color = this._state.color;

                    color[0] = value[0];
                    color[1] = value[1];
                    color[2] = value[2];

                    this._renderer.imageDirty = true;

                    /**
                     * Fired whenever this DirLight's  {{#crossLink "DirLight/color:property"}}{{/crossLink}} property changes.
                     * @event color
                     * @param value The property's new value
                     */
                    this.fire("color", color);
                },

                get: function () {
                    return this._state.color;
                }
            },

            /**
             The intensity of this DirLight.

             Fires a {{#crossLink "DirLight/intensity:event"}}{{/crossLink}} event on change.

             @property intensity
             @default 1.0
             @type Number
             */
            intensity: {

                set: function (value) {

                    value = value !== undefined ? value :  1.0;

                    this._state.intensity = value;

                    this._renderer.imageDirty = true;

                    /**
                     * Fired whenever this DirLight's  {{#crossLink "DirLight/intensity:property"}}{{/crossLink}} property changes.
                     * @event intensity
                     * @param value The property's new value
                     */
                    this.fire("intensity", this._state.intensity);
                },

                get: function () {
                    return this._state.intensity;
                }
            },

            /**
             Specifies which coordinate space this DirLight is in.

             Supported values are:

             <ul>
             <li>"view" - View space, aligned within the view volume as if fixed to the viewer's head</li>
             <li>"world" - World space, fixed within the world, moving within the view volume with respect to camera</li>
             </ul>

             Fires a {{#crossLink "DirLight/space:event"}}{{/crossLink}} event on change.

             @property space
             @default "view"
             @type String
             */
            space: {

                set: function (value) {

                    this._state.space = value || "view";

                    this.fire("dirty", true); // Need to rebuild shader

                    /**
                     * Fired whenever this DirLight's {{#crossLink "DirLight/space:property"}}{{/crossLink}} property changes.
                     * @event space
                     * @param value The property's new value
                     */
                    this.fire("space", this._state.space);
                },

                get: function () {
                    return this._state.space;
                }
            }
        },

        _getJSON: function () {
            return {
                type: this._state.type,
                dir: this._state.dir,
                color: this._state.color,
                intensity: this._state.intensity,
                space: this._state.space
            };
        }
    });

})();
;/**
 A **PointLight** defines a positional light source that originates from a single point and spreads outward in all directions, to illuminate
 attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>

 <li>PointLights are grouped, along with other light source types, within {{#crossLink "Lights"}}Lights{{/crossLink}} components,
 which are attached to {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>

 <li>PointLights have a position, but no direction.</li>

 <li>PointLights may be defined in either **World** or **View** coordinate space. When in World-space, their positions
 are relative to the World coordinate system, and will appear to move as the {{#crossLink "Camera"}}{{/crossLink}} moves.
 When in View-space, their positions are relative to the View coordinate system, and will behave as if fixed to the viewer's
 head as the {{#crossLink "Camera"}}{{/crossLink}} moves.</li>

 <li>PointLights have {{#crossLink "PointLight/constantAttenuation:property"}}{{/crossLink}}, {{#crossLink "PointLight/linearAttenuation:property"}}{{/crossLink}} and
 {{#crossLink "PointLight/quadraticAttenuation:property"}}{{/crossLink}} factors, which indicate how their intensity attenuates over distance.</li>

 <li>See <a href="Shader.html#inputs">Shader Inputs</a> for the variables that PointLights create within xeoEngine's shaders.</li>

 </ul>

 <img src="../../../assets/images/PointLight.png"></img>

 ## Example

 ```` javascript
 var entity = new XEO.Entity(scene, {

        lights: new XEO.Lights({
            lights: [
                new XEO.PointLight({
                    pos: [0, 100, 100],
                    color: [0.5, 0.7, 0.5],
                    intensity: 1
                    constantAttenuation: 0,
                    linearAttenuation: 0,
                    quadraticAttenuation: 0,
                    space: "view"
                })
            ]
        }),
 ,
        material: new XEO.PhongMaterial({
            diffuse: [0.5, 0.5, 0.0]
        }),

        geometry: new XEO.BoxGeometry()
  });

 // Update the light's color
 entity.lights.lights[0].color[0] = 1.0;

 ````

 @class PointLight
 @module XEO
 @submodule lighting
 @constructor
 @extends Component
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this PointLight within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted
 @param [cfg] {*} The PointLight configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this PointLight.
 @param [cfg.pos=[ 1.0, 1.0, 1.0 ]] {Array(Number)} Position, in either World or View space, depending on the value of the **space** parameter.
 @param [cfg.color=[0.7, 0.7, 0.8 ]] {Array(Number)} Color of this PointLight.
 @param [cfg.intensity=1.0] {Number} Intensity of this PointLight.
 @param [cfg.constantAttenuation=0] {Number} Constant attenuation factor.
 @param [cfg.linearAttenuation=0] {Number} Linear attenuation factor.
 @param [cfg.quadraticAttenuation=0] {Number} Quadratic attenuation factor.
 @param [cfg.space="view"] {String} The coordinate system this PointLight is defined in - "view" or "world".
 */
(function () {

    "use strict";

    XEO.PointLight = XEO.Component.extend({

        type: "XEO.PointLight",

        _init: function (cfg) {

            this._state = {
                type: "point",
                pos: [1.0, 1.0, 1.0],
                color: [0.7, 0.7, 0.8],
                intensity:   1.0,

                // Packaging constant, linear and quadratic attenuation terms
                // into an array for easy insertion into shaders as a vec3
                attenuation: [0.0, 0.0, 0.0],
                space: "view"
            };

            this.pos = cfg.pos;
            this.color = cfg.color;
            this.intensity = cfg.intensity;
            this.constantAttenuation = cfg.constantAttenuation;
            this.linearAttenuation = cfg.linearAttenuation;
            this.quadraticAttenuation = cfg.quadraticAttenuation;
            this.space = cfg.space;
        },

        _props: {

            /**
             The position of this PointLight.

             This will be either World- or View-space, depending on the value of {{#crossLink "PointLight/space:property"}}{{/crossLink}}.

             Fires a {{#crossLink "PointLight/pos:event"}}{{/crossLink}} event on change.

             @property pos
             @default [1.0, 1.0, 1.0]
             @type Array(Number)
             */
            pos: {

                set: function (value) {

                    this._state.pos = value || [ 1.0, 1.0, 1.0 ];

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this PointLight's  {{#crossLink "PointLight/pos:property"}}{{/crossLink}} property changes.
                     @event pos
                     @param value The property's new value
                     */
                    this.fire("pos", this._state.pos);
                },

                get: function () {
                    return this._state.pos;
                }
            },

            /**
             The color of this PointLight.

             Fires a {{#crossLink "PointLight/color:event"}}{{/crossLink}} event on change.

             @property color
             @default [0.7, 0.7, 0.8]
             @type Array(Number)
             */
            color: {

                set: function (value) {

                    this._state.color = value || [ 0.7, 0.7, 0.8 ];

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this PointLight's  {{#crossLink "PointLight/color:property"}}{{/crossLink}} property changes.
                     @event color
                     @param value The property's new value
                     */
                    this.fire("color", this._state.color);
                },

                get: function () {
                    return this._state.color;
                }
            },

            /**
             The intensity of this PointLight.

             Fires a {{#crossLink "PointLight/intensity:event"}}{{/crossLink}} event on change.

             @property intensity
             @default 1.0
             @type Number
             */
            intensity: {

                set: function (value) {

                    value = value !== undefined ? value :  1.0;

                    this._state.intensity = value;

                    this._renderer.imageDirty = true;

                    /**
                     * Fired whenever this PointLight's  {{#crossLink "PointLight/intensity:property"}}{{/crossLink}} property changes.
                     * @event intensity
                     * @param value The property's new value
                     */
                    this.fire("intensity", this._state.intensity);
                },

                get: function () {
                    return this._state.intensity;
                }
            },

            /**
             The constant attenuation factor for this PointLight.

             Fires a {{#crossLink "PointLight/constantAttenuation:event"}}{{/crossLink}} event on change.

             @property constantAttenuation
             @default 0
             @type Number
             */
            constantAttenuation: {

                set: function (value) {

                    this._state.attenuation[0] = value || 0.0;

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this PointLight's {{#crossLink "PointLight/constantAttenuation:property"}}{{/crossLink}} property changes.

                     @event constantAttenuation
                     @param value The property's new value
                     */
                    this.fire("constantAttenuation", this._state.attenuation[0]);
                },

                get: function () {
                    return this._state.attenuation[0];
                }
            },

            /**
             The linear attenuation factor for this PointLight.

             Fires a {{#crossLink "PointLight/linearAttenuation:event"}}{{/crossLink}} event on change.

             @property linearAttenuation
             @default 0
             @type Number
             */
            linearAttenuation: {

                set: function (value) {

                    this._state.attenuation[1] = value || 0.0;

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this PointLight's  {{#crossLink "PointLight/linearAttenuation:property"}}{{/crossLink}} property changes.

                     @event linearAttenuation
                     @param value The property's new value
                     */
                    this.fire("linearAttenuation", this._state.attenuation[1]);
                },

                get: function () {
                    return this._state.attenuation[1];
                }
            },

            /**
             The quadratic attenuation factor for this Pointlight.

             Fires a {{#crossLink "PointLight/quadraticAttenuation:event"}}{{/crossLink}} event on change.

             @property quadraticAttenuation
             @default 0
             @type Number
             */
            quadraticAttenuation: {

                set: function (value) {

                    this._state.attenuation[2] =  value || 0.0;

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this PointLight's {{#crossLink "PointLight/quadraticAttenuation:property"}}{{/crossLink}} property changes.

                     @event quadraticAttenuation
                     @param value The property's new value
                     */
                    this.fire("quadraticAttenuation", this._state.attenuation[2]);
                },

                get: function () {
                    return this._state.attenuation[2];
                }
            },

            /**
             Indicates which coordinate space this PointLight is in.

             Supported values are:

             <ul>
             <li>"view" - View space, aligned within the view volume as if fixed to the viewer's head</li>
             <li>"world" - World space, fixed within the world, moving within the view volume with respect to camera</li>
             </ul>

             Fires a {{#crossLink "PointLight/space:event"}}{{/crossLink}} event on change.

             @property space
             @default "view"
             @type String
             */
            space: {

                set: function (value) {

                    this._state.space = value || "view";

                    this.fire("dirty", true); // Need to rebuild shader

                    /**
                     Fired whenever this Pointlight's  {{#crossLink "PointLight/space:property"}}{{/crossLink}} property changes.

                     @event space
                     @param value The property's new value
                     */
                    this.fire("space", this._state.space);
                },

                get: function () {
                    return this._state.space;
                }
            }
        },

        _getJSON: function () {
            return {
                type: this._state.type,
                pos: this._state.pos,
                color: this._state.color,
                intensity: this._state.intensity,
                constantAttenuation: this._state.attenuation[0],
                linearAttenuation: this._state.attenuation[1],
                quadraticAttenuation: this._state.attenuation[2],
                space: this._state.space
            };
        }
    });

})();
;/**
 * Imports content from files.
 *
 * @module XEO
 * @submodule importing
 */;// Copyright (c) 2013 Fabrice Robinet
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
 The Abstract Loader has two modes:
 #1: [static] load all the JSON at once [as of now]
 #2: [stream] stream and parse JSON progressively [not yet supported]

 Whatever is the mechanism used to parse the JSON (#1 or #2),
 The loader starts by resolving the paths to binaries and referenced json files (by replace the value of the path property with an absolute path if it was relative).

 In case #1: it is guaranteed to call the concrete loader implementation methods in a order that solves the dependencies between the entries.
 only the nodes requires an extra pass to set up the hirerarchy.
 In case #2: the concrete implementation will have to solve the dependencies. no order is guaranteed.

 When case #1 is used the followed dependency order is:

 scenes -> nodes -> meshes -> materials -> techniques -> shaders
 -> buffers
 -> cameras
 -> lights

 The readers starts with the leafs, i.e:
 shaders, techniques, materials, meshes, buffers, cameras, lights, nodes, scenes

 For each called handle method called the client should return true if the next handle can be call right after returning,
 or false if a callback on client side will notify the loader that the next handle method can be called.

 */
var global = window;
(function (root, factory) {
    if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        factory(module.exports);
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function () {
            return factory(root);
        });
    } else {
        // Browser globals
        factory(root);
    }
}(this, function (root) {
    "use strict";

    var categoriesDepsOrder = ["extensions", "buffers", "bufferViews", "images",  "videos", "samplers", "textures", "shaders", "programs", "techniques", "materials", "accessors", "meshes", "cameras", "lights", "skins", "nodes", "scenes", "animations", ];

    var glTFParser = Object.create(Object.prototype, {

        _rootDescription: { value: null, writable: true },

        rootDescription: {
            set: function(value) {
                this._rootDescription = value;
            },
            get: function() {
                return this._rootDescription;
            }
        },

        baseURL: { value: null, writable: true },

        //detect absolute path following the same protocol than window.location
        _isAbsolutePath: {
            value: function(path) {
                var isAbsolutePathRegExp = new RegExp("^"+window.location.protocol, "i");

                return path.match(isAbsolutePathRegExp) ? true : false;
            }
        },

        resolvePathIfNeeded: {
            value: function(path) {
                if (this._isAbsolutePath(path)) {
                    return path;
                }

                var isDataUriRegex = /^data:/;
                if (isDataUriRegex.test(path)) {
                    return path;
                }

                return this.baseURL + path;
            }
        },

        _resolvePathsForCategories: {
            value: function(categories) {
                categories.forEach( function(category) {
                    var descriptions = this.json[category];
                    if (descriptions) {
                        var descriptionKeys = Object.keys(descriptions);
                        descriptionKeys.forEach( function(descriptionKey) {
                            var description = descriptions[descriptionKey];
                            description.uri = this.resolvePathIfNeeded(description.uri);
                        }, this);
                    }
                }, this);
            }
        },

        _json: {
            value: null,
            writable: true
        },

        json: {
            enumerable: true,
            get: function() {
                return this._json;
            },
            set: function(value) {
                if (this._json !== value) {
                    this._json = value;
                    this._resolvePathsForCategories(["buffers", "shaders", "images", "videos"]);
                }
            }
        },

        _path: {
            value: null,
            writable: true
        },

        getEntryDescription: {
            value: function (entryID, entryType) {
                var entries = null;

                var category = entryType;
                entries = this.rootDescription[category];
                if (!entries) {
                    console.log("ERROR:CANNOT find expected category named:"+category);
                    return null;
                }

                return entries ? entries[entryID] : null;
            }
        },

        _stepToNextCategory: {
            value: function() {
                this._state.categoryIndex = this.getNextCategoryIndex(this._state.categoryIndex + 1);
                if (this._state.categoryIndex !== -1) {
                    this._state.categoryState.index = 0;
                    return true;
                }

                return false;
            }
        },

        _stepToNextDescription: {
            enumerable: false,
            value: function() {
                var categoryState = this._state.categoryState;
                var keys = categoryState.keys;
                if (!keys) {
                    console.log("INCONSISTENCY ERROR");
                    return false;
                }

                categoryState.index++;
                categoryState.keys = null;
                if (categoryState.index >= keys.length) {
                    return this._stepToNextCategory();
                }
                return false;
            }
        },

        hasCategory: {
            value: function(category) {
                return this.rootDescription[category] ? true : false;
            }
        },

        _handleState: {
            value: function() {

                var methodForType = {
                    "buffers" : this.handleBuffer,
                    "bufferViews" : this.handleBufferView,
                    "shaders" : this.handleShader,
                    "programs" : this.handleProgram,
                    "techniques" : this.handleTechnique,
                    "materials" : this.handleMaterial,
                    "meshes" : this.handleMesh,
                    "cameras" : this.handleCamera,
                    "lights" : this.handleLight,
                    "nodes" : this.handleNode,
                    "scenes" : this.handleScene,
                    "images" : this.handleImage,
                    "animations" : this.handleAnimation,
                    "accessors" : this.handleAccessor,
                    "skins" : this.handleSkin,
                    "samplers" : this.handleSampler,
                    "textures" : this.handleTexture,
                    "videos" : this.handleVideo,
                    "extensions" : this.handleExtension
                };

                var success = true;
                while (this._state.categoryIndex !== -1) {
                    var category = categoriesDepsOrder[this._state.categoryIndex];
                    var categoryState = this._state.categoryState;
                    var keys = categoryState.keys;
                    if (!keys) {
                        categoryState.keys = keys = Object.keys(this.rootDescription[category]);
                        if (keys) {
                            if (keys.length == 0) {
                                this._stepToNextDescription();
                                continue;
                            }
                        }
                    }

                    var type = category;
                    var entryID = keys[categoryState.index];
                    var description = this.getEntryDescription(entryID, type);
                    if (!description) {
                        if (this.handleError) {
                            this.handleError("INCONSISTENCY ERROR: no description found for entry "+entryID);
                            success = false;
                            break;
                        }
                    } else {

                        if (methodForType[type]) {
                            if (methodForType[type].call(this, entryID, description, this._state.userInfo) === false) {
                                success = false;
                                break;
                            }
                        }

                        this._stepToNextDescription();
                    }
                }

                if (this.handleLoadCompleted) {
                    this.handleLoadCompleted(success);
                }

            }
        },

        _loadJSONIfNeeded: {
            enumerable: true,
            value: function(callback) {
                var self = this;
                //FIXME: handle error
                if (!this._json)  {
                    var jsonPath = this._path;
                    var i = jsonPath.lastIndexOf("/");
                    this.baseURL = (i !== 0) ? jsonPath.substring(0, i + 1) : '';
                    var jsonfile = new XMLHttpRequest();
                    jsonfile.open("GET", jsonPath, true);
                    jsonfile.onreadystatechange = function() {
                        if (jsonfile.readyState == 4) {
                            if (jsonfile.status == 200) {
                                self.json = JSON.parse(jsonfile.responseText);
                                if (callback) {
                                    callback(self.json);
                                }
                            }
                        }
                    };
                    jsonfile.send(null);
                } else {
                    if (callback) {
                        callback(this.json);
                    }
                }
            }
        },

        /* load JSON and assign it as description to the reader */
        _buildLoader: {
            value: function(callback) {
                var self = this;
                function JSONReady(json) {
                    self.rootDescription = json;
                    if (callback)
                        callback(this);
                }

                this._loadJSONIfNeeded(JSONReady);
            }
        },

        _state: { value: null, writable: true },

        _getEntryType: {
            value: function(entryID) {
                var rootKeys = categoriesDepsOrder;
                for (var i = 0 ;  i < rootKeys.length ; i++) {
                    var rootValues = this.rootDescription[rootKeys[i]];
                    if (rootValues) {
                        return rootKeys[i];
                    }
                }
                return null;
            }
        },

        getNextCategoryIndex: {
            value: function(currentIndex) {
                for (var i = currentIndex ; i < categoriesDepsOrder.length ; i++) {
                    if (this.hasCategory(categoriesDepsOrder[i])) {
                        return i;
                    }
                }

                return -1;
            }
        },

        load: {
            enumerable: true,
            value: function(userInfo, options) {
                var self = this;
                this._buildLoader(function loaderReady(reader) {
                    var startCategory = self.getNextCategoryIndex.call(self,0);
                    if (startCategory !== -1) {
                        self._state = { "userInfo" : userInfo,
                            "options" : options,
                            "categoryIndex" : startCategory,
                            "categoryState" : { "index" : "0" } };
                        self._handleState();
                    }
                });
            }
        },

        initWithPath: {
            value: function(path) {
                this._path = path;
                this._json = null;
                return this;
            }
        },

        //this is meant to be global and common for all instances
        _knownURLs: { writable: true, value: {} },

        //to be invoked by subclass, so that ids can be ensured to not overlap
        loaderContext: {
            value: function() {
                if (typeof this._knownURLs[this._path] === "undefined") {
                    this._knownURLs[this._path] = Object.keys(this._knownURLs).length;
                }
                return "__" + this._knownURLs[this._path];
            }
        },

        initWithJSON: {
            value: function(json, baseURL) {
                this.json = json;
                this.baseURL = baseURL;
                if (!baseURL) {
                    console.log("WARNING: no base URL passed to Reader:initWithJSON");
                }
                return this;
            }
        }

    });

    if(root) {
        root.glTFParser = glTFParser;
    }

    return glTFParser;

}));
;/**
 * Private xeoEngine glTF loading utilities.
 *
 * Adapted from the THREE loader by Tony Parisi (http://www.tonyparisi.com)
 * https://github.com/KhronosGroup/glTF/blob/master/loaders/threejs/glTFLoaderUtils.js
 */
XEO.GLTFLoaderUtils = Object.create(Object, {

    // errors

    // misc constants
    ARRAY_BUFFER: {value: "ArrayBuffer"},

    _streams: {value: {}, writable: true},

    _streamsStatus: {value: {}, writable: true},

    _resources: {value: {}, writable: true},

    _resourcesStatus: {value: {}, writable: true},

    // initialization
    init: {
        value: function () {
            this._streams = {};
            this._streamsStatus = {};
            this._resources = {};
            this._resourcesStatus = {};
        }
    },

    //manage entries
    _containsResource: {
        enumerable: false,
        value: function (resourceID) {
            return this._resources[resourceID] ? true : false;
        }
    },

    _storeResource: {
        enumerable: false,
        value: function (resourceID, resource) {
            if (!resourceID) {
                console.log("ERROR: entry does not contain id, cannot store");
                return;
            }

            if (this._containsResource[resourceID]) {
                console.log("WARNING: resource:" + resourceID + " is already stored, overriding");
            }

            this._resources[resourceID] = resource;
        }
    },

    _getResource: {
        enumerable: false,
        value: function (resourceID) {
            return this._resources[resourceID];
        }
    },

    _loadStream: {
        value: function (path, type, delegate) {


            var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;

            function decodeDataUriText(isBase64, data) {
                var result = decodeURIComponent(data);
                if (isBase64) {
                    return atob(result);
                }
                return result;
            }

            function decodeDataUriArrayBuffer(isBase64, data) {
                var byteString = decodeDataUriText(isBase64, data);
                var buffer = new ArrayBuffer(byteString.length);
                var view = new Uint8Array(buffer);
                for (var i = 0; i < byteString.length; i++) {
                    view[i] = byteString.charCodeAt(i);
                }
                return buffer;
            }

            function decodeDataUri(dataUriRegexResult, responseType) {
                responseType = typeof responseType !== 'undefined' ? responseType : '';
                var mimeType = dataUriRegexResult[1];
                var isBase64 = !!dataUriRegexResult[2];
                var data = dataUriRegexResult[3];

                switch (responseType) {
                    case '':
                    case 'text':
                        return decodeDataUriText(isBase64, data);
                    case 'ArrayBuffer':
                        return decodeDataUriArrayBuffer(isBase64, data);
                    case 'blob':
                        var buffer = decodeDataUriArrayBuffer(isBase64, data);
                        return new Blob([buffer], {
                            type: mimeType
                        });
                    case 'document':
                        var parser = new DOMParser();
                        return parser.parseFromString(decodeDataUriText(isBase64, data), mimeType);
                    case 'json':
                        return JSON.parse(decodeDataUriText(isBase64, data));
                    default:
                        throw 'Unhandled responseType: ' + responseType;
                }
            }

            var dataUriRegexResult = dataUriRegex.exec(path);
            if (dataUriRegexResult !== null) {
                delegate.streamAvailable(path, decodeDataUri(dataUriRegexResult, type));
                return;
            }

            var self = this;

            if (!type) {
                delegate.handleError(XEO.GLTFLoaderUtils.INVALID_TYPE, null);
                return;
            }

            if (!path) {
                delegate.handleError(XEO.GLTFLoaderUtils.INVALID_PATH);
                return;
            }

            var xhr = new XMLHttpRequest();
            xhr.open('GET', path, true);
            xhr.responseType = (type === this.ARRAY_BUFFER) ? "arraybuffer" : "text";

            //if this is not specified, 1 "big blob" scenes fails to load.
            xhr.setRequestHeader("If-Modified-Since", "Sat, 01 Jan 1970 00:00:00 GMT");
            xhr.onload = function (e) {
                if ((xhr.status == 200) || (xhr.status == 206)) {

                    delegate.streamAvailable(path, xhr.response);

                } else {
                    delegate.handleError(XEO.GLTFLoaderUtils.XMLHTTPREQUEST_STATUS_ERROR, this.status);
                }
            };
            xhr.send(null);
        }
    },

    send: {value: 0, writable: true},
    requested: {value: 0, writable: true},

    _handleRequest: {
        value: function (request) {
            var resourceStatus = this._resourcesStatus[request.id];
            if (resourceStatus) {
                this._resourcesStatus[request.id]++;
            }
            else {
                this._resourcesStatus[request.id] = 1;
            }

            var streamStatus = this._streamsStatus[request.uri];
            if (streamStatus && streamStatus.status === "loading") {
                streamStatus.requests.push(request);
                return;
            }

            this._streamsStatus[request.uri] = {status: "loading", requests: [request]};

            var self = this;
            var processResourceDelegate = {};

            processResourceDelegate.streamAvailable = function (path, res_) {
                var streamStatus = self._streamsStatus[path];
                var requests = streamStatus.requests;
                requests.forEach(function (req_) {
                    var subArray = res_.slice(req_.range[0], req_.range[1]);
                    var convertedResource = req_.delegate.convert(subArray, req_.ctx);
                    self._storeResource(req_.id, convertedResource);
                    req_.delegate.resourceAvailable(convertedResource, req_.ctx);
                    --self._resourcesStatus[req_.id];

                }, this);

                delete self._streamsStatus[path];

            };

            processResourceDelegate.handleError = function (errorCode, info) {
                request.delegate.handleError(errorCode, info);
            };

            this._loadStream(request.uri, request.type, processResourceDelegate);
        }
    },

    _elementSizeForGLType: {
        value: function (componentType, type) {

            var nElements = 0;
            switch (type) {
                case "SCALAR" :
                    nElements = 1;
                    break;
                case "VEC2" :
                    nElements = 2;
                    break;
                case "VEC3" :
                    nElements = 3;
                    break;
                case "VEC4" :
                    nElements = 4;
                    break;
                case "MAT2" :
                    nElements = 4;
                    break;
                case "MAT3" :
                    nElements = 9;
                    break;
                case "MAT4" :
                    nElements = 16;
                    break;
                default :
                    debugger;
                    break;
            }

            switch (componentType) {
                case WebGLRenderingContext.FLOAT :
                    return Float32Array.BYTES_PER_ELEMENT * nElements;
                case WebGLRenderingContext.UNSIGNED_BYTE :
                    return Uint8Array.BYTES_PER_ELEMENT * nElements;
                case WebGLRenderingContext.UNSIGNED_SHORT :
                    return Uint16Array.BYTES_PER_ELEMENT * nElements;
                default :
                    debugger;
                    return null;
            }
        }
    },

    _handleWrappedBufferViewResourceLoading: {
        value: function (wrappedBufferView, delegate, ctx) {
            var bufferView = wrappedBufferView.bufferView;
            var buffer = bufferView.buffer;
            var byteOffset = wrappedBufferView.byteOffset + bufferView.description.byteOffset;
            var range = [byteOffset, (this._elementSizeForGLType(wrappedBufferView.componentType, wrappedBufferView.type) * wrappedBufferView.count) + byteOffset];

            this._handleRequest({
                "id": wrappedBufferView.id,
                "range": range,
                "type": buffer.description.type,
                "uri": buffer.description.uri,
                "delegate": delegate,
                "ctx": ctx
            }, null);
        }
    },

    getBuffer: {

        value: function (wrappedBufferView, delegate, ctx) {

            var savedBuffer = this._getResource(wrappedBufferView.id);
            if (savedBuffer) {
                return savedBuffer;
            } else {
                this._handleWrappedBufferViewResourceLoading(wrappedBufferView, delegate, ctx);
            }

            return null;
        }
    },

    getFile: {

        value: function (request, delegate, ctx) {

            request.delegate = delegate;
            request.ctx = ctx;

            this._handleRequest({
                "id": request.id,
                "uri": request.uri,
                "range": [0],
                "type": "text",
                "delegate": delegate,
                "ctx": ctx
            }, null);

            return null;
        }
    },
});
;/**
 * Private xeoEngine glTF loader core.
 *
 * Adapted from the THREE loader by Tony Parisi (http://www.tonyparisi.com)
 * https://github.com/KhronosGroup/glTF/blob/master/loaders/threejs/glTFLoaderUtils.js
 */
(function () {

    "use strict";

    function log(type, entryId, description) {
        console.log(type + ": " + entryId + ": " + JSON.stringify(description, null, 4));
    }

    // Resource management

    var ResourceEntry = function (entryID, object, description) {
        this.entryID = entryID;
        this.object = object;
        this.description = description;
    };

    var Resources = function () {
        this._entries = {};
    };

    Resources.prototype.setEntry = function (entryID, object, description) {
        if (!entryID) {
            console.error("No EntryID provided, cannot store", description);
            return;
        }

        if (this._entries[entryID]) {
            console.warn("entry[" + entryID + "] is being overwritten");
        }

        this._entries[entryID] = new ResourceEntry(entryID, object, description);
    };

    Resources.prototype.getEntry = function (entryID) {
        return this._entries[entryID];
    };

    Resources.prototype.clearEntries = function () {
        this._entries = {};
    };

    // Delegate for processing index buffers
    var IndicesDelegate = function () {
    };

    IndicesDelegate.prototype.handleError = function (errorCode, info) {
        // FIXME: report error
        console.log("ERROR(IndicesDelegate):" + errorCode + ":" + info);
    };

    IndicesDelegate.prototype.convert = function (resource, ctx) {
        return new Uint16Array(resource, 0, ctx.indices.count);
    };

    IndicesDelegate.prototype.resourceAvailable = function (glResource, ctx) {
        var geometry = ctx.geometry;
        geometry.indices = glResource;
        //geometry.checkFinished();
        return true;
    };

    function componentsPerElementForGLType(type) {

        var nElements = 0;

        switch (type) {
            case "SCALAR" :
                nElements = 1;
                break;
            case "VEC2" :
                nElements = 2;
                break;
            case "VEC3" :
                nElements = 3;
                break;
            case "VEC4" :
                nElements = 4;
                break;
            case "MAT2" :
                nElements = 4;
                break;
            case "MAT3" :
                nElements = 9;
                break;
            case "MAT4" :
                nElements = 16;
                break;
            default :
                debugger;
                break;
        }

        return nElements;
    }

    var indicesDelegate = new IndicesDelegate();

    var IndicesContext = function (indices, geometry) {
        this.indices = indices;
        this.geometry = geometry;
    };

    // Delegate for processing vertex attribute buffers
    var VertexAttributeDelegate = function () {
    };

    VertexAttributeDelegate.prototype.handleError = function (errorCode, info) {
        // FIXME: report error
        console.log("ERROR(VertexAttributeDelegate):" + errorCode + ":" + info);
    };

    VertexAttributeDelegate.prototype.convert = function (resource, ctx) {
        return resource;
    };

    VertexAttributeDelegate.prototype.resourceAvailable = function (glResource, ctx) {

        var geometry = ctx.geometry;
        var attribute = ctx.attribute;
        var semantic = ctx.semantic;

        //FIXME: Float32 is assumed here, but should be checked.

        if (semantic == "POSITION") {
            geometry.positions = new Float32Array(glResource, 0, attribute.count * componentsPerElementForGLType(attribute.type));

        } else if (semantic == "NORMAL") {
            geometry.normals = new Float32Array(glResource, 0, attribute.count * componentsPerElementForGLType(attribute.type));

        } else if ((semantic == "TEXCOORD_0") || (semantic == "TEXCOORD" )) {
            geometry.uv = new Float32Array(glResource, 0, attribute.count * componentsPerElementForGLType(attribute.type));
        }

        geometry.loadedAttributes++;

        //geometry.checkFinished();

        return true;
    };

    var vertexAttributeDelegate = new VertexAttributeDelegate();

    var VertexAttributeContext = function (attribute, semantic, geometry) {
        this.attribute = attribute;
        this.semantic = semantic;
        this.geometry = geometry;
    };


    XEO.GLTFLoader = Object.create(glTFParser, {

        setCollection: {
            value: function (collection) {
                this.collection = collection;
            }
        },

        load: {
            enumerable: true,
            value: function (userInfo, options, ok) {

                if (!this.collection) {
                    throw "collection not set";
                }

                this.resources = new Resources();

                glTFParser.handleLoadCompleted = ok;
                glTFParser.load.call(this, userInfo, options);
            }
        },

        _makeID: {
            value: function (entryID) {
                // https://github.com/KhronosGroup/glTF/blob/master/specification/README.md#ids-and-names
                return this._path + "#" + entryID;
            }
        },

        handleBuffer: {
            value: function (entryID, description, userInfo) {
                this.resources.setEntry(entryID, null, description);
                description.type = "ArrayBuffer";
                return true;
            }
        },

        handleBufferView: {
            value: function (entryID, description, userInfo) {
                this.resources.setEntry(entryID, null, description);

                var buffer = this.resources.getEntry(description.buffer);
                description.type = "ArrayBufferView";

                var bufferViewEntry = this.resources.getEntry(entryID);
                bufferViewEntry.buffer = buffer;
                return true;
            }
        },

        handleAccessor: {
            value: function (entryID, description, userInfo) {
                this.resources.setEntry(entryID, description, description);
                return true;
            }
        },

        handleTexture: {
            value: function (entryID, description, userInfo) {

                if (!description.source) {
                    return;
                }

                var image = this._json.images[description.source];

                var texture = new XEO.Texture(this.collection.scene, {
                    src: image.uri
                });

                //   log("technique", entryID, description);
                this.resources.setEntry(entryID, texture, description);

                return true;
            }
        },

        handleMaterial: {
            value: function (entryID, description, userInfo) {

                //   log("material", entryID, description);

                var values = description.values || {};

                var diffuseVal = values.diffuse;
                var specularVal = values.specular;
                var shininessVal = values.shininess;
                var emissiveVal = values.emission;

                var cfg = {
                    id: this._makeID(entryID),
                    meta: {
                        userInfo: userInfo
                    },
                    shininess: shininessVal
                };

                var entry;

                if (diffuseVal) {
                    if (XEO._isString(diffuseVal)) {
                        entry = this.resources.getEntry(diffuseVal);
                        if (entry) {
                            cfg.diffuseMap = entry.object;
                        }
                    } else {
                        cfg.diffuse = diffuseVal.slice(0, 3);
                    }
                }

                if (specularVal) {
                    if (XEO._isString(specularVal)) {
                        entry = this.resources.getEntry(specularVal);
                        if (entry) {
                            cfg.specularMap = entry.object;
                        }
                    } else {
                        cfg.specular = specularVal.slice(0, 3);
                    }
                }

                if (emissiveVal) {
                    if (XEO._isString(emissiveVal)) {
                        entry = this.resources.getEntry(emissiveVal);
                        if (entry) {
                            cfg.emissiveMap = entry.object;
                        }
                    } else {
                        cfg.emissive = emissiveVal.slice(0, 3);
                    }
                }

                var material = new XEO.PhongMaterial(this.collection.scene, cfg);

                this.collection.add(material);

                this.resources.setEntry(entryID, material, description);

                return true;
            }
        },

        handleLight: {
            value: function (entryID, description, userInfo) {
                log("light", entryID, description);
                return true;
            }
        },

        handleMesh: {
            value: function (entryID, description, userInfo) {

                var mesh = [];

                this.resources.setEntry(entryID, mesh, description);

                var primitivesDescription = description.primitives;

                if (!primitivesDescription) {
                    //FIXME: not implemented in delegate
                    log("MISSING_PRIMITIVES for mesh:" + entryID);
                    return false;
                }

                for (var i = 0; i < primitivesDescription.length; i++) {
                    var primitiveDescription = primitivesDescription[i];

                    if (primitiveDescription.mode === WebGLRenderingContext.TRIANGLES) {

                        var geometry = new XEO.Geometry(this.collection.scene, {
                            id: this._makeID(entryID + "-geo" + i)
                        });

                        var materialEntry = this.resources.getEntry(primitiveDescription.material);
                        var material = materialEntry.object;

                        mesh.push({
                            geometry: geometry,
                            material: material
                        });

                        var allAttributes = Object.keys(primitiveDescription.attributes);

                        // count them first, async issues otherwise
                        allAttributes.forEach(function (semantic) {
                            geometry.totalAttributes++;
                        }, this);

                        var indices = this.resources.getEntry(primitiveDescription.indices);
                        var bufferEntry = this.resources.getEntry(indices.description.bufferView);
                        var indicesObject = {
                            bufferView: bufferEntry,
                            byteOffset: indices.description.byteOffset,
                            count: indices.description.count,
                            id: indices.entryID,
                            componentType: indices.description.componentType,
                            type: indices.description.type
                        };

                        var indicesContext = new IndicesContext(indicesObject, geometry);
                        var alreadyProcessedIndices = XEO.GLTFLoaderUtils.getBuffer(indicesObject, indicesDelegate, indicesContext);

                        // Load Vertex Attributes
                        allAttributes.forEach(function (semantic) {

                            var attribute;
                            var attributeID = primitiveDescription.attributes[semantic];
                            var attributeEntry = this.resources.getEntry(attributeID);
                            var bufferEntry;

                            if (!attributeEntry) {

                                //let's just use an anonymous object for the attribute
                                attribute = description.attributes[attributeID];
                                attribute.id = attributeID;
                                this.resources.setEntry(attributeID, attribute, attribute);

                                bufferEntry = this.resources.getEntry(attribute.bufferView);
                                attributeEntry = this.resources.getEntry(attributeID);

                            } else {
                                attribute = attributeEntry.object;
                                attribute.id = attributeID;
                                bufferEntry = this.resources.getEntry(attribute.bufferView);
                            }

                            var attributeObject = {
                                bufferView: bufferEntry,
                                byteOffset: attribute.byteOffset,
                                byteStride: attribute.byteStride,
                                count: attribute.count,
                                max: attribute.max,
                                min: attribute.min,
                                componentType: attribute.componentType,
                                type: attribute.type,
                                id: attributeID
                            };

                            var attribContext = new VertexAttributeContext(attributeObject, semantic, geometry);

                            var alreadyProcessedAttribute = XEO.GLTFLoaderUtils.getBuffer(attributeObject, vertexAttributeDelegate, attribContext);

                            /*if(alreadyProcessedAttribute) {
                             vertexAttributeDelegate.resourceAvailable(alreadyProcessedAttribute, attribContext);
                             }*/

                        }, this);
                    }
                }

                return true;
            }
        },

        handleCamera: {
            value: function (entryID, description, userInfo) {
                //log("camera", entryID, description);
                return true;
            }
        },

        handleScene: {
            value: function (entryID, description, userInfo) {

                var nodes = description.nodes;

                if (nodes) {

                    var node;
                    var transform;

                    for (var nodeId in nodes) {
                        if (nodes.hasOwnProperty(nodeId)) {

                            node = nodes [nodeId];
                            transform = null;

                            this._parseNode(node, transform);
                        }
                    }
                }
            }
        },

        _parseNode: {
            value: function (nodeId, transform) {

                var node = this._json.nodes[nodeId];

                if (!node) {
                    return;
                }

                if (node.matrix) {
                    var matrix = node.matrix;
                    transform = new XEO.Transform(this.collection.scene, {
                        //id: this._makeID(nodeId + ".transform"),
                        matrix: matrix,
                        parent: transform
                    });
                    this.collection.add(transform);
                }

                if (node.translation) {
                    var translation = node.translation;
                    transform = new XEO.Translate(this.collection.scene, {
                        //id: this._makeID(nodeId + ".translation"),
                        xyz: [translation[0], translation[1], translation[2]],
                        parent: transform
                    });
                    this.collection.add(transform);
                }

                if (node.rotation) {
                    var rotation = node.rotation;
                    transform = new XEO.Translate(this.collection.scene, {
                        //id: this._makeID(nodeId + ".rotation"),
                        xyz: [rotation[0], rotation[1], rotation[2]],
                        angle: rotation[3],
                        parent: transform
                    });
                    this.collection.add(transform);
                }

                if (node.scale) {
                    var scale = node.scale;
                    transform = new XEO.Scale(this.collection.scene, {
                        //id: this._makeID(nodeId + ".scale"),
                        xyz: [scale[0], scale[1], scale[2]],
                        parent: transform
                    });
                    this.collection.add(transform);
                }

                if (node.meshes) {

                    var meshes = node.meshes;
                    var imeshes;
                    var lenMeshes = meshes.length;
                    var mesh;
                    var material;
                    var geometry;
                    var entity;

                    for (imeshes = 0; imeshes < lenMeshes; imeshes++) {

                        mesh = this.resources.getEntry(meshes[imeshes]);

                        if (!mesh) {
                            continue;
                        }

                        mesh = mesh.object;

                        for (var i = 0, len = mesh.length; i < len; i++) {

                            material = mesh[i].material;
                            geometry = mesh[i].geometry;

                            entity = new XEO.Entity(this.collection.scene, {
                                //id: this._makeID(nodeId + ".entity" + i),
                                meta: {
                                    name: node.name
                                },
                                material: material,
                                geometry: geometry,
                                transform: transform
                            });

                            this.collection.add(entity);
                        }
                    }
                }

                if (node.children) {

                    var children = node.children;
                    var childNode;

                    for (var i = 0, len = children.length; i < len; i++) {
                        childNode = children[i];
                        this._parseNode(childNode, transform);
                    }
                }

                return true;
            }
        }
    });

})();;(function () {

    "use strict";

    var glTFLoader = XEO.GLTFLoader;

    /**
     A **Model** loads content from a <a href="https://github.com/KhronosGroup/glTF" target = "_other">glTF</a> file into its parent {{#crossLink "Scene"}}{{/crossLink}}.

     <ul><li>A Model begins loading as soon as it's {{#crossLink "Model/src:property"}}{{/crossLink}}
     property is set to the location of a valid glTF file.</li>
     <li>A Model keeps all its loaded components in a {{#crossLink "Collection"}}{{/crossLink}}.</li>
     <li>You can set a Model's {{#crossLink "Model/src:property"}}{{/crossLink}} property to a new file path at any time,
     which will cause it to load components from the new file, after destroying any components loaded previously.</li>
     </ul>

     <img src="../../../assets/images/Model.png"></img>

     ### Loading a glTF file

     First, create a Model, which immediately loads a glTF model into its {{#crossLink "Scene"}}{{/crossLink}} (which in this case is the default {{#crossLink "Scene"}}{{/crossLink}}, since we didn't explicitly configure the Model with one):

     ````javascript
     var gearboxModel = new XEO.Model({
        src: "models/gltf/gearbox/gearbox_assy.gltf"
     });
     ````

     We can bind a callback, to get notification when the Model has loaded, which will
     fire immediately if the Model happens to be loaded already:

     ````javascript
     gearboxModel.on("loaded",
     function() {
             // Model has loaded!
         });
     ````

     ### Iterating over loaded components

     The Model's {{#crossLink "Collection"}}{{/crossLink}} which now contains all the scene components
     it created while loading the glTF file.

     Let's iterate over the {{#crossLink "Collection"}}{{/crossLink}} and log the ID of each
     {{#crossLink "Entity"}}{{/crossLink}} we that find in there:

     ````javascript
     gearboxModel.collection.iterate(function(c) {
         if (c.type === "XEO.Entity") {
             this.log("Entity found: " + c.id);
         }
     });
     ````

     ### Getting the boundary of a Model

     To visualize the World-space boundary of a Model, we can create a {{#crossLink "CollectionBoundary"}}{{/crossLink}},
     generate a {{#crossLink "BoundaryGeometry"}}{{/crossLink}} from that, then create an {{#crossLink "Entity"}}{{/crossLink}}
     to visualize the {{#crossLink "BoundaryGeometry"}}{{/crossLink}}:

     ````javascript
     var collectionBoundary = new XEO.CollectionBoundary({
         collection: model.collection
     });

     var boundaryGeometry = new XEO.BoundaryGeometry({
         boundary: collectionBoundary.worldBoundary
     });

     // The Entity will be a red wireframe box indicating the
     // extents of the boundary

     new XEO.Entity({
         geometry: boundaryGeometry,
         material: new XEO.PhongMaterial({
             diffuse: [1,0,0]
         })
     });
     ````

     Now whenever we set the Model to a new file (see example below), the World-space boundary will automatically update accordingly, as will
     our boundary indicator {{#crossLink "Entity"}}{{/crossLink}}.

     ### Flying the Camera to look at a Model

     To position the Model entirely within view, we can use a {{#crossLink "CameraFlight"}}{{/crossLink}} to fly the {{#crossLink "Camera"}}{{/crossLink}} (in this case the default, implicit one) to look at the World-space extents of our {{#crossLink "CollectionBoundary"}}{{/crossLink}}:

     ````javascript
     var flight = new XEO.CameraFlight({
        duration: 1.5
     });

     flight.flyTo(collectionBoundary.worldBoundary,
     function() {
             // Optional callback to fire on arrival
         });

     ````

     ### Switching to a different glTF file

     Let's set the Model to a different file path:

     ````javascript
     gearboxModel.src = "models/gltf/buggy/buggy.gltf"
     ````

     Once loaded, the {{#crossLink "Collection"}}{{/crossLink}} will then contain an entirely different collection of scene
     components, created from this new glTF file.

     ### Destroying a Model

     Finally, a Model manages the lifecycle of it's components. Therefore, destroying a Model also destroys all the
     components it loaded:

     ````javascript
     gearboxModel.destroy();
     ````

     @class Model
     @module XEO
     @submodule importing
     @extends Component
     */
    XEO.Model = XEO.Component.extend({

        type: "XEO.Model",

        _init: function (cfg) {

            this._super(cfg);

            // The XEO.Collection that will hold all the components
            // we create from the glTF model; this will be available
            // as a public, immutable #collection property

            this._collection = new XEO.Collection(this.scene);

            this._src = null;

            if (!cfg.src) {
                this.error("Config missing: 'src'");
                return;
            }

            if (!XEO._isString(cfg.src)) {
                this.error("Value for config 'src' should be a string");
                return;
            }

            this.src = cfg.src;
        },

        _props: {

            /**
             Path to the glTF file.

             You can set this to a new file path at any time, which will cause the Model to load components from
             the new file (after first destroying any components loaded from a previous file path).

             Fires a {{#crossLink "Model/src:event"}}{{/crossLink}} event on change.

             @property src
             @type String
             */
            src: {

                set: function (value) {

                    if (!value) {
                        return;
                    }

                    if (!XEO._isString(value)) {
                        this.error("Value for 'src' should be a string");
                        return;
                    }

                    this._clear();

                    this._src = value;

                    glTFLoader.setCollection(this._collection);
                    glTFLoader.initWithPath(this._src);

                    var self = this;
                    var userInfo = null;
                    var options = null;

                    glTFLoader.load(userInfo, options,
                        function () {

                            /**
                             Fired whenever this Model has finished loading components from the glTF file
                             specified by {{#crossLink "Model/src:property"}}{{/crossLink}}.
                             @event loaded
                             */
                            self.fire("loaded");
                        });

                    /**
                     Fired whenever this Model's {{#crossLink "Model/src:property"}}{{/crossLink}} property changes.
                     @event src
                     @param value The property's new value
                     */
                    this.fire("src", this._src);
                },

                get: function () {
                    return this._src;
                }
            },

            /**
             * A {{#crossLink "Collection"}}{{/crossLink}} containing the scene components loaded by this Model.
             *
             * Whenever {{#crossLink "Model/src:property"}}{{/crossLink}} is set to the location of a valid glTF file,
             * and once the file has been loaded, this {{#crossLink "Collection"}}{{/crossLink}} will contain whatever
             * components were loaded from that file.
             *
             * Note that prior to loading the file, the Model will destroy any components in the {{#crossLink "Collection"}}{{/crossLink}}.
             *
             * @property collection
             * @type Collection
             * @final
             */
            collection: {

                get: function () {
                    return this._collection;
                }
            }
        },

        _clear: function () {

            var c = [];

            this._collection.iterate(
                function (component) {
                    c.push(component);
                });

            while (c.length) {
                c.pop().destroy();
            }
        },

        _getJSON: function () {
            return {
                src: this._src
            };
        },

        _destroy: function () {
            this._clear();
        }
    });


})();;/**
 * Components to define the surface appearance of Entities.
 *
 * @module XEO
 * @submodule materials
 */;/**
 A **Material** defines the surface appearance of attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 Material is the base class for:

 <ul>
 <li>{{#crossLink "PBRMaterial"}}{{/crossLink}} - Physically-based rendering (PBR) material.</li>
 <li>{{#crossLink "PhongMaterial"}}{{/crossLink}} - Blinn-Phong shading material.</li>
 <li>(more coming)</li>
 </ul>

 <img src="../../../assets/images/Material.png"></img>

 @class Material
 @module XEO
 @submodule materials
 @constructor
 @extends Component
 */
(function () {

    "use strict";

    XEO.Material = XEO.Component.extend({

        type: "XEO.Material",

        _init: function (cfg) {

        }
    });

})();
;/**
 A **PhongMaterial** is a {{#crossLink "Material"}}{{/crossLink}} that defines the surface appearance of
 attached {{#crossLink "Entity"}}Entities{{/crossLink}} using
 the <a href="http://en.wikipedia.org/wiki/Phong_reflection_model">Phong</a> lighting model.

 ## Overview

 <ul>

 <li>These PhongMaterial properties, along with {{#crossLink "PhongMaterial/emissive:property"}}{{/crossLink}},
 {{#crossLink "PhongMaterial/opacity:property"}}{{/crossLink}} and {{#crossLink "PhongMaterial/reflectivity:property"}}{{/crossLink}},
 specify attributes that are to be **applied uniformly** across the surface of attached {{#crossLink "Geometry"}}Geometries{{/crossLink}}.</li>

 <li>Most of those attributes can be textured, **effectively replacing the values set for those properties**, by
 assigning {{#crossLink "Texture"}}Textures{{/crossLink}} to the PhongMaterial's
 {{#crossLink "PhongMaterial/diffuseMap:property"}}{{/crossLink}}, {{#crossLink "PhongMaterial/specularMap:property"}}{{/crossLink}},
 {{#crossLink "PhongMaterial/emissiveMap:property"}}{{/crossLink}}, {{#crossLink "PhongMaterial/opacityMap:property"}}{{/crossLink}}
 and  {{#crossLink "PhongMaterial/reflectivityMap:property"}}{{/crossLink}} properties.</li>

 <li>For example, the value of {{#crossLink "PhongMaterial/diffuse:property"}}{{/crossLink}} will be ignored if your
 PhongMaterial also has a {{#crossLink "PhongMaterial/diffuseMap:property"}}{{/crossLink}} set to a {{#crossLink "Texture"}}Texture{{/crossLink}}.
 The {{#crossLink "Texture"}}Texture's{{/crossLink}} pixel colors directly provide the diffuse color of each fragment across the
 {{#crossLink "Geometry"}}{{/crossLink}} surface, ie. they are not multiplied by
 the {{#crossLink "PhongMaterial/diffuse:property"}}{{/crossLink}} for each pixel, as is done in many shading systems.</li>

 <li>When the {{#crossLink "Entity"}}{{/crossLink}}'s {{#crossLink "Geometry"}}{{/crossLink}} has a
 {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} set to "lines" or "points" then only the {{#crossLink "PhongMaterial"}}{{/crossLink}}'s
 {{#crossLink "PhongMaterial/emissive:property"}}{{/crossLink}}, {{#crossLink "PhongMaterial/emissiveMap:property"}}{{/crossLink}},
 {{#crossLink "PhongMaterial/opacity:property"}}{{/crossLink}} and {{#crossLink "PhongMaterial/opacityMap:property"}}{{/crossLink}}
 will actually be applied, since those primitive types cannot be shaded.</li>

 <li>See <a href="Shader.html#inputs">Shader Inputs</a> for the variables that PhongMaterials create within xeoEngine's shaders.</li>

 </ul>

 <img src="../../../assets/images/Material.png"></img>

 ## Example

 In this example we have

 <ul>
 <li>a {{#crossLink "Texture"}}{{/crossLink}},</li>
 <li>a {{#crossLink "Fresnel"}}{{/crossLink}},</li>
 <li>a {{#crossLink "PhongMaterial"}}{{/crossLink}} which applies the {{#crossLink "Texture"}}{{/crossLink}} as a diffuse map and the {{#crossLink "Fresnel"}}{{/crossLink}} as a specular Fresnel effect,</li>
 <li>a {{#crossLink "Lights"}}{{/crossLink}} containing an {{#crossLink "AmbientLight"}}{{/crossLink}} and a {{#crossLink "DirLight"}}{{/crossLink}},</li>
 <li>a {{#crossLink "Geometry"}}{{/crossLink}} that is the default box shape, and
 <li>an {{#crossLink "Entity"}}{{/crossLink}} attached to all of the above.</li>
 </ul>

 Note that the value for the {{#crossLink "PhongMaterial"}}PhongMaterial's{{/crossLink}} {{#crossLink "PhongMaterial/diffuse:property"}}{{/crossLink}}
 property is ignored and redundant, since we assign a {{#crossLink "Texture"}}{{/crossLink}} to the
 {{#crossLink "PhongMaterial"}}PhongMaterial's{{/crossLink}} {{#crossLink "PhongMaterial/diffuseMap:property"}}{{/crossLink}} property.
 The {{#crossLink "Texture"}}Texture's{{/crossLink}} pixel colors directly provide the diffuse color of each fragment across the
 {{#crossLink "Geometry"}}{{/crossLink}} surface.

 ```` javascript
 var scene = new XEO.Scene();

 var diffuseMap = new XEO.Texture(scene, {
    src: "diffuseMap.jpg"
 });

 var fresnel = new XEO.Fresnel(scene, {
    leftColor: [1.0, 1.0, 1.0],
    rightColor: [0.0, 0.0, 0.0],
    power: 4
 });

 var material = new XEO.PhongMaterial(scene, {
    ambient:         [0.3, 0.3, 0.3],
    diffuse:         [0.5, 0.5, 0.0],   // Ignored, since we have assigned a Texture to diffuseMap, below
    diffuseMap:      diffuseMap,
    specular:        [1, 1, 1],
    shininess:       80,
    specularFresnel: fresnel
 });

 var ambientLight = new XEO.AmbientLight(scene, {
    color: [0.7, 0.7, 0.7]
 });

 var dirLight = new XEO.DirLight(scene, {
    dir:        [-1, -1, -1],
    color:      [0.5, 0.7, 0.5],
    intensity:  [1.0, 1.0, 1.0],
    space:      "view"
 });

 var lights = new XEO.Lights(scene, {
    lights: [
        ambientLight,
        dirLight
    ]
 });

 var geometry = new XEO.Geometry(scene); // Geometry without parameters will default to a 2x2x2 box.

 var entity = new XEO.Entity(scene, {
    lights: lights,
    material: material,
    geometry: geometry
 });
 ````

 @class PhongMaterial
 @module XEO
 @submodule materials
 @constructor
 @extends Material
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this PhongMaterial within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted
 @param [cfg] {*} The PhongMaterial configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta=null] {String:Object} Metadata to attach to this PhongMaterial.
 @param [cfg.ambient=[0.7, 0.7, 0.8 ]] {Array of Number} PhongMaterial ambient color.
 @param [cfg.diffuse=[ 1.0, 1.0, 1.0 ]] {Array of Number} PhongMaterial diffuse color.
 @param [cfg.specular=[ 1.0, 1.0, 1.0 ]] {Array of Number} PhongMaterial specular color.
 @param [cfg.emissive=[ 0.0, 0.0, 0.0 ]] {Array of Number} PhongMaterial emissive color.
 @param [cfg.opacity=1] {Number} Scalar in range 0-1 that controls opacity, where 0 is completely transparent and 1 is completely opaque.
 Only applies while {{#crossLink "Modes"}}Modes{{/crossLink}} {{#crossLink "Modes/transparent:property"}}transparent{{/crossLink}} equals ````true````.
 @param [cfg.shininess=80] {Number} Scalar in range 0-128 that determines the size and sharpness of specular highlights.
 @param [cfg.reflectivity=1] {Number} Scalar in range 0-1 that controls how much {{#crossLink "CubeMap"}}CubeMap{{/crossLink}} is reflected.
 @param [cfg.lineWidth=1] {Number} Scalar that controls the width of lines for {{#crossLink "Geometry"}}{{/crossLink}} with {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} set to "lines".
 @param [cfg.pointSize=1] {Number} Scalar that controls the size of points for {{#crossLink "Geometry"}}{{/crossLink}} with {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} set to "points".
 @param [cfg.diffuseMap=null] {Texture} A diffuse map {{#crossLink "Texture"}}Texture{{/crossLink}}, which will override the effect of the diffuse property. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.specularMap=null] {Texture} A specular map {{#crossLink "Texture"}}Texture{{/crossLink}}, which will override the effect of the specular property. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.emissiveMap=null] {Texture} An emissive map {{#crossLink "Texture"}}Texture{{/crossLink}}, which will override the effect of the emissive property. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.normalMap=null] {Texture} A normal map {{#crossLink "Texture"}}Texture{{/crossLink}}. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.opacityMap=null] {Texture} An opacity map {{#crossLink "Texture"}}Texture{{/crossLink}}, which will override the effect of the opacity property. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.reflectivityMap=null] {Texture} A reflectivity control map {{#crossLink "Texture"}}Texture{{/crossLink}}, which will override the effect of the reflectivity property. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.diffuseFresnel=null] {Fresnel} A diffuse {{#crossLink "Fresnel"}}Fresnel{{/crossLink}}.
 @param [cfg.specularFresnel=null] {Fresnel} A specular {{#crossLink "Fresnel"}}Fresnel{{/crossLink}}.
 @param [cfg.emissiveFresnel=null] {Fresnel} An emissive {{#crossLink "Fresnel"}}Fresnel{{/crossLink}}.
 @param [cfg.opacityFresnel=null] {Fresnel} An opacity {{#crossLink "Fresnel"}}Fresnel{{/crossLink}}.
 @param [cfg.reflectivityFresnel=null] {Fresnel} A reflectivity {{#crossLink "Fresnel"}}Fresnel{{/crossLink}}.
 */
(function () {

    "use strict";

    XEO.PhongMaterial = XEO.Material.extend({

        type: "XEO.PhongMaterial",

        _init: function (cfg) {

            this._state = new XEO.renderer.PhongMaterial({

                type: "phongMaterial",

                ambient: [0.7, 0.7, 0.8],
                diffuse: [1.0, 1.0, 1.0],
                specular: [1.0, 1.0, 1.0],
                emissive: [0.0, 0.0, 0.0],

                opacity: 1.0,
                shininess: 20.0,
                reflectivity: 1.0,

                lineWidth: 1.0,
                pointSize: 1.0,

                ambientMap: null,
                normalMap: null,
                diffuseMap: null,
                specularMap: null,
                emissiveMap: null,
                opacityMap: null,
                reflectivityMap: null,

                diffuseFresnel: null,
                specularFresnel: null,
                emissiveFresnel: null,
                opacityFresnel: null,
                reflectivityFresnel: null,

                hash: null
            });

            this._hashDirty = true;

            this.on("dirty", function() {

                // This PhongMaterial is flagged dirty when a
                // child component fires "dirty", which always
                // means that a shader recompile will be needed.

                this._hashDirty = true;
            }, this);

            this.ambient = cfg.ambient;
            this.diffuse = cfg.diffuse;
            this.specular = cfg.specular;
            this.emissive = cfg.emissive;

            this.opacity = cfg.opacity;
            this.shininess = cfg.shininess;
            this.reflectivity = cfg.reflectivity;

            this.lineWidth = cfg.lineWidth;
            this.pointSize = cfg.pointSize;

            this.ambientMap = cfg.ambientMap;
            this.diffuseMap = cfg.diffuseMap;
            this.specularMap = cfg.specularMap;
            this.emissiveMap = cfg.emissiveMap;
            this.opacityMap = cfg.opacityMap;
            this.reflectivityMap = cfg.reflectivityMap;
            this.normalMap = cfg.normalMap;

            this.diffuseFresnel = cfg.diffuseFresnel;
            this.specularFresnel = cfg.specularFresnel;
            this.emissiveFresnel = cfg.emissiveFresnel;
            this.opacityFresnel = cfg.opacityFresnel;
            this.reflectivityFresnel = cfg.reflectivityFresnel;
        },

        _props: {

            /**
             The PhongMaterial's ambient color.

             Fires a {{#crossLink "PhongMaterial/ambient:event"}}{{/crossLink}} event on change.

             @property ambient
             @default [1.0, 1.0, 1.0]
             @type Array(Number)
             */
            ambient: {

                set: function (value) {

                    this._state.ambient = value || [1.0, 1.0, 1.0];

                    this._renderer.imageDirty = true;

                    /**
                     * Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/ambient:property"}}{{/crossLink}} property changes.
                     *
                     * @event ambient
                     * @param value {Array(Number)} The property's new value
                     */
                    this.fire("ambient", this._state.ambient);
                },

                get: function () {
                    return this._state.ambient;
                }
            },

            /**
             The PhongMaterial's diffuse color.

             This property may be overridden by {{#crossLink "PhongMaterial/diffuseMap:property"}}{{/crossLink}}.

             Fires a {{#crossLink "PhongMaterial/diffuse:event"}}{{/crossLink}} event on change.

             @property diffuse
             @default [1.0, 1.0, 1.0]
             @type Array(Number)
             */
            diffuse: {

                set: function (value) {

                    this._state.diffuse = value || [1.0, 1.0, 1.0];

                    this._renderer.imageDirty = true;

                    /**
                     * Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/diffuse:property"}}{{/crossLink}} property changes.
                     *
                     * @event diffuse
                     * @param value {Array(Number)} The property's new value
                     */
                    this.fire("diffuse", this._state.diffuse);
                },

                get: function () {
                    return this._state.diffuse;
                }
            },

            /**
             The material's specular color.

             This property may be overridden by {{#crossLink "PhongMaterial/specularMap:property"}}{{/crossLink}}.

             Fires a {{#crossLink "PhongMaterial/specular:event"}}{{/crossLink}} event on change.

             @property specular
             @default [1.0, 1.0, 1.0]
             @type Array(Number)
             */
            specular: {

                set: function (value) {

                    this._state.specular = value || [1.0, 1.0, 1.0];

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/specular:property"}}{{/crossLink}} property changes.

                     @event specular
                     @param value {Array(Number)} The property's new value
                     */
                    this.fire("specular", this._state.specular);
                },

                get: function () {
                    return this._state.specular;
                }
            },

            /**
             The PhongMaterial's emissive color.

             This property may be overridden by {{#crossLink "PhongMaterial/emissiveMap:property"}}{{/crossLink}}.

             Fires a {{#crossLink "PhongMaterial/emissive:event"}}{{/crossLink}} event on change.

             @property emissive
             @default [0.0, 0.0, 0.0]
             @type Array(Number)
             */
            emissive: {

                set: function (value) {

                    this._state.emissive = value || [0.0, 0.0, 0.0];

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/emissive:property"}}{{/crossLink}} property changes.

                     @event emissive
                     @param value {Array(Number)} The property's new value
                     */
                    this.fire("emissive", this._state.emissive);
                },

                get: function () {
                    return this._state.emissive;
                }
            },

            /**
             Factor in the range [0..1] indicating how transparent the PhongMaterial is.

             A value of 0.0 indicates fully transparent, 1.0 is fully opaque.

             Attached {{#crossLink "Entity"}}Entities{{/crossLink}} will appear transparent only if they are also attached
             to {{#crossLink "Modes"}}Modes{{/crossLink}} that have {{#crossLink "Modes/transparent:property"}}transparent{{/crossLink}}
             set to **true**.

             This property may be overridden by {{#crossLink "PhongMaterial/opacityMap:property"}}{{/crossLink}}.

             Fires an {{#crossLink "PhongMaterial/opacity:event"}}{{/crossLink}} event on change.

             @property opacity
             @default 1.0
             @type Number
             */
            opacity: {

                set: function (value) {

                    this._state.opacity = (value !== undefined && value !== null) ? value : 1.0;

                    this._renderer.imageDirty = true;

                    /**
                     * Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/opacity:property"}}{{/crossLink}} property changes.
                     *
                     * @event opacity
                     * @param value {Number} The property's new value
                     */
                    this.fire("opacity", this._state.opacity);
                },

                get: function () {
                    return this._state.opacity;
                }
            },

            /**
             A factor in range [0..128] that determines the size and sharpness of the specular highlights create by this PhongMaterial.

             Larger values produce smaller, sharper highlights. A value of 0.0 gives very large highlights that are almost never
             desirable. Try values close to 10 for a larger, fuzzier highlight and values of 100 or more for a small, sharp
             highlight.

             Fires a {{#crossLink "PhongMaterial/shininess:event"}}{{/crossLink}} event on change.

             @property shininess
             @default 80.0
             @type Number
             */
            shininess: {

                set: function (value) {

                    this._state.shininess = value !== undefined ? value : 80;

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/shininess:property"}}{{/crossLink}} property changes.

                     @event shininess
                     @param value Number The property's new value
                     */
                    this.fire("shininess", this._state.shininess);
                },

                get: function () {
                    return this._state.shininess;
                }
            },

            /**
             The PhongMaterial's line width.

             Fires a {{#crossLink "PhongMaterial/lineWidth:event"}}{{/crossLink}} event on change.

             @property lineWidth
             @default 1.0
             @type Number
             */
            lineWidth: {

                set: function (value) {

                    this._state.lineWidth = value || 1.0;

                    this._renderer.imageDirty = true;

                    /**
                     * Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/lineWidth:property"}}{{/crossLink}} property changes.
                     *
                     * @event lineWidth
                     * @param value {Array(Number)} The property's new value
                     */
                    this.fire("lineWidth", this._state.lineWidth);
                },

                get: function () {
                    return this._state.lineWidth;
                }
            },

            /**
             The PhongMaterial's point size.

             Fires a {{#crossLink "PhongMaterial/pointSize:event"}}{{/crossLink}} event on change.

             @property pointSize
             @default 1.0
             @type Number
             */
            pointSize: {

                set: function (value) {

                    this._state.pointSize = value || 1.0;

                    this._renderer.imageDirty = true;

                    /**
                     * Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/pointSize:property"}}{{/crossLink}} property changes.
                     *
                     * @event pointSize
                     * @param value {Array(Number)} The property's new value
                     */
                    this.fire("pointSize", this._state.pointSize);
                },

                get: function () {
                    return this._state.pointSize;
                }
            },

            /**
             Scalar in range 0-1 that controls how much {{#crossLink "CubeMap"}}CubeMap{{/crossLink}} is reflected by this PhongMaterial.

             The surface will be non-reflective when this is 0, and completely mirror-like when it is 1.0.

             This property may be overridden by {{#crossLink "PhongMaterial/reflectivityMap:property"}}{{/crossLink}}.

             Fires a {{#crossLink "PhongMaterial/reflectivity:event"}}{{/crossLink}} event on change.

             @property reflectivity
             @default 1.0
             @type Number
             */
            reflectivity: {

                set: function (value) {

                    this._state.reflectivity = value !== undefined ? value : 1.0;

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/reflectivity:property"}}{{/crossLink}} property changes.

                     @event reflectivity
                     @param value Number The property's new value
                     */
                    this.fire("reflectivity", this._state.reflectivity);
                },

                get: function () {
                    return this._state.reflectivity;
                }
            },

            /**
             A normal {{#crossLink "Texture"}}{{/crossLink}} attached to this PhongMaterial.

             This property overrides {{#crossLink "PhongMaterial/normalMap:property"}}{{/crossLink}} when not null or undefined.

             Fires a {{#crossLink "PhongMaterial/normalMap:event"}}{{/crossLink}} event on change.

             @property normalMap
             @default null
             @type {Texture}
             */
            normalMap: {

                set: function (texture) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/normalMap:property"}}{{/crossLink}} property changes.

                     @event normalMap
                     @param value Number The property's new value
                     */
                    this._setComponent("normalMap", texture);
                },

                get: function () {
                    return this._children["normalMap"];
                }
            },

            /**
             An ambient {{#crossLink "Texture"}}{{/crossLink}} attached to this PhongMaterial.

             This property overrides {{#crossLink "PhongMaterial/ambientMap:property"}}{{/crossLink}} when not null or undefined.

             Fires a {{#crossLink "PhongMaterial/ambientMap:event"}}{{/crossLink}} event on change.

             @property ambientMap
             @default null
             @type {Texture}
             */
            ambientMap: {

                set: function (texture) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/ambientMap:property"}}{{/crossLink}} property changes.

                     @event ambientMap
                     @param value Number The property's new value
                     */
                    this._setComponent("ambientMap", texture);
                },

                get: function () {
                    return this._children["ambientMap"];
                }
            },

            /**
             A diffuse {{#crossLink "Texture"}}{{/crossLink}} attached to this PhongMaterial.

             This property overrides {{#crossLink "PhongMaterial/diffuseMap:property"}}{{/crossLink}} when not null or undefined.

             Fires a {{#crossLink "PhongMaterial/diffuseMap:event"}}{{/crossLink}} event on change.

             @property diffuseMap
             @default null
             @type {Texture}
             */
            diffuseMap: {

                set: function (texture) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/diffuseMap:property"}}{{/crossLink}} property changes.

                     @event diffuseMap
                     @param value Number The property's new value
                     */
                    this._setComponent("diffuseMap", texture);
                },

                get: function () {
                    return this._children["diffuseMap"];
                }
            },

            /**
             A specular {{#crossLink "Texture"}}{{/crossLink}} attached to this PhongMaterial.

             This property overrides {{#crossLink "PhongMaterial/specular:property"}}{{/crossLink}} when not null or undefined.

             Fires a {{#crossLink "PhongMaterial/specularMap:event"}}{{/crossLink}} event on change.

             @property specularMap
             @default null
             @type {Texture}
             */
            specularMap: {

                set: function (texture) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/specularMap:property"}}{{/crossLink}} property changes.

                     @event specularMap
                     @param value Number The property's new value
                     */
                    this._setComponent("specularMap", texture);
                },

                get: function () {
                    return this._children["specularMap"];
                }
            },

            /**
             An emissive {{#crossLink "Texture"}}{{/crossLink}} attached to this PhongMaterial.

             This property overrides {{#crossLink "PhongMaterial/emissive:property"}}{{/crossLink}} when not null or undefined.

             Fires an {{#crossLink "PhongMaterial/emissiveMap:event"}}{{/crossLink}} event on change.

             @property emissiveMap
             @default null
             @type {Texture}
             */
            emissiveMap: {

                set: function (texture) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/emissiveMap:property"}}{{/crossLink}} property changes.

                     @event emissiveMap
                     @param value Number The property's new value
                     */
                    this._setComponent("emissiveMap", texture);
                },

                get: function () {
                    return this._children["emissiveMap"];
                }
            },

            /**
             An opacity {{#crossLink "Texture"}}{{/crossLink}} attached to this PhongMaterial.

             This property overrides {{#crossLink "PhongMaterial/opacity:property"}}{{/crossLink}} when not null or undefined.

             Fires an {{#crossLink "PhongMaterial/opacityMap:event"}}{{/crossLink}} event on change.

             @property opacityMap
             @default null
             @type {Texture}
             */
            opacityMap: {

                set: function (texture) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/opacityMap:property"}}{{/crossLink}} property changes.

                     @event opacityMap
                     @param value Number The property's new value
                     */
                    this._setComponent("opacityMap", texture);
                },

                get: function () {
                    return this._children["opacityMap"];
                }
            },

            /**
             A reflectivity {{#crossLink "Texture"}}{{/crossLink}} attached to this PhongMaterial.

             This property overrides {{#crossLink "PhongMaterial/reflectivity:property"}}{{/crossLink}} when not null or undefined.

             Fires a {{#crossLink "PhongMaterial/reflectivityMap:event"}}{{/crossLink}} event on change.

             @property reflectivityMap
             @default null
             @type {Texture}
             */
            reflectivityMap: {

                set: function (texture) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/reflectivityMap:property"}}{{/crossLink}} property changes.

                     @event reflectivityMap
                     @param value Number The property's new value
                     */
                    this._setComponent("reflectivityMap", texture);
                },

                get: function () {
                    return this._children["reflectivityMap"];
                }
            },

            /**
             A reflection {{#crossLink "CubeMap"}}{{/crossLink}} attached to this PhongMaterial.

             Fires a {{#crossLink "PhongMaterial/reflection:event"}}{{/crossLink}} event on change.

             @property reflection
             @default null
             @type {CubeMap}
             */
            reflection: {

                set: function (cubeMap) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/reflectivityMap:property"}}{{/crossLink}} property changes.

                     @event reflection
                     @param value {CubeMap} The property's new value
                     */
                    this._setComponent("reflection", cubeMap);
                },

                get: function () {
                    return this._children["reflection"];
                }
            },

            /**
             A diffuse {{#crossLink "Fresnel"}}{{/crossLink}} attached to this PhongMaterial.

             This property overrides {{#crossLink "PhongMaterial/diffuseFresnel:property"}}{{/crossLink}} when not null or undefined.

             Fires a {{#crossLink "PhongMaterial/diffuseFresnel:event"}}{{/crossLink}} event on change.

             @property diffuseFresnel
             @default null
             @type {Fresnel}
             */
            diffuseFresnel: {

                set: function (fresnel) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/diffuse:property"}}{{/crossLink}} property changes.

                     @event diffuseFresnel
                     @param value Number The property's new value
                     */
                    this._setComponent("diffuseFresnel", fresnel);
                },

                get: function () {
                    return this._children["diffuseFresnel"];
                }
            },

            /**
             A specular {{#crossLink "Fresnel"}}{{/crossLink}} attached to this PhongMaterial.

             This property overrides {{#crossLink "PhongMaterial/specular:property"}}{{/crossLink}} when not null or undefined.

             Fires a {{#crossLink "PhongMaterial/specularFresnel:event"}}{{/crossLink}} event on change.

             @property specularFresnel
             @default null
             @type {Fresnel}
             */
            specularFresnel: {

                set: function (fresnel) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/specularFresnel:property"}}{{/crossLink}} property changes.

                     @event specularFresnel
                     @param value Number The property's new value
                     */
                    this._setComponent("specularFresnel", fresnel);
                },

                get: function () {
                    return this._children["specularFresnel"];
                }
            },

            /**
             An emissive {{#crossLink "Fresnel"}}{{/crossLink}} attached to this PhongMaterial.

             This property overrides {{#crossLink "PhongMaterial/emissive:property"}}{{/crossLink}} when not null or undefined.

             Fires an {{#crossLink "PhongMaterial/emissiveFresnel:event"}}{{/crossLink}} event on change.

             @property emissiveFresnel
             @default null
             @type {Fresnel}
             */
            emissiveFresnel: {

                set: function (fresnel) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/emissiveFresnel:property"}}{{/crossLink}} property changes.

                     @event emissiveFresnel
                     @param value Number The property's new value
                     */
                    this._setComponent("emissiveFresnel", fresnel);
                },

                get: function () {
                    return this._children["emissiveFresnel"];
                }
            },

            /**
             An opacity {{#crossLink "Fresnel"}}{{/crossLink}} attached to this PhongMaterial.

             This property overrides {{#crossLink "PhongMaterial/opacity:property"}}{{/crossLink}} when not null or undefined.

             Fires an {{#crossLink "PhongMaterial/opacityFresnel:event"}}{{/crossLink}} event on change.

             @property opacityFresnel
             @default null
             @type {Fresnel}
             */
            opacityFresnel: {

                set: function (fresnel) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/opacityFresnel:property"}}{{/crossLink}} property changes.

                     @event opacityFresnel
                     @param value Number The property's new value
                     */
                    this._setComponent("opacityFresnel", fresnel);
                },

                get: function () {
                    return this._children["opacityFresnel"];
                }
            },

            /**
             A reflectivity {{#crossLink "Fresnel"}}{{/crossLink}} attached to this PhongMaterial.

             This property overrides {{#crossLink "PhongMaterial/reflectivity:property"}}{{/crossLink}} when not null or undefined.

             Fires a {{#crossLink "PhongMaterial/reflectivityFresnel:event"}}{{/crossLink}} event on change.

             @property reflectivityFresnel
             @default null
             @type {Fresnel}
             */
            reflectivityFresnel: {

                set: function (fresnel) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/reflectivityFresnel:property"}}{{/crossLink}} property changes.

                     @event reflectivityFresnel
                     @param value Number The property's new value
                     */
                    this._setComponent("reflectivityFresnel", fresnel);
                },

                get: function () {
                    return this._children["reflectivityFresnel"];
                }
            }
        },

        _setComponent: function (name, child) {
            child = this._setChild(name, child, false);
            this._state[name] = child ? child._state : null;
            this._hashDirty = true;
        },

        _compile: function () {

            if (this._hashDirty) {
                this._makeHash();
                this._hashDirty = false;
            }

            this._renderer.material = this._state;
        },

        _makeHash: function () {

            var state = this._state;

            var hash = ["/p"]; // 'P' for Phong

            if (state.normalMap) {
                hash.push("/b");
                if (state.normalMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.ambientMap) {
                hash.push("/a");
                if (state.ambientMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.diffuseMap) {
                hash.push("/d");
                if (state.diffuseMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.specularMap) {
                hash.push("/s");
                if (state.specularMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.emissiveMap) {
                hash.push("/e");
                if (state.emissiveMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.opacityMap) {
                hash.push("/o");
                if (state.opacityMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.reflectivityMap) {
                hash.push("/r");
                if (state.reflectivityMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.diffuseFresnel) {
                hash.push("/df");
            }

            if (state.specularFresnel) {
                hash.push("/sf");
            }

            if (state.emissiveFresnel) {
                hash.push("/ef");
            }

            if (state.opacityFresnel) {
                hash.push("/of");
            }

            if (state.reflectivityFresnel) {
                hash.push("/rf");
            }

            hash.push(";");

            state.hash = hash.join("");
        },

        _getJSON: function () {

            var json = {

                // Colors

                ambient: this._state.ambient,
                diffuse: this._state.diffuse,
                specular: this._state.specular,
                emissive: this._state.emissive
            };

            if (this._state.opacity != 1.0) {
                json.opacity = this._state.opacity;
            }

            if (this._state.shininess != 80.0) {
                json.shininess = this._state.shininess;
            }

            if (this._state.reflectivity != 1.0) {
                json.reflectivity = this._state.reflectivity;
            }


            // Lines and points

            if (this._state.lineWidth != 1.0) {
                json.lineWidth = this._state.lineWidth;
            }

            if (this._state.pointSize != 1.0) {
                json.pointSize = this._state.pointSize;
            }

            // Textures

            var components = this._children;

            if (components.normalMap) {
                json.normalMap = components.normalMap.id;
            }

            if (components.ambientMap) {
                json.ambientMap = components.ambientMap.id;
            }

            if (components.diffuseMap) {
                json.diffuseMap = components.diffuseMap.id;
            }

            if (components.specularMap) {
                json.specularMap = components.specularMap.id;
            }

            if (components.emissiveMap) {
                json.emissiveMap = components.emissiveMap.id;
            }

            if (components.opacityMap) {
                json.opacityMap = components.opacityMap.id;
            }

            if (components.reflectivityMap) {
                json.reflectivityMap = components.reflectivityMap.id;
            }

            if (components.diffuseFresnel) {
                json.diffuseFresnel = components.diffuseFresnel.id;
            }

            if (components.specularFresnel) {
                json.specularFresnel = components.specularFresnel.id;
            }

            if (components.emissiveFresnel) {
                json.emissiveFresnel = components.emissiveFresnel.id;
            }

            if (components.opacityFresnel) {
                json.opacityFresnel = components.opacityFresnel.id;
            }

            if (components.reflectivityFresnel) {
                json.reflectivityFresnel = components.reflectivityFresnel.id;
            }

            return json;
        },

        _destroy: function () {
            this._state.destroy();
        }
    });

})();
;/**
 A **Texture** specifies a texture map.

 ## Overview

 <ul>
 <li>Textures are grouped within {{#crossLink "Material"}}Material{{/crossLink}}s, which are attached to
 {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>
 <li>To create a Texture from an image file, set the Texture's {{#crossLink "Texture/src:property"}}{{/crossLink}}
 property to the image file path.</li>
 <li>To create a Texture from an HTML DOM Image object, set the Texture's {{#crossLink "Texture/image:property"}}{{/crossLink}}
 property to the object.</li>
 <li>To render color images of {{#crossLink "Entity"}}Entities{{/crossLink}} to a Texture, set the Texture's {{#crossLink "Texture/target:property"}}{{/crossLink}}
 property to a {{#crossLink "ColorTarget"}}ColorTarget{{/crossLink}} that is attached to those {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>
 <li>Similarly, to render depth images of {{#crossLink "Entity"}}Entities{{/crossLink}} to a Texture, set the Texture's {{#crossLink "Texture/target:property"}}{{/crossLink}}
 property to a {{#crossLink "DepthTarget"}}DepthTarget{{/crossLink}} that is attached to those {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>
 <li>For special effects, we often use rendered Textures in combination with {{#crossLink "Shader"}}Shaders{{/crossLink}} and {{#crossLink "Stage"}}Stages{{/crossLink}}.</li>
 <li>See <a href="Shader.html#inputs">Shader Inputs</a> for the variables that Textures create within xeoEngine's shaders.</li>
 </ul>

 <img src="../../../assets/images/Texture.png"></img>

 ## Example

 The example below has:
 <ul>
 <li>three Textures,</li>
 <li>a {{#crossLink "PhongMaterial"}}{{/crossLink}} which applies the {{#crossLink "Texture"}}{{/crossLink}}s as diffuse, normal and specular maps,</li>
 <li>a {{#crossLink "Lights"}}{{/crossLink}} containing an {{#crossLink "AmbientLight"}}{{/crossLink}} and a {{#crossLink "PointLight"}}{{/crossLink}},</li>
 <li>a {{#crossLink "BoxGeometry"}}{{/crossLink}}, and
 <li>an {{#crossLink "Entity"}}{{/crossLink}} attached to all of the above.</li>
 </ul>

 ```` javascript
 var texture1 = new XEO.Texture({
    src: "diffuseMap.jpg"
 });

 var texture2 = new XEO.Texture({
    src: "normalMap.jpg"
 });

 var texture3 = new XEO.Texture({
    src: "specularMap.jpg"
});

 var material = new XEO.PhongMaterial({
    ambient: [0.3, 0.3, 0.3],
    shininess: 30,
    diffuseMap: texture1,
    normalMap: texture2,
    specularMap: texture3
});

 var light1 = new XEO.PointLight({
    pos: [0, 100, 100],
    color: [0.5, 0.7, 0.5]
});

 var light2 = new XEO.AmbientLight({
    color: [0.5, 0.7, 0.5]
});

 var lights = new XEO.Lights({
    lights: [
        light1,
        light2
    ]
});

 var geometry = new XEO.BoxGeometry();

 var entity = new XEO.Entity({
    lights: lights,
    material: material,
    geometry: geometry
});
 ````
 @class Texture
 @module XEO
 @submodule materials
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Texture in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID for this Texture, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Texture.
 @param [cfg.src=null] {String} Path to image file to load into this Texture. See the {{#crossLink "Texture/src:property"}}{{/crossLink}} property for more info.
 @param [cfg.image=null] {HTMLImageElement} HTML Image object to load into this Texture. See the {{#crossLink "Texture/image:property"}}{{/crossLink}} property for more info.
 @param [cfg.target=null] {String | XEO.ColorTarget | XEO.DepthTarget} Instance or ID of a {{#crossLink "ColorTarget"}}ColorTarget{{/crossLink}} or
 {{#crossLink "DepthTarget"}}DepthTarget{{/crossLink}} to source this Texture from. See the {{#crossLink "Texture/target:property"}}{{/crossLink}} property for more info.
 @param [cfg.minFilter="linearMipmapLinear"] {String} How the texture is sampled when a texel covers less than one pixel. See the {{#crossLink "Texture/minFilter:property"}}{{/crossLink}} property for more info.
 @param [cfg.magFilter="linear"] {String} How the texture is sampled when a texel covers more than one pixel. See the {{#crossLink "Texture/magFilter:property"}}{{/crossLink}} property for more info.
 @param [cfg.wrapS="repeat"] {String} Wrap parameter for texture coordinate *S*. See the {{#crossLink "Texture/wrapS:property"}}{{/crossLink}} property for more info.
 @param [cfg.wrapT="repeat"] {String} Wrap parameter for texture coordinate *S*. See the {{#crossLink "Texture/wrapT:property"}}{{/crossLink}} property for more info.
 @param [cfg.translate=[0,0]] {Array of Number} 2D translation vector that will be added to texture's *S* and *T* coordinates.
 @param [cfg.scale=[1,1]] {Array of Number} 2D scaling vector that will be applied to texture's *S* and *T* coordinates.
 @param [cfg.rotate=0] {Number} Rotation, in degrees, that will be applied to texture's *S* and *T* coordinates.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Texture = XEO.Component.extend({

        type: "XEO.Texture",

        _init: function (cfg) {

            // Rendering state

            this._state = new XEO.renderer.Texture({

                texture: null,  // XEO.renderer.webgl.Texture2D
                matrix: null,   // Float32Array

                // Texture properties

                minFilter: null,
                magFilter: null,
                wrapS: null,
                wrapT: null
            });

            // Data source

            this._src = null;   // URL string
            this._image = null; // HTMLImageElement
            this._target = null;// XEO.RenderTarget

            // Transformation

            this._translate = [0, 0];
            this._scale = [1, 1];
            this._rotate = [0, 0];

            // Dirty flags, processed in _buildTexture()

            this._matrixDirty = false;
            this._srcDirty = false;
            this._imageDirty = false;
            this._targetDirty = false;
            this._propsDirty = false;

            var self = this;

            // Handle WebGL context restore

            this._webglContextRestored = this.scene.canvas.on("webglContextRestored", this._webglContextRestored, this);

            // Transform

            this.translate = cfg.translate;
            this.scale = cfg.scale;
            this.rotate = cfg.rotate;

            // Properties

            this.minFilter = cfg.minFilter;
            this.magFilter = cfg.magFilter;
            this.wrapS = cfg.wrapS;
            this.wrapT = cfg.wrapT;

            // Data source

            if (cfg.src) {
                this.src = cfg.src; // Image file

            } else if (cfg.image) {
                this.image = cfg.image; // Image object

            } else if (cfg.target) {
                this.target = cfg.target; // Render target
            }

            XEO.stats.memory.textures++;
        },

        _webglContextRestored: function () {

            this._state.texture = null;

            this._matrixDirty = true;
            this._propsDirty = true;

            if (this._image) {
                this._imageDirty = true;

            } else if (this._src) {
                this._srcDirty = true;

            } else if (this._target) {
                this._targetDirty = true;
            }

            this._scheduleUpdate();
        },

        _update: function () {

            var gl = this.scene.canvas.gl;

            var state = this._state;

            if (this._srcDirty) {

                if (this._src) {

                    this._loadSrc(this._src);

                    this._srcDirty = false;

                    // _imageDirty is set when the image has loaded

                    return;
                }
            }

            if (this._imageDirty) {

                if (this._image) {

                    if (this._onTargetActive) {
                        this._target.off(this._onTargetActive);
                        this._onTargetActive = null;
                    }

                    if (state.texture && state.texture.renderBuffer) {

                        // Detach from "virtual texture" provided by render target
                        state.texture = null;
                    }

                    if (!state.texture) {
                        state.texture = new XEO.renderer.webgl.Texture2D(gl);
                    }

                    state.texture.setImage(this._image);

                    this._imageDirty = false;
                    this._propsDirty = true; // May now need to regenerate mipmaps etc
                }
            }

            if (this._targetDirty) {

                if (state.texture && !state.texture.renderBuffer) {
                    state.texture.destroy();
                    state.texture = null;
                }

                if (this._onTargetActive) {
                    this._target.off(this._onTargetActive);
                    this._onTargetActive = null;
                }

                if (this._target) {
                    this._onTargetActive = this._target.on("active",  // Called immediately when first bound
                        function (active) {
                            state.texture = active ? this._state.renderBuf.getTexture() : null;
                        });
                }

                this._targetDirty = false;
                this._propsDirty = true;
            }

            if (this._matrixDirty) {

                var matrix;

                var t;

                if (this._translate[0] !== 0 || this._translate[2] !== 0) {
                    matrix = XEO.math.translationMat4v([this._translate[0], this._translate[1], 0]);
                }

                if (this._scale[0] !== 1 || this._scale[1] !== 1) {
                    t = XEO.math.scalingMat4v([this._scale[0], this._scale[1], 1]);
                    matrix = matrix ? XEO.math.mulMat4(matrix, t) : t;
                }

                if (this._rotate !== 0) {
                    t = XEO.math.rotationMat4v(this._rotate * 0.0174532925, [0, 0, 1]);
                    matrix = matrix ? XEO.math.mulMat4(matrix, t) : t;
                }

                var oldMatrix = state.matrix;

                state.matrix = matrix;

                this._matrixDirty = false;

                if (!!matrix !== !!oldMatrix) {

                    // Matrix has been lazy-created, now need
                    // to recompile xeoEngine shaders to use the matrix

                    this.fire("dirty");
                }
            }

            if (this._propsDirty) {

                if (state.texture && state.texture.setProps) {

                    // TODO: Ability to set props on texture from _target's RenderBuffer?

                    state.texture.setProps(state);
                }

                this._propsDirty = false;
            }

            this._renderer.imageDirty = true;
        },


        _loadSrc: function (src) {

            //var task = this.scene.tasks.create({
            //    description: "Loading texture"
            //});

            var self = this;

            var image = new Image();

            image.onload = function () {

                if (self._src === src) {

                    // Ensure data source was not changed while we were loading

                    // Keep self._src because that's where we loaded the image
                    // from, and we may need to save that in JSON later

                    self._image = XEO.renderer.webgl.ensureImageSizePowerOfTwo(image);

                    self._imageDirty = true;
                    self._srcDirty = false;
                    self._targetDirty = false;

                    self._scheduleUpdate();

                    /**
                     * Fired whenever this Texture's  {{#crossLink "Texture/image:property"}}{{/crossLink}} property changes.
                     * @event image
                     * @param value {HTML Image} The property's new value
                     */
                    self.fire("image", self._image);

                    /**
                     * Fired whenever this Texture has loaded the
                     * image file that its {{#crossLink "Texture/src:property"}}{{/crossLink}} property currently points to.
                     * @event loaded
                     * @param value {HTML Image} The value of the {{#crossLink "Texture/src:property"}}{{/crossLink}} property
                     */
                    self.fire("loaded", self._src);
                }

//                task.setCompleted();
            };

            image.onerror = function () {
                //              task.setFailed();
            };

            if (src.indexOf("data") === 0) {

                // Image data
                image.src = src;

            } else {

                // Image file
                image.crossOrigin = "Anonymous";
                image.src = src;
            }
        },

        _props: {

            /**
             * Indicates an HTML DOM Image object to source this Texture from.
             *
             * Alternatively, you could indicate the source via either of properties
             * {{#crossLink "Texture/src:property"}}{{/crossLink}} or {{#crossLink "Texture/target:property"}}{{/crossLink}}.
             *
             * Fires an {{#crossLink "Texture/image:event"}}{{/crossLink}} event on change.
             *
             * Sets the {{#crossLink "Texture/src:property"}}{{/crossLink}} and
             * {{#crossLink "Texture/target:property"}}{{/crossLink}} properties to null.
             *
             * @property image
             * @default null
             * @type {HTMLImageElement}
             */
            image: {

                set: function (value) {

                    this._image = XEO.renderer.webgl.ensureImageSizePowerOfTwo(value);
                    this._src = null;

                    this._imageDirty = true;
                    this._srcDirty = false;
                    this._targetDirty = false;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Texture's  {{#crossLink "Texture/image:property"}}{{/crossLink}} property changes.
                     * @event image
                     * @param value {HTML Image} The property's new value
                     */
                    this.fire("image", this._image);
                },

                get: function () {
                    return this._state.image;
                }
            },

            /**
             * Indicates a path to an image file to source this Texture from.
             *
             * Alternatively, you could indicate the source via either of properties
             * {{#crossLink "Texture/image:property"}}{{/crossLink}} or {{#crossLink "Texture/target:property"}}{{/crossLink}}.
             *
             * Fires a {{#crossLink "Texture/src:event"}}{{/crossLink}} event on change.
             *
             * Sets the {{#crossLink "Texture/image:property"}}{{/crossLink}} and
             * {{#crossLink "Texture/target:property"}}{{/crossLink}} properties to null.
             *
             * @property src
             * @default null
             * @type String
             */
            src: {

                set: function (value) {

                    this._image = null;
                    this._src = value;

                    this._imageDirty = false;
                    this._srcDirty = true;
                    this._targetDirty = false;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Texture's {{#crossLink "Texture/src:property"}}{{/crossLink}} property changes.
                     * @event src
                     * @param value The property's new value
                     * @type String
                     */
                    this.fire("src", this._src);
                },

                get: function () {
                    return this._src;
                }
            },

            /**
             * Instance or ID of a {{#crossLink "ColorTarget"}}ColorTarget{{/crossLink}} or
             * {{#crossLink "DepthTarget"}}DepthTarget{{/crossLink}} to source this Texture from.
             *
             * Alternatively, you could indicate the source via either of properties
             * {{#crossLink "Texture/src:property"}}{{/crossLink}} or {{#crossLink "Texture/image:property"}}{{/crossLink}}.
             *
             * Fires a {{#crossLink "Texture/target:event"}}{{/crossLink}} event on change.
             *
             * Sets the {{#crossLink "Texture/src:property"}}{{/crossLink}} and
             * {{#crossLink "Texture/image:property"}}{{/crossLink}} properties to null.
             *
             * @property target
             * @default null
             * @type String | XEO.ColorTarget | XEO.DepthTarget
             */
            target: {

                set: function (value) {

                    this._image = null;
                    this._src = null;

                    if (this._onTargetActive) {
                        this._target.off(this._onTargetActive);
                        this._onTargetActive = null;
                    }

                    this._target = this._setChild("renderBuf", value);

                    this._imageDirty = false;
                    this._srcDirty = false;
                    this._targetDirty = true;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Texture's   {{#crossLink "Texture/target:property"}}{{/crossLink}} property changes.
                     * @event target
                     * @param value The property's new value
                     * @type String | XEO.ColorTarget | XEO.DepthTarget
                     */
                    this.fire("target", this._target);
                },

                get: function () {
                    return this._children.target;
                }
            },

            /**
             * 2D translation vector that will be added to this Texture's *S* and *T* coordinates.
             *
             * Fires a {{#crossLink "Texture/translate:event"}}{{/crossLink}} event on change.
             *
             * @property translate
             * @default [0, 0]
             * @type Array(Number)
             */
            translate: {

                set: function (value) {

                    value = value || [0, 0];

                    this._translate = value;
                    this._matrixDirty = true;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Texture's   {{#crossLink "Texture/translate:property"}}{{/crossLink}} property changes.
                     * @event translate
                     * @param value {Array(Number)} The property's new value
                     */
                    this.fire("translate", this._translate);
                },

                get: function () {
                    return this._translate;
                }
            },

            /**
             * 2D scaling vector that will be applied to this Texture's *S* and *T* coordinates.
             *
             * Fires a {{#crossLink "Texture/scale:event"}}{{/crossLink}} event on change.
             *
             * @property scale
             * @default [1, 1]
             * @type Array(Number)
             */
            scale: {

                set: function (value) {

                    value = value || [1, 1];

                    this._scale = value;
                    this._matrixDirty = true;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Texture's   {{#crossLink "Texture/scale:property"}}{{/crossLink}} property changes.
                     * @event scale
                     * @param value {Array(Number)} The property's new value
                     */
                    this.fire("scale", this._scale);
                },

                get: function () {
                    return this._scale;
                }
            },

            /**
             * Rotation, in degrees, that will be applied to this Texture's *S* and *T* coordinates.
             *
             * Fires a {{#crossLink "Texture/rotate:event"}}{{/crossLink}} event on change.
             *
             * @property rotate
             * @default 0
             * @type Number
             */
            rotate: {

                set: function (value) {

                    value = value || 0;

                    if (this._rotate === value) {
                        return;
                    }

                    this._rotate = value;
                    this._matrixDirty = true;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Texture's  {{#crossLink "Texture/rotate:property"}}{{/crossLink}} property changes.
                     * @event rotate
                     * @param value {Number} The property's new value
                     */
                    this.fire("rotate", this._rotate);
                },

                get: function () {
                    return this._rotate;
                }
            },

            /**
             * How this Texture is sampled when a texel covers less than one pixel.
             *
             * Options are:
             *
             * <ul>
             *     <li>**"nearest"** - Uses the value of the texture element that is nearest
             *     (in Manhattan distance) to the center of the pixel being textured.</li>
             *
             *     <li>**"linear"** - Uses the weighted average of the four texture elements that are
             *     closest to the center of the pixel being textured.</li>
             *
             *     <li>**"nearestMipmapNearest"** - Chooses the mipmap that most closely matches the
             *     size of the pixel being textured and uses the "nearest" criterion (the texture
             *     element nearest to the center of the pixel) to produce a texture value.</li>
             *
             *     <li>**"linearMipmapNearest"** - Chooses the mipmap that most closely matches the size of
             *     the pixel being textured and uses the "linear" criterion (a weighted average of the
             *     four texture elements that are closest to the center of the pixel) to produce a
             *     texture value.</li>
             *
             *     <li>**"nearestMipmapLinear"** - Chooses the two mipmaps that most closely
             *     match the size of the pixel being textured and uses the "nearest" criterion
             *     (the texture element nearest to the center of the pixel) to produce a texture
             *     value from each mipmap. The final texture value is a weighted average of those two
             *     values.</li>
             *
             *     <li>**"linearMipmapLinear"** - **(default)** - Chooses the two mipmaps that most closely match the size
             *     of the pixel being textured and uses the "linear" criterion (a weighted average
             *     of the four texture elements that are closest to the center of the pixel) to
             *     produce a texture value from each mipmap. The final texture value is a weighted
             *     average of those two values.</li>
             * </ul>
             *
             * Fires a {{#crossLink "Texture/minFilter:event"}}{{/crossLink}} event on change.
             *
             * @property minFilter
             * @default "linearMipmapLinear"
             * @type String
             */
            minFilter: {

                set: function (value) {

                    value = value || "linearMipmapLinear";

                    if (value !== "linear" &&
                        value !== "linearMipmapNearest" &&
                        value !== "linearMipmapLinear" &&
                        value !== "nearestMipmapLinear" &&
                        value !== "linearMipmapLinear") {

                        this.error("Unsupported value for 'minFilter': '" + value +
                            "' - supported values are 'linear', 'linearMipmapNearest', 'nearestMipmapLinear' " +
                            "and 'linearMipmapLinear'. Defaulting to 'linearMipmapLinear'.");

                        value = "linearMipmapLinear";
                    }

                    this._state.minFilter = value;
                    this._propsDirty = true;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Texture's  {{#crossLink "Texture/minFilter:property"}}{{/crossLink}} property changes.
                     * @event minFilter
                     * @param value {String} The property's new value
                     */
                    this.fire("minFilter", this._state.minFilter);
                },

                get: function () {
                    return this._state.minFilter;
                }
            },

            /**
             * How this Texture is sampled when a texel covers more than one pixel.
             *
             * Options are:
             *
             * <ul>
             *     <li>**"nearest"** - Uses the value of the texture element that is nearest
             *     (in Manhattan distance) to the center of the pixel being textured.</li>
             *     <li>**"linear"** - **(default)** - Uses the weighted average of the four texture elements that are
             *     closest to the center of the pixel being textured.</li>
             * </ul>
             *
             * Fires a {{#crossLink "Texture/magFilter:event"}}{{/crossLink}} event on change.
             *
             * @property magFilter
             * @default "linear"
             * @type String
             */
            magFilter: {

                set: function (value) {

                    value = value || "linear";

                    if (value !== "linear" && value !== "nearest") {

                        this.error("Unsupported value for 'magFilter': '" + value +
                            "' - supported values are 'linear' and 'nearest'. Defaulting to 'linear'.");

                        value = "linear";
                    }

                    this._state.magFilter = value;
                    this._propsDirty = true;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Texture's  {{#crossLink "Texture/magFilter:property"}}{{/crossLink}} property changes.
                     * @event magFilter
                     * @param value {String} The property's new value
                     */
                    this.fire("magFilter", this._state.magFilter);
                },

                get: function () {
                    return this._state.magFilter;
                }
            },

            /**
             * Wrap parameter for this Texture's *S* coordinate.
             *
             * Options are:
             *
             * <ul>
             *     <li>**"clampToEdge"** -  causes *S* coordinates to be clamped to the size of the texture.</li>
             *     <li>**"mirroredRepeat"** - causes the *S* coordinate to be set to the fractional part of the texture coordinate
             *     if the integer part of *S* is even; if the integer part of *S* is odd, then the *S* texture coordinate is
             *     set to *1 - frac ⁡ S* , where *frac ⁡ S* represents the fractional part of *S*.</li>
             *     <li>**"repeat"** - **(default)** - causes the integer part of the *S* coordinate to be ignored; xeoEngine uses only the
             *     fractional part, thereby creating a repeating pattern.</li>
             * </ul>
             *
             * Fires a {{#crossLink "Texture/wrapS:event"}}{{/crossLink}} event on change.
             *
             * @property wrapS
             * @default "repeat"
             * @type String
             */
            wrapS: {

                set: function (value) {

                    value = value || "repeat";

                    if (value !== "clampToEdge" && value !== "mirroredRepeat" && value !== "repeat") {

                        this.error("Unsupported value for 'wrapS': '" + value +
                            "' - supported values are 'clampToEdge', 'mirroredRepeat' and 'repeat'. Defaulting to 'repeat'.");

                        value = "repeat";
                    }

                    this._state.wrapS = value;
                    this._propsDirty = true;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Texture's  {{#crossLink "Texture/wrapS:property"}}{{/crossLink}} property changes.
                     * @event wrapS
                     * @param value {String} The property's new value
                     */
                    this.fire("wrapS", this._state.wrapS);
                },

                get: function () {
                    return this._state.wrapS;
                }
            },

            /**
             * Wrap parameter for this Texture's *T* coordinate.
             *
             * Options are:
             *
             * <ul>
             *     <li>**"clampToEdge"** -  Causes *T* coordinates to be clamped to the size of the texture.</li>
             *     <li>**"mirroredRepeat"** - Causes the *T* coordinate to be set to the fractional part of the texture coordinate
             *     if the integer part of *T* is even; if the integer part of *T* is odd, then the *T* texture coordinate is
             *     set to *1 - frac ⁡ S* , where *frac ⁡ S* represents the fractional part of *T*.</li>
             *     <li>**"repeat"** - **(default)** - Causes the integer part of the *T* coordinate to be ignored; xeoEngine uses only the
             *     fractional part, thereby creating a repeating pattern.</li>
             * </ul>
             *
             * Fires a {{#crossLink "Texture/wrapT:event"}}{{/crossLink}} event on change.
             *
             * @property wrapT
             * @default "repeat"
             * @type String
             */
            wrapT: {

                set: function (value) {

                    value = value || "repeat";

                    if (value !== "clampToEdge" && value !== "mirroredRepeat" && value !== "repeat") {

                        this.error("Unsupported value for 'wrapT': '" + value +
                            "' - supported values are 'clampToEdge', 'mirroredRepeat' and 'repeat'. Defaulting to 'repeat'.");

                        value = "repeat";
                    }

                    this._state.wrapT = value;
                    this._propsDirty = true;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Texture's  {{#crossLink "Texture/wrapT:property"}}{{/crossLink}} property changes.
                     * @event wrapT
                     * @param value {String} The property's new value
                     */
                    this.fire("wrapT", this._state.wrapT);
                },

                get: function () {
                    return this._state.wrapT;
                }
            }
        },

        _getJSON: function () {

            var json = {};

            if (this._translate && (this._translate[0] !== 0 || this._translate[1] !== 0)) {
                json.translate = this._translate;
            }

            if (this._scale && (this._scale[0] !== 1 || this._scale[1] !== 1)) {
                json.scale = this._scale;
            }

            if (this._rotate !== 0) {
                json.rotate = this._rotate;
            }

            if (this._state.minFilter != "linearMipmapLinear") {
                json.minFilter = this._state.minFilter;
            }

            if (this._state.magFilter != "linear") {
                json.magFilter = this._state.magFilter;
            }

            if (this._state.wrapS != "repeat") {
                json.wrapS = this._state.wrapS;
            }

            if (this._state.wrapT != "repeat") {
                json.wrapT = this._state.wrapT;
            }

            if (this._src) {
                json.src = this._src;

            } else if (this._target) {
                json.target = this._target.id;

            } else if (this._image) {
                // TODO: Image data
                // json.src = image.src;
            }

            return json;
        },

        _destroy: function () {

            this.scene.canvas.off(this._webglContextRestored);

            if (this._state.texture) {
                this._state.texture.destroy();
            }

            XEO.stats.memory.textures--;
        }
    });

})();
;/**
 A **Fresnel** specifies a Fresnel effect.

 ## Overview

 <ul>
 <li>Fresnels are grouped within {{#crossLink "Material"}}Material{{/crossLink}}s, which are attached to
 {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>
 <li>See <a href="Shader.html#inputs">Shader Inputs</a> for the variables that Fresnels create within xeoEngine's shaders.</li>
 </ul>

 <img src="../../../assets/images/Fresnel.png"></img>

 ## Example

 The example below has:
 <ul>
 <li>two Fresnels,</li>
 <li>a {{#crossLink "PhongMaterial"}}{{/crossLink}} which applies the {{#crossLink "Fresnel"}}{{/crossLink}}s to diffuse and specular shading,</li>
 <li>a {{#crossLink "Lights"}}{{/crossLink}} containing an {{#crossLink "AmbientLight"}}{{/crossLink}} and a {{#crossLink "PointLight"}}{{/crossLink}},</li>
 <li>a {{#crossLink "Geometry"}}{{/crossLink}} that has the default box shape, and
 <li>an {{#crossLink "Entity"}}{{/crossLink}} attached to all of the above.</li>
 </ul>

 ```` javascript
 var scene = new XEO.Scene();

 var fresnel1 = new XEO.Fresnel(scene, {
    edgeColor: [1.0, 1.0, 1.0],
    centerColor: [0.0, 0.0, 0.0],
    power: 4,
    bias: 0.6
});

 var fresnel2 = new XEO.Fresnel(scene, {
    edgeColor: [1.0, 1.0, 1.0],
    centerColor: [0.0, 0.0, 0.0],
    power: 4,
    bias: 0.2
});

 var material = new XEO.PhongMaterial(scene, {
    ambient: [0.3, 0.3, 0.3],
    shininess: 30,
    diffuseFresnel: fresnel1,
    specularFresnel: fresnel3
});

 var light1 = new XEO.PointLight(scene, {
    pos: [0, 100, 100],
    diffuse: [0.5, 0.7, 0.5],
    specular: [1.0, 1.0, 1.0]
});

 var light2 = new XEO.AmbientLight(scene, {
    color: [0.5, 0.7, 0.5]
});

 var lights = new XEO.Lights(scene, {
    lights: [
        light1,
        light2
    ]
});

 // Geometry without parameters will default to a 2x2x2 box.
 var geometry = new XEO.Geometry(scene);

 var entity = new XEO.Entity(scene, {
    lights: lights,
    material: material,
    geometry: geometry
});
 ````

 @class Fresnel
 @module XEO
 @submodule materials
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Geometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Fresnel.
 @param [cfg.edgeColor=[ 0.0, 0.0, 0.0 ]] {Array of Number} Color used on edges.
 @param [cfg.centerColor=[ 1.0, 1.0, 1.0 ]] {Array of Number} Color used on center.
 @param [cfg.edgeBias=0] {Number} Bias at the edge.
 @param [cfg.centerBias=1] {Number} Bias at the center.
 @param [cfg.power=0] {Number} The power.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Fresnel = XEO.Component.extend({

        type: "XEO.Fresnel",

        _init: function (cfg) {

            this._state = new XEO.renderer.Fresnel({
                edgeColor: [0, 0, 0],
                centerColor: [1, 1, 1],
                edgeBias: 0,
                centerBias: 1,
                power: 1
            });

            this.edgeColor = cfg.edgeColor;
            this.centerColor = cfg.centerColor;
            this.edgeBias = cfg.edgeBias;
            this.centerBias = cfg.centerBias;
            this.power = cfg.power;
        },

        _props: {

            /**
             This Fresnel's edge color.

             Fires an {{#crossLink "Fresnel/edgeColor:event"}}{{/crossLink}} event on change.

             @property edgeColor
             @default [0.0, 0.0, 0.0]
             @type Array(Number)
             */
            edgeColor: {

                set: function (value) {

                    this._state.edgeColor = value || [0.0, 0.0, 0.0];

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this Fresnel's {{#crossLink "leftColorLight/edgeColor:property"}}{{/crossLink}} property changes.

                     @event edgeColor
                     @param value The property's new value
                     */
                    this.fire("edgeColor", this._state.edgeColor);
                },

                get: function () {
                    return this._state.edgeColor;
                }
            },

            /**
             This Fresnel's center color.

             Fires an {{#crossLink "Fresnel/centerColor:event"}}{{/crossLink}} event on change.

             @property centerColor
             @default [1.0, 1.0, 1.0]
             @type Array(Number)
             */
            centerColor: {

                set: function (value) {

                    this._state.centerColor = value || [1.0, 1.0, 1.0];

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this Fresnel's {{#crossLink "rightColorLight/centerColor:property"}}{{/crossLink}} property changes.

                     @event centerColor
                     @param value The property's new value
                     */
                    this.fire("centerColor", this._state.centerColor);
                },

                get: function () {
                    return this._state.centerColor;
                }
            },

            /**
             * Indicates this Fresnel's edge bias.
             *
             * Fires a {{#crossLink "Fresnel/edgeBias:event"}}{{/crossLink}} event on change.
             *
             * @property edgeBias
             * @default 0
             * @type Number
             */
            edgeBias: {

                set: function (value) {

                    this._state.edgeBias = value || 0;

                    this._renderer.imageDirty = true;

                    /**
                     * Fired whenever this Fresnel's {{#crossLink "Fresnel/edgeBias:property"}}{{/crossLink}} property changes.
                     *
                     * @event edgeBias
                     * @param value The property's new value
                     */
                    this.fire("edgeBias", this._state.edgeBias);
                },

                get: function () {
                    return this._state.edgeBias;
                }
            },

            /**
             * Indicates this Fresnel's center bias.
             *
             * Fires a {{#crossLink "Fresnel/centerBias:event"}}{{/crossLink}} event on change.
             *
             * @property centerBias
             * @default 1
             * @type Number
             */
            centerBias: {

                set: function (value) {

                    this._state.centerBias = (value !== undefined && value !== null) ? value : 1;

                    this._renderer.imageDirty = true;

                    /**
                     * Fired whenever this Fresnel's {{#crossLink "Fresnel/centerBias:property"}}{{/crossLink}} property changes.
                     *
                     * @event centerBias
                     * @param value The property's new value
                     */
                    this.fire("centerBias", this._state.centerBias);
                },

                get: function () {
                    return this._state.centerBias;
                }
            },

            /**
             * Indicates this Fresnel's power.
             *
             * Fires a {{#crossLink "Fresnel/power:event"}}{{/crossLink}} event on change.
             *
             * @property power
             * @default 1
             * @type Number
             */
            power: {

                set: function (value) {

                    this._state.power = (value !== undefined && value !== null) ? value : 1;

                    this._renderer.imageDirty = true;

                    /**
                     * Fired whenever this Fresnel's {{#crossLink "Fresnel/power:property"}}{{/crossLink}} property changes.
                     *
                     * @event power
                     * @param value The property's new value
                     */
                    this.fire("power", this._state.power);
                },

                get: function () {
                    return this._state.power;
                }
            }
        },

        _getJSON: function () {
            return {
                edgeColor: this._state.edgeColor,
                centerColor: this._state.centerColor,
                edgeBias: this._state.edgeBias,
                centerBias: this._state.centerBias,
                power: this._state.power
            };
        },

        _destroy: function () {
            this._state.destroy();
        }
    });

})();
;/**
 A **Reflect** specifies a reflect map.

 ## Overview

 <ul>
 <li>Reflects are grouped within {{#crossLink "Material"}}Material{{/crossLink}}s, which are attached to
 {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>
 <li>To create a Reflect from an image file, set the Reflect's {{#crossLink "Reflect/src:property"}}{{/crossLink}}
 property to the image file path.</li>
 <li>To create a Reflect from an HTML DOM Image object, set the Reflect's {{#crossLink "Reflect/image:property"}}{{/crossLink}}
 property to the entity.</li>
 <li>To render color images of {{#crossLink "Entity"}}Entities{{/crossLink}} to a Reflect, set the Reflect's {{#crossLink "Reflect/target:property"}}{{/crossLink}}
 property to a {{#crossLink "ColorTarget"}}ColorTarget{{/crossLink}} that is attached to those {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>
 <li>Similarly, to render depth images of {{#crossLink "Entity"}}Entities{{/crossLink}} to a Reflect, set the Reflect's {{#crossLink "Reflect/target:property"}}{{/crossLink}}
 property to a {{#crossLink "DepthTarget"}}DepthTarget{{/crossLink}} that is attached to those {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>
 <li>For special effects, we often use rendered Reflects in combination with {{#crossLink "Shader"}}Shaders{{/crossLink}} and {{#crossLink "Stage"}}Stages{{/crossLink}}.</li>
 <li>See <a href="Shader.html#inputs">Shader Inputs</a> for the variables that Reflects create within xeoEngine's shaders.</li>
 </ul>

 <img src="../../../assets/images/Reflect.png"></img>

 ## Example

 The example below has:
 <ul>
 <li>three Reflects,</li>
 <li>a {{#crossLink "PhongMaterial"}}{{/crossLink}} which applies the {{#crossLink "Reflect"}}{{/crossLink}}s as diffuse, normal and specular maps,</li>
 <li>a {{#crossLink "Lights"}}{{/crossLink}} containing an {{#crossLink "AmbientLight"}}{{/crossLink}} and a {{#crossLink "PointLight"}}{{/crossLink}},</li>
 <li>a {{#crossLink "Geometry"}}{{/crossLink}} that has the default box shape, and
 <li>an {{#crossLink "Entity"}}{{/crossLink}} attached to all of the above.</li>
 </ul>

 ```` javascript
 var scene = new XEO.Scene();

 var reflect1 = new XEO.Reflect(scene, {
    src: "diffuseMap.jpg"
 });

 var reflect2 = new XEO.Reflect(scene, {
    src: "normalMap.jpg"
 });

 var reflect3 = new XEO.Reflect(scene, {
    src: "specularMap.jpg"
});

 var material = new XEO.PhongMaterial(scene, {
    ambient: [0.3, 0.3, 0.3],
    shininess: 30,
    diffuseMap: reflect1,
    normalMap: reflect2,
    specularMap: reflect3
});

 var light1 = new XEO.PointLight(scene, {
    pos: [0, 100, 100],
    color: [0.5, 0.7, 0.5]
});

 var light2 = new XEO.AmbientLight(scene, {
    color: [0.5, 0.7, 0.5]
});

 var lights = new XEO.Lights(scene, {
    lights: [
        light1,
        light2
    ]
});

 // Geometry without parameters will default to a 2x2x2 box.
 var geometry = new XEO.Geometry(scene);

 var entity = new XEO.Entity(scene, {
    lights: lights,
    material: material,
    geometry: geometry
});
 ````
 @class Reflect
 @module XEO
 @submodule materials
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Reflect in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID for this Reflect, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Reflect.
 @param [cfg.src=null] {String} Path to image file to load into this Reflect. See the {{#crossLink "Reflect/src:property"}}{{/crossLink}} property for more info.
 @param [cfg.image=null] {HTMLImageElement} HTML Image object to load into this Reflect. See the {{#crossLink "Reflect/image:property"}}{{/crossLink}} property for more info.
 @param [cfg.target=null] {String | XEO.ColorTarget | XEO.DepthTarget} Instance or ID of a {{#crossLink "ColorTarget"}}ColorTarget{{/crossLink}} or
 {{#crossLink "DepthTarget"}}DepthTarget{{/crossLink}} to source this Reflect from. See the {{#crossLink "Reflect/target:property"}}{{/crossLink}} property for more info.
 @param [cfg.minFilter="linearMipmapLinear"] {String} How the reflect is sampled when a texel covers less than one pixel. See the {{#crossLink "Reflect/minFilter:property"}}{{/crossLink}} property for more info.
 @param [cfg.magFilter="linear"] {String} How the reflect is sampled when a texel covers more than one pixel. See the {{#crossLink "Reflect/magFilter:property"}}{{/crossLink}} property for more info.
 @param [cfg.wrapS="repeat"] {String} Wrap parameter for reflect coordinate *S*. See the {{#crossLink "Reflect/wrapS:property"}}{{/crossLink}} property for more info.
 @param [cfg.wrapT="repeat"] {String} Wrap parameter for reflect coordinate *S*. See the {{#crossLink "Reflect/wrapT:property"}}{{/crossLink}} property for more info.
 @param [cfg.translate=[0,0]] {Array of Number} 2D translation vector that will be added to reflect's *S* and *T* coordinates.
 @param [cfg.scale=[1,1]] {Array of Number} 2D scaling vector that will be applied to reflect's *S* and *T* coordinates.
 @param [cfg.rotate=0] {Number} Rotation, in degrees, that will be applied to reflect's *S* and *T* coordinates.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Reflect = XEO.Component.extend({

        type: "XEO.Reflect",

        _init: function (cfg) {

            // Rendering state

            this._state = new XEO.renderer.Reflect({
                texture: null
            });

            this._src = [];
            this._images = []; // HTMLImageElement

            // Dirty flags, processed in _buildReflect()

            this._srcDirty = false;
            this._imageDirty = false;

            // Handle WebGL context restore

            this._webglContextRestored = this.scene.canvas.on("webglContextRestored", this._webglContextRestored, this);

            this.src = cfg.src;

            XEO.stats.memory.textures++;
        },

        _webglContextRestored: function () {

            this._state.reflect = null;

            if (this._images) {
                this._imageDirty = true;

            } else if (this._src) {
                this._srcDirty = true;

            }

            this._scheduleUpdate();
        },

        _update: function () {

            var gl = this.scene.canvas.gl;

            var state = this._state;

            if (this._srcDirty) {

                if (this._src) {

                    this._loadSrc(this._src);

                    this._srcDirty = false;

                    // _imageDirty is set when the imagea have loaded

                    return;
                }
            }

            if (this._imageDirty) {

                if (this._images) {

                    state.reflect.setImage(this._image);

                    this._imageDirty = false;
                    this._propsDirty = true; // May now need to regenerate mipmaps etc
                }
            }

            this._renderer.imageDirty = true;
        },


        _loadSrc: function (src) {

            //var task = this.scene.tasks.create({
            //    description: "Loading reflect"
            //});

            var self = this;

            var image = new Image();

            image.onload = function () {

                if (self._src === src) {

                    // Ensure data source was not changed while we were loading

                    // Keep self._src because that's where we loaded the image
                    // from, and we may need to save that in JSON later

                    self._image = XEO.renderer.webgl.ensureImageSizePowerOfTwo(image);

                    self._imageDirty = true;
                    self._srcDirty = false;
                    self._targetDirty = false;

                    self._scheduleUpdate();

                    /**
                     * Fired whenever this Reflect's  {{#crossLink "Reflect/image:property"}}{{/crossLink}} property changes.
                     * @event image
                     * @param value {HTML Image} The property's new value
                     */
                    self.fire("image", self._image);

                    /**
                     * Fired whenever this Reflect has loaded the
                     * image file that its {{#crossLink "Reflect/src:property"}}{{/crossLink}} property currently points to.
                     * @event loaded
                     * @param value {HTML Image} The value of the {{#crossLink "Reflect/src:property"}}{{/crossLink}} property
                     */
                    self.fire("loaded", self._src);
                }

//                task.setCompleted();
            };

            image.onerror = function () {
                //              task.setFailed();
            };

            if (src.indexOf("data") === 0) {

                // Image data
                image.src = src;

            } else {

                // Image file
                image.crossOrigin = "Anonymous";
                image.src = src;
            }
        },

        _props: {

            /**
             * Indicates a path to an image file to source this Reflect from.
             *
             * Alternatively, you could indicate the source via either of properties
             * {{#crossLink "Reflect/image:property"}}{{/crossLink}} or {{#crossLink "Reflect/target:property"}}{{/crossLink}}.
             *
             * Fires a {{#crossLink "Reflect/src:event"}}{{/crossLink}} event on change.
             *
             * Sets the {{#crossLink "Reflect/image:property"}}{{/crossLink}} and
             * {{#crossLink "Reflect/target:property"}}{{/crossLink}} properties to null.
             *
             * @property src
             * @default null
             * @type String
             */
            src: {

                set: function (value) {

                    this._image = null;
                    this._src = value;

                    this._imageDirty = false;
                    this._srcDirty = true;
                    this._targetDirty = false;

                    this._scheduleUpdate();

                    /**
                     * Fired whenever this Reflect's {{#crossLink "Reflect/src:property"}}{{/crossLink}} property changes.
                     * @event src
                     * @param value The property's new value
                     * @type String
                     */
                    this.fire("src", this._src);
                },

                get: function () {
                    return this._src;
                }
            }
        },

        _getJSON: function () {
            return {
                src: this._src.slice(0)
            };
        },

        _destroy: function () {

            this.scene.canvas.off(this._webglContextRestored);

            if (this._state.texture) {
                this._state.texture.destroy();
            }

            XEO.stats.memory.textures--;
        }
    });

})();
;/**
 * Entities.
 *
 * @module XEO
 * @submodule entities
 */;/**
 A **Entity** is an object within a xeoEngine {{#crossLink "Scene"}}Scene{{/crossLink}}.

 ## Overview

 See the {{#crossLink "Scene"}}Scene{{/crossLink}} class documentation for more information on Entities.</li>

 <img src="../../../assets/images/Entity.png"></img>


 ## Boundaries

 #### Local-space

 A Entity provides its Local-space boundary as a {{#crossLink "Boundary3D"}}{{/crossLink}} that encloses
 the {{#crossLink "Geometry"}}{{/crossLink}} {{#crossLink "Geometry/positions:property"}}{{/crossLink}}.</li>

 ```` javascript
 var scene = new XEO.Scene();

 var geometry = new XEO.Geometry(myScene, {
      //...
  });

 var entity = new XEO.Entity(myScene, {
       geometry: myGeometry,
       transform: translate
  });

 // Get the Local-space Boundary3D
 var localBoundary = entity.localBoundary;

 // Get Local-space entity-aligned bounding box (OBB),
 // which is an array of eight vertices that describes
 // the box that is aligned with the Entity's Geometry
 var obb = localBoundary.obb;

 // Get the Local-space axis-aligned bounding box (ABB),
 // which contains the extents of the boundary on each axis
 var aabb = localBoundary.aabb;

 // get the Local-space center of the Entity:
 var center = localBoundary.center;

 ````

 #### World-space

 A Entity provides its World-space boundary as a {{#crossLink "Boundary3D"}}{{/crossLink}} that encloses
 the {{#crossLink "Geometry"}}{{/crossLink}} {{#crossLink "Geometry/positions:property"}}{{/crossLink}} after
 transformation by the Entity's {{#crossLink "Entity/transform:property"}}Modelling transform{{/crossLink}}.</li>


 ```` javascript
 var scene = new XEO.Scene();

 var geometry = new XEO.Geometry(myScene, {
      //...
  });

 var translate = new XEO.Translate(scene, {
    xyz: [-5, 0, 0] // Translate along -X axis
 });

 var entity = new XEO.Entity(myScene, {
       geometry: myGeometry,
       transform: translate
  });

 // Get the World-space Boundary3D
 var worldBoundary = entity.worldBoundary;

 // Get World-space entity-aligned bounding box (OBB),
 // which is an array of eight vertices that describes
 // the box that is aligned with the Entity
 var obb = worldBoundary.obb;

 // Get the World-space axis-aligned bounding box (ABB),
 // which contains the extents of the boundary on each axis
 var aabb = worldBoundary.aabb;

 // get the World-space center of the Entity:
 var center = worldBoundary.center;

 ````

 #### View-space

 A Entity also provides its View-space boundary as a {{#crossLink "Boundary3D"}}{{/crossLink}} that encloses
 the {{#crossLink "Geometry/positions:property"}}Geometry positions{{/crossLink}} after
 their transformation by the {{#crossLink "Camera/view:property"}}View{{/crossLink}} and
 {{#crossLink "Entity/transform:property"}}Modelling{{/crossLink}} transforms.</li>

 ```` javascript
 // Get the View-space Boundary3D
 var viewBoundary = entity.viewBoundary;

 // Get View-space entity-aligned bounding box (OBB),
 // which is an array of eight vertices that describes
 // the box that is aligned with the Entity
 var obb = viewBoundary.obb;

 // Get the View-space axis-aligned bounding box (ABB),
 // which contains the extents of the boundary on each axis
 var aabb = viewBoundary.aabb;

 // get the View-space center of the Entity:
 var center = viewBoundary.center;

 ````

 #### View-space

 A Entity also provides its Canvas-space boundary as a {{#crossLink "Boundary2D"}}{{/crossLink}} that encloses
 the {{#crossLink "Geometry/positions:property"}}Geometry positions{{/crossLink}} after
 their transformation by the {{#crossLink "Entity/transform:property"}}Modelling{{/crossLink}},
 {{#crossLink "Camera/view:property"}}View{{/crossLink}} and {{#crossLink "Camera/project:property"}}Projection{{/crossLink}} transforms.</li>

 ```` javascript
 // Get the Canvas-space Boundary2D
 var canvasBoundary = entity.canvasBoundary;

 // Get the Canvas-space axis-aligned bounding box (ABB),
 // which contains the extents of the boundary on each axis
 var aabb = canvasBoundary.aabb;

 // get the Canvas-space center of the Entity:
 var center = canvasBoundary.center;

 ````

 @class Entity
 @module XEO
 @submodule entities
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Entity within xeoEngine's default {{#crossLink "XEO/scene:property"}}scene{{/crossLink}} by default.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Entity.
 @param [cfg.camera] {String|Camera} ID or instance of a {{#crossLink "Camera"}}Camera{{/crossLink}} to attach to this Entity.  Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/camera:property"}}camera{{/crossLink}}.
 @param [cfg.clips] {String|Clips} ID or instance of a {{#crossLink "Clips"}}Clips{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/clips:property"}}clips{{/crossLink}}.
 @param [cfg.colorTarget] {String|ColorTarget} ID or instance of a {{#crossLink "ColorTarget"}}ColorTarget{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/colorTarget:property"}}colorTarget{{/crossLink}}.
 @param [cfg.depthTarget] {String|DepthTarget} ID or instance of a {{#crossLink "DepthTarget"}}DepthTarget{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/depthTarget:property"}}depthTarget{{/crossLink}}.
 @param [cfg.depthBuf] {String|DepthBuf} ID or instance of a {{#crossLink "DepthBuf"}}DepthBuf{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, depth {{#crossLink "Scene/depthBuf:property"}}depthBuf{{/crossLink}}.
 @param [cfg.visibility] {String|Visibility} ID or instance of a {{#crossLink "Visibility"}}Visibility{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/visibility:property"}}visibility{{/crossLink}}.
 @param [cfg.modes] {String|Modes} ID or instance of a {{#crossLink "Modes"}}Modes{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/modes:property"}}modes{{/crossLink}}.
 @param [cfg.geometry] {String|Geometry} ID or instance of a {{#crossLink "Geometry"}}Geometry{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/geometry:property"}}geometry{{/crossLink}}, which is a 2x2x2 box.
 @param [cfg.layer] {String|Layer} ID or instance of a {{#crossLink "Layer"}}Layer{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/layer:property"}}layer{{/crossLink}}.
 @param [cfg.lights] {String|Lights} ID or instance of a {{#crossLink "Lights"}}Lights{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/lights:property"}}lights{{/crossLink}}.
 @param [cfg.material] {String|Material} ID or instance of a {{#crossLink "Material"}}Material{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/material:property"}}material{{/crossLink}}.
 @param [cfg.morphTargets] {String|MorphTargets} ID or instance of a {{#crossLink "MorphTargets"}}MorphTargets{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s
 default instance, {{#crossLink "Scene/morphTargets:property"}}morphTargets{{/crossLink}}.
 @param [cfg.reflect] {String|Reflect} ID or instance of a {{#crossLink "CubeMap"}}CubeMap{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance,
 {{#crossLink "Scene/reflect:property"}}reflection{{/crossLink}}.
 @param [cfg.shader] {String|Shader} ID or instance of a {{#crossLink "Shader"}}Shader{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance,
 {{#crossLink "Scene/shader:property"}}shader{{/crossLink}}.
 @param [cfg.shaderParams] {String|ShaderParams} ID or instance of a {{#crossLink "ShaderParams"}}ShaderParams{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance,
 {{#crossLink "Scene/shaderParams:property"}}shaderParams{{/crossLink}}.
 @param [cfg.stage] {String|Stage} ID or instance of of a {{#crossLink "Stage"}}Stage{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance,
 {{#crossLink "Scene/stage:property"}}stage{{/crossLink}}.
 @param [cfg.transform] {String|Transform} ID or instance of a modelling transform to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance,
 {{#crossLink "Scene/transform:property"}}transform{{/crossLink}} (which is an identity matrix which performs no transformation).
 @extends Component
 */

/**
 * Fired when this Entity is *picked* via a call to the {{#crossLink "Canvas/pick:method"}}{{/crossLink}} method
 * on the parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas {{/crossLink}}.
 * @event picked
 * @param {String} entityId The ID of this Entity.
 * @param {Number} canvasX The X-axis Canvas coordinate that was picked.
 * @param {Number} canvasY The Y-axis Canvas coordinate that was picked.
 */
(function () {

    "use strict";

    XEO.Entity = XEO.Component.extend({

        type: "XEO.Entity",

        _init: function (cfg) {

            this.camera = cfg.camera;
            this.clips = cfg.clips;
            this.colorTarget = cfg.colorTarget;
            this.colorBuf = cfg.colorBuf;
            this.depthTarget = cfg.depthTarget;
            this.depthBuf = cfg.depthBuf;
            this.visibility = cfg.visibility;
            this.modes = cfg.modes;
            this.geometry = cfg.geometry;
            this.layer = cfg.layer;
            this.lights = cfg.lights;
            this.material = cfg.material;
            this.morphTargets = cfg.morphTargets;
            this.reflect = cfg.reflect;
            this.shader = cfg.shader;
            this.shaderParams = cfg.shaderParams;
            this.stage = cfg.stage;
            this.transform = cfg.transform;
            this.billboard = cfg.billboard;
            this.stationary = cfg.stationary;

            // Cached boundary for each coordinate space
            // The Entity's Geometry component caches the Local-space boundary

            this._worldBoundary = null;
            this._viewBoundary = null;
            this._canvasBoundary = null;

            this._worldBoundaryDirty = true;
            this._viewBoundaryDirty = true;
            this._canvasBoundaryDirty = true;
        },

        _props: {

            /**
             * The {{#crossLink "Camera"}}Camera{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/camera:property"}}camera{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/camera:event"}}{{/crossLink}} event on change.
             *
             * @property camera
             * @type Camera
             */
            camera: {

                set: function (value) {

                    // Invalidate cached World-space bounding boxes

                    this._setViewBoundaryDirty();

                    // Unsubscribe from old Cameras's events

                    var oldCamera = this._children.camera;

                    if (oldCamera) {
                        oldCamera.off(this._onCameraViewMatrix);
                        oldCamera.off(this._onCameraProjMatrix);
                    }

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/camera:property"}}{{/crossLink}} property changes.
                     *
                     * @event camera
                     * @param value The property's new value
                     */
                    this._setChild("camera", value);

                    var newCamera = this._children.camera;

                    if (newCamera) {

                        // Subscribe to new Camera's events

                        this._onCameraViewMatrix = newCamera.on("viewMatrix", this._setViewBoundaryDirty, this);
                        this._onCameraProjMatrix = newCamera.on("projMatrix", this._setCanvasBoundaryDirty, this);
                    }
                },

                get: function () {
                    return this._children.camera;
                }
            },

            /**
             * The {{#crossLink "Clips"}}Clips{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/clips:property"}}clips{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/clips:event"}}{{/crossLink}} event on change.
             *
             * @property clips
             * @type Clips
             */
            clips: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/clips:property"}}{{/crossLink}} property changes.
                     * @event clips
                     * @param value The property's new value
                     */
                    this._setChild("clips", value);
                },

                get: function () {
                    return this._children.clips;
                }
            },

            /**
             * The {{#crossLink "ColorTarget"}}ColorTarget{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/colorTarget:property"}}colorTarget{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/colorTarget:event"}}{{/crossLink}} event on change.
             *
             * @property colorTarget
             * @type ColorTarget
             */
            colorTarget: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/colorTarget:property"}}{{/crossLink}} property changes.
                     * @event colorTarget
                     * @param value The property's new value
                     */
                    this._setChild("colorTarget", value);
                },

                get: function () {
                    return this._children.colorTarget;
                }
            },

            /**
             * The {{#crossLink "ColorBuf"}}ColorBuf{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/colorBuf:property"}}colorBuf{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/colorBuf:event"}}{{/crossLink}} event on change.
             *
             * @property colorBuf
             * @type ColorBuf
             */
            colorBuf: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/colorBuf:property"}}{{/crossLink}} property changes.
                     *
                     * @event colorBuf
                     * @param value The property's new value
                     */
                    this._setChild("colorBuf", value);
                },

                get: function () {
                    return this._children.colorBuf;
                }
            },

            /**
             * The {{#crossLink "DepthTarget"}}DepthTarget{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/depthTarget:property"}}depthTarget{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/depthTarget:event"}}{{/crossLink}} event on change.
             *
             * @property depthTarget
             * @type DepthTarget
             */
            depthTarget: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/depthTarget:property"}}{{/crossLink}} property changes.
                     *
                     * @event depthTarget
                     * @param value The property's new value
                     */
                    this._setChild("depthTarget", value);
                },

                get: function () {
                    return this._children.depthTarget;
                }
            },

            /**
             * The {{#crossLink "DepthBuf"}}DepthBuf{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
             * parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/depthBuf:property"}}depthBuf{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/depthBuf:event"}}{{/crossLink}} event on change.
             *
             * @property depthBuf
             * @type DepthBuf
             */
            depthBuf: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/depthBuf:property"}}{{/crossLink}} property changes.
                     *
                     * @event depthBuf
                     * @param value The property's new value
                     */
                    this._setChild("depthBuf", value);
                },

                get: function () {
                    return this._children.depthBuf;
                }
            },

            /**
             * The {{#crossLink "Visibility"}}Visibility{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/visibility:property"}}visibility{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/visibility:event"}}{{/crossLink}} event on change.
             *
             * @property visibility
             * @type Visibility
             */
            visibility: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/visibility:property"}}{{/crossLink}} property changes.
                     *
                     * @event visibility
                     * @param value The property's new value
                     */
                    this._setChild("visibility", value);
                },

                get: function () {
                    return this._children.visibility;
                }
            },

            /**
             * The {{#crossLink "Modes"}}Modes{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/modes:property"}}modes{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/modes:event"}}{{/crossLink}} event on change.
             *
             * @property modes
             * @type Modes
             */
            modes: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's {{#crossLink "Entity/modes:property"}}{{/crossLink}} property changes.
                     *
                     * @event modes
                     * @param value The property's new value
                     */
                    this._setChild("modes", value);
                },

                get: function () {
                    return this._children.modes;
                }
            },

            /**
             * The {{#crossLink "Geometry"}}Geometry{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/geometry:property"}}camera{{/crossLink}}
             * (a simple box) when set to a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/geometry:event"}}{{/crossLink}} event on change.
             *
             * Updates {{#crossLink "Entity/boundary"}}{{/crossLink}},
             * {{#crossLink "Entity/worldObb"}}{{/crossLink}} and
             * {{#crossLink "Entity/center"}}{{/crossLink}}
             *
             * @property geometry
             * @type Geometry
             */
            geometry: {

                set: function (value) {

                    // Invalidate cached World-space bounding boxes

                    this._setWorldBoundaryDirty();

                    // Unsubscribe from old Geometry's events

                    var oldGeometry = this._children.geometry;

                    if (oldGeometry) {

                        if (!value || (value.id !== undefined ? value.id : value) != oldGeometry.id) {
                            oldGeometry.off(this._onGeometryPositions);
                            oldGeometry.off(this._onGeometryDestroyed);
                        }
                    }

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/geometry:property"}}{{/crossLink}} property changes.
                     *
                     * @event geometry
                     * @param value The property's new value
                     */
                    this._setChild("geometry", value);

                    var newGeometry = this._children.geometry;

                    if (newGeometry) {

                        // Subscribe to new Geometry's events

                        // World-space boundary is dirty when new Geometry's
                        // positions are updated or Geometry is destroyed.

                        this._onGeometryPositions = newGeometry.on("positions", this._setWorldBoundaryDirty, this);
                        this._onGeometryDestroyed = newGeometry.on("destroyed", this._setWorldBoundaryDirty, this);
                    }
                },

                get: function () {
                    return this._children.geometry;
                }
            },

            /**
             * The {{#crossLink "Layer"}}Layer{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/layer:property"}}layer{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/layer:event"}}{{/crossLink}} event on change.
             *
             * @property layer
             * @type Layer
             */
            layer: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/layer:property"}}{{/crossLink}} property changes.
                     *
                     * @event layer
                     * @param value The property's new value
                     */
                    this._setChild("layer", value);
                },

                get: function () {
                    return this._children.layer;
                }
            },

            /**
             * The {{#crossLink "Lights"}}Lights{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/lights:property"}}lights{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/lights:event"}}{{/crossLink}} event on change.
             *
             * @property lights
             * @type Lights
             */
            lights: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/lights:property"}}{{/crossLink}} property changes.
                     *
                     * @event lights
                     * @param value The property's new value
                     */
                    this._setChild("lights", value);
                },

                get: function () {
                    return this._children.lights;
                }
            },

            /**
             * The {{#crossLink "Material"}}Material{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/material:property"}}material{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/material:event"}}{{/crossLink}} event on change.
             *
             * @property material
             * @type Material
             */
            material: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/material:property"}}{{/crossLink}} property changes.
                     *
                     * @event material
                     * @param value The property's new value
                     */
                    this._setChild("material", value);
                },

                get: function () {
                    return this._children.material;
                }
            },

            /**
             * The {{#crossLink "MorphTargets"}}MorphTargets{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/morphTargets:property"}}morphTargets{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/morphTargets:event"}}{{/crossLink}} event on change.
             *
             * @property morphTargets
             * @type MorphTargets
             */
            morphTargets: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/morphTargets:property"}}{{/crossLink}} property changes.
                     * @event morphTargets
                     * @param value The property's new value
                     */
                    this._setChild("morphTargets", value);
                },

                get: function () {
                    return this._children.morphTargets;
                }
            },

            /**
             * The {{#crossLink "Reflect"}}Reflect{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/reflect:property"}}reflect{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/reflect:event"}}{{/crossLink}} event on change.
             *
             * @property reflect
             * @type Reflect
             */
            reflect: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/reflect:property"}}{{/crossLink}} property changes.
                     *
                     * @event reflect
                     * @param value The property's new value
                     */
                    this._setChild("reflect", value);
                },

                get: function () {
                    return this._children.reflect;
                }
            },

            /**
             * The {{#crossLink "Shader"}}Shader{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/shader:property"}}shader{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/shader:event"}}{{/crossLink}} event on change.
             *
             * @property shader
             * @type Shader
             */
            shader: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/shader:property"}}{{/crossLink}} property changes.
                     * @event shader
                     * @param value The property's new value
                     */
                    this._setChild("shader", value);
                },

                get: function () {
                    return this._children.shader;
                }
            },

            /**
             * The {{#crossLink "ShaderParams"}}ShaderParams{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/shaderParams:property"}}shaderParams{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/shaderParams:event"}}{{/crossLink}} event on change.
             *
             * @property shaderParams
             * @type ShaderParams
             */
            shaderParams: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/shaderParams:property"}}{{/crossLink}} property changes.
                     *
                     * @event shaderParams
                     * @param value The property's new value
                     */
                    this._setChild("shaderParams", value);
                },

                get: function () {
                    return this._children.shaderParams;
                }
            },

            /**
             * The {{#crossLink "Stage"}}Stage{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/stage:property"}}stage{{/crossLink}} when set to
             * a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/stage:event"}}{{/crossLink}} event on change.
             *
             * @property stage
             * @type Stage
             */
            stage: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's  {{#crossLink "Entity/stage:property"}}{{/crossLink}} property changes.
                     *
                     * @event stage
                     * @param value The property's new value
                     */
                    this._setChild("stage", value);
                },

                get: function () {
                    return this._children.stage;
                }
            },

            /**
             * The Local-to-World-space (modelling) {{#crossLink "Transform"}}{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/transform:property"}}transform{{/crossLink}}
             * (an identity matrix) when set to a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/transform:event"}}{{/crossLink}} event on change.
             *
             * Updates {{#crossLink "Entity/boundary"}}{{/crossLink}},
             * {{#crossLink "Entity/worldObb"}}{{/crossLink}} and
             * {{#crossLink "Entity/center"}}{{/crossLink}}
             *
             * @property transform
             * @type Transform
             */
            transform: {

                set: function (value) {

                    // Invalidate cached World-space bounding boxes

                    this._setWorldBoundaryDirty();

                    // Unsubscribe from old Transform's events

                    var oldTransform = this._children.transform;

                    if (oldTransform && (!value || value.id !== oldTransform.id)) {
                        oldTransform.off(this._onTransformUpdated);
                        oldTransform.off(this._onTransformDestroyed);
                    }

                    /**
                     * Fired whenever this Entity's {{#crossLink "Entity/transform:property"}}{{/crossLink}}
                     * property changes.
                     *
                     * @event transform
                     * @param value The property's new value
                     */
                    this._setChild("transform", value);

                    // Subscribe to new Transform's events

                    var newTransform = this._children.transform;

                    if (newTransform) {

                        // World-space boundary is dirty when Transform's
                        // matrix is updated or Transform is destroyed.

                        var self = this;

                        this._onTransformUpdated = newTransform.on("updated",
                            function () {
                                if (self._transformDirty) {
                                    return;
                                }
                                self._transformDirty = true;
                                XEO.scheduleTask(function () {
                                    if (!self._transformDirty) {
                                        return;
                                    }
                                    newTransform._buildLeafMatrix();

                                    self._setWorldBoundaryDirty();
                                    self._transformDirty = false;
                                });
                            });

                        this._onTransformDestroyed = newTransform.on("destroyed",this._setWorldBoundaryDirty,this);
                    }
                },

                get: function () {
                    return this._children.transform;
                }
            },

            /**
             * The {{#crossLink "Billboard"}}{{/crossLink}} attached to this Entity.
             *
             * When {{#crossLink "Billboard/property:active"}}{{/crossLink}}, the {{#crossLink "Billboard"}}{{/crossLink}}
             * will keep this Entity oriented towards the viewpoint.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/billboard:property"}}billboard{{/crossLink}}
             * (an identity matrix) when set to a null or undefined value.
             *
             * Fires an {{#crossLink "Entity/billboard:event"}}{{/crossLink}} event on change.
             *
             * @property billboard
             * @type Billboard
             */
            billboard: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's {{#crossLink "Entity/billboard:property"}}{{/crossLink}}
                     * property changes.
                     *
                     * @event billboard
                     * @param value The property's new value
                     */
                    this._setChild("billboard", value);
                },

                get: function () {
                    return this._children.billboard;
                }
            },

            /**
             * The {{#crossLink "Stationary"}}{{/crossLink}} attached to this Entity.
             *
             * When {{#crossLink "Stationary/property:active"}}{{/crossLink}}, the {{#crossLink "Stationary"}}{{/crossLink}}
             * will prevent the translation component of the viewing transform from being applied to this Entity, yet
             * still allowing it to rotate.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/stationary:property"}}stationary{{/crossLink}},
             * which is disabled by default.
             *
             * Fires an {{#crossLink "Entity/stationary:event"}}{{/crossLink}} event on change.
             *
             * @property stationary
             * @type Stationary
             */
            stationary: {

                set: function (value) {

                    /**
                     * Fired whenever this Entity's {{#crossLink "Entity/stationary:property"}}{{/crossLink}}
                     * property changes.
                     *
                     * @event stationary
                     * @param value The property's new value
                     */
                    this._setChild("stationary", value);
                },

                get: function () {
                    return this._children.stationary;
                }
            },

            /**
             * Local-space 3D boundary of this Entity.
             *
             * This is a {{#crossLink "Boundary3D"}}{{/crossLink}} that encloses
             * the {{#crossLink "Geometry"}}{{/crossLink}} that is attached to this Entity.
             *
             * The {{#crossLink "Boundary3D"}}{{/crossLink}} will fire an {{#crossLink "Boundary3D/updated:event"}}{{/crossLink}}
             * event whenever this Entity's {{#crossLink "Entity/geometry:property"}}{{/crossLink}} is linked to
             * a new {{#crossLink "Geometry"}}{{/crossLink}}, or whenever the {{#crossLink "Geometry"}}{{/crossLink}}'s
             * {{#crossLink "Geometry/positions:property"}}{{/crossLink}} are updated.
             *
             * The a {{#crossLink "Boundary3D"}}{{/crossLink}} is lazy-instantiated the first time that this
             * property is referenced. If {{#crossLink "Component/destroy:method"}}{{/crossLink}} is then called on it,
             * then this property will be assigned to a fresh {{#crossLink "Boundary3D"}}{{/crossLink}} instance next
             * time it's referenced.
             *
             * @property localBoundary
             * @type Boundary3D
             * @final
             */
            localBoundary: {

                get: function () {
                    return this._children.geometry.localBoundary;
                }
            },

            /**
             * World-space 3D boundary of this Entity.
             *
             * This is a {{#crossLink "Boundary3D"}}{{/crossLink}} that encloses the {{#crossLink "Geometry"}}{{/crossLink}}
             * that is attached to this Entity after transformation by this Entity's modelling
             * {{#crossLink "Entity/transform:property"}}{{/crossLink}}.
             *
             * The {{#crossLink "Boundary3D"}}{{/crossLink}} will fire an {{#crossLink "Boundary3D/updated:event"}}{{/crossLink}}
             * event whenever this Entity's {{#crossLink "Entity/geometry:property"}}{{/crossLink}} is linked to
             * a new {{#crossLink "Geometry"}}{{/crossLink}}, or whenever the {{#crossLink "Geometry"}}{{/crossLink}}'s
             * {{#crossLink "Geometry/positions:property"}}{{/crossLink}} are updated.
             *
             * The a {{#crossLink "Boundary3D"}}{{/crossLink}} is lazy-instantiated the first time that this
             * property is referenced. If {{#crossLink "Component/destroy:method"}}{{/crossLink}} is then called on it,
             * then this property will be assigned to a fresh {{#crossLink "Boundary3D"}}{{/crossLink}} instance next
             * time it's referenced.
             *
             * <h4>Example</h4>
             *
             * [here](http://xeoengine.org/examples/#boundaries_Entity_worldBoundary)
             *
             * <h4>Performance</h4>
             *
             * To minimize performance overhead, only reference this property if you need it, and destroy
             * the {{#crossLink "Boundary3D"}}{{/crossLink}} as soon as you don't need it anymore.
             *
             * @property worldBoundary
             * @type Boundary3D
             * @final
             */
            worldBoundary: {

                get: function () {

                    if (!this._worldBoundary) {

                        var self = this;

                        // this._setWorldBoundaryDirty();

                        this._worldBoundary = new XEO.Boundary3D(this.scene, {

                            meta: {
                                desc: "Entity " + self.id + " World-space boundary" // For debugging
                            },

                            getDirty: function () {
                                if (self._worldBoundaryDirty) {
                                    self._worldBoundaryDirty = false;
                                    return true;
                                }
                                return false;
                            },

                            // Faster and less precise than getPositions:
                            getOBB: function () {
                                var geometry = self._children.geometry;
                                if (geometry) {
                                    var boundary = geometry.localBoundary;
                                    return boundary.obb;
                                }
                            },

                            //getPositions: function () {
                            //    return self._children.geometry.positions;
                            //},

                            getMatrix: function () {

                                var transform = self._children.transform;

                                if (self._transformDirty) {
                                    transform._buildLeafMatrix();
                                    self._setWorldBoundaryDirty();
                                    self._transformDirty = false;
                                }

                                return transform.leafMatrix;
                            }
                        });

                        this._worldBoundary.on("destroyed",
                            function () {
                                self._worldBoundary = null;
                            });
                    }

                    return this._worldBoundary;
                }
            },

            /**
             * View-space 3D boundary of this Entity.
             *
             * This is a {{#crossLink "Boundary3D"}}{{/crossLink}} that encloses the {{#crossLink "Geometry"}}{{/crossLink}}
             * that is attached to this Entity after transformation by this Entity's modelling
             * {{#crossLink "Entity/transform:property"}}{{/crossLink}} and {{#crossLink "Camera"}}{{/crossLink}}
             * {{#crossLink "Camera/view:property"}}view transform{{/crossLink}}.
             *
             * The {{#crossLink "Boundary3D"}}{{/crossLink}} will fire an {{#crossLink "Boundary3D/updated:event"}}{{/crossLink}}
             * event whenever there are any changes to the {{#crossLink "Geometry"}}{{/crossLink}},
             * {{#crossLink "Entity/transform:property"}}{{/crossLink}} or {{#crossLink "Camera"}}{{/crossLink}} that
             * would affect its extents.
             *
             * The a {{#crossLink "Boundary3D"}}{{/crossLink}} is lazy-instantiated the first time that this
             * property is referenced. If {{#crossLink "Component/destroy:method"}}{{/crossLink}} is then called on it,
             * then this property will be assigned to a fresh {{#crossLink "Boundary3D"}}{{/crossLink}} instance next
             * time it's referenced.
             *
             * <h4>Performance</h4>
             *
             * To minimize performance overhead, only reference this property if you need it, and destroy
             * the {{#crossLink "Boundary3D"}}{{/crossLink}} as soon as you don't need it anymore.
             *
             * @property viewBoundary
             * @type Boundary3D
             * @final
             */
            viewBoundary: {

                get: function () {

                    if (!this._viewBoundary) {

                        var self = this;

                        //     this._setViewBoundaryDirty();

                        this._viewBoundary = new XEO.Boundary3D(this.scene, {

                            meta: {
                                desc: "Entity " + self.id + " View-space boundary" // For debugging
                            },

                            getDirty: function () {
                                if (self._viewBoundaryDirty) {
                                    self._viewBoundaryDirty = false;
                                    return true;
                                }
                                return false;
                            },

                            getOBB: function () {
                                return self.worldBoundary.obb;
                            },

                            getMatrix: function () {
                                return self._children.camera.view.matrix;
                            }
                        });

                        this._viewBoundary.on("destroyed",
                            function () {
                                self._viewBoundary = null;
                            });
                    }

                    return this._viewBoundary;
                }
            },

            /**
             * Canvas-space 2D boundary.
             *
             * This is a {{#crossLink "Boundary2D"}}{{/crossLink}} that encloses this Entity's
             * {{#crossLink "Entity/geometry:property"}}{{/crossLink}} after transformation by this Entity's modelling
             * {{#crossLink "Entity/transform:property"}}{{/crossLink}} and {{#crossLink "Camera"}}{{/crossLink}}
             * {{#crossLink "Camera/view:property"}}view{{/crossLink}} and
             * {{#crossLink "Camera/project:property"}}projection{{/crossLink}} transforms.
             *
             * The {{#crossLink "Boundary2D"}}{{/crossLink}} will fire an {{#crossLink "Boundary3D/updated:event"}}{{/crossLink}}
             * event whenever there are any changes to the {{#crossLink "Geometry"}}{{/crossLink}},
             * {{#crossLink "Entity/transform:property"}}{{/crossLink}} or {{#crossLink "Camera"}}{{/crossLink}} that
             * would affect its extents.
             *
             * The a {{#crossLink "Boundary2D"}}{{/crossLink}} is lazy-instantiated the first time that this
             * property is referenced. If {{#crossLink "Component/destroy:method"}}{{/crossLink}} is then called on it,
             * then this property will be assigned to a fresh {{#crossLink "Boundary2D"}}{{/crossLink}} instance next
             * time it's referenced.
             *
             * <h4>Performance</h4>
             *
             * To minimize performance overhead, only reference this property if you need it, and destroy
             * the {{#crossLink "Boundary2D"}}{{/crossLink}} as soon as you don't need it anymore.
             *
             * @property canvasBoundary
             * @type Boundary2D
             * @final
             */
            canvasBoundary: {

                get: function () {

                    if (!this._canvasBoundary) {

                        var self = this;

                        //   this._setCanvasBoundaryDirty();

                        this._canvasBoundary = new XEO.Boundary2D(this.scene, {

                            meta: {
                                desc: "Entity " + self.id + " Canvas-space boundary" // For debugging
                            },

                            getDirty: function () {
                                if (self._canvasBoundaryDirty) {
                                    self._canvasBoundaryDirty = false;
                                    return true;
                                }
                                return false;
                            },

                            getOBB: function () {
                                return self.viewBoundary.obb;
                            },

                            getMatrix: function () {
                                return self._children.camera.project.matrix;
                            }
                        });

                        this._canvasBoundary.on("destroyed",
                            function () {
                                self._canvasBoundary = null;
                            });
                    }

                    return this._canvasBoundary;
                }
            },

            /**
             * JSON object containing the (GLSL) source code of the shaders for this Entity.
             *
             * This is sometimes useful to have as a reference
             * when constructing your own custom {{#crossLink "Shader"}}{{/crossLink}} components.
             *
             * Will return null if xeoEngine has not yet rendered this Entity.
             *
             * @property glsl
             * @type JSON
             * @final
             */
            glsl: {

                get: function () {
                    var rendererObject = this._renderer.objects[this.id];
                    if (!rendererObject) {
                        return null;
                    }
                    var source = rendererObject.program.program.source;
                    return {
                        draw: {
                            vertex: source.vertexDraw,
                            fragment: source.fragmentDraw
                        },
                        pickObject: {
                            vertex: source.vertexPickObject,
                            fragment: source.fragmentPickObject
                        },
                        pickPrimitive: {
                            vertex: source.vertexPickPrimitive,
                            fragment: source.fragmentPickPrimitive
                        }
                    };
                }
            },

            /**
             * The (GLSL) source code of the shaders for this Entity, as a string.
             *
             * This is sometimes useful to have as a reference
             * when constructing your own custom {{#crossLink "Shader"}}{{/crossLink}} components.
             *
             * Will return null if xeoEngine has not yet rendered this Entity.
             *
             * @property glslString
             * @type String
             * @final
             */
            glslString: {

                get: function () {
                    var glsl = this.glsl;
                    if (glsl) {
                        return JSON.stringify(glsl, "\n", 4);
                    }
                }
            }
        },

        // Callbacks as members, to avoid GC churn

        _setWorldBoundaryDirty: function () {
            this._worldBoundaryDirty = true;
            if (this._worldBoundary) {
                this._worldBoundary.fire("updated", true);
            }
            this._setViewBoundaryDirty();
        },

        _setViewBoundaryDirty: function () {
            this._viewBoundaryDirty = true;
            if (this._viewBoundary) {
                this._viewBoundary.fire("updated", true);
            }
            this._setCanvasBoundaryDirty();
        },

        _setCanvasBoundaryDirty: function () {
            this._canvasBoundaryDirty = true;
            if (this._canvasBoundary) {
                this._canvasBoundary.fire("updated", true);
            }
        },

        // Returns true if there is enough on this Entity to render something.
        _valid: function () {
            var geometry = this._children.geometry;
            return geometry && geometry.positions && geometry.indices;

        },

        _compile: function () {

            var children = this._children;

            children.camera._compile();
            children.clips._compile();
            children.colorTarget._compile();
            children.colorBuf._compile();
            children.depthTarget._compile();
            children.depthBuf._compile();
            children.visibility._compile();
            children.modes._compile();
            children.geometry._compile();
            children.layer._compile();
            children.lights._compile();
            children.material._compile();
            //children.morphTargets._compile();
            children.reflect._compile();
            children.shader._compile();
            children.shaderParams._compile();
            children.stage._compile();
            children.transform._compile();
            children.billboard._compile();
            children.stationary._compile();

            // (Re)build this Entity in the renderer; for each Entity in teh scene graph,
            // there is an "object" in the renderer, that has the same ID as the entity

            var objectId = this.id;

            var result = this._renderer.buildObject(objectId);

            if (result && result.error) {

                // Object has errors, probably due to
                // shader not allocating/compiling/linking.

                this.error(result.errorLog.join("\n"));
            }
        },

        _getJSON: function () {

            var children = this._children;

            return {
                camera: children.camera.id,
                clips: children.clips.id,
                colorTarget: children.colorTarget.id,
                colorBuf: children.colorBuf.id,
                depthTarget: children.depthTarget.id,
                depthBuf: children.depthBuf.id,
                visibility: children.visibility.id,
                modes: children.modes.id,
                geometry: children.geometry.id,
                layer: children.layer.id,
                lights: children.lights.id,
                material: children.material.id,
                reflect: children.reflect.id,
                shader: children.shader.id,
                shaderParams: children.shaderParams.id,
                stage: children.stage.id,
                transform: children.transform.id,
                billboard: children.billboard.id,
                stationary: children.stationary.id
            };
        },

        _destroy: function () {

            if (this._children.transform) {
                this._children.transform.off(this._onTransformUpdated);
                this._children.transform.off(this._onTransformDestroyed);
            }

            if (this._children.geometry) {
                this._children.geometry.off(this._onGeometryDirty);
                this._children.geometry.off(this._onGeometryPositions);
                this._children.geometry.off(this._onGeometryDestroyed);
            }

            if (this._worldBoundary) {
                this._worldBoundary.destroy();
            }

            if (this._viewBoundary) {
                this._viewBoundary.destroy();
            }

            if (this._canvasBoundary) {
                this._canvasBoundary.destroy();
            }

            this._renderer.removeObject(this.id);
        }
    });

})();
;/**
 * Components that influence the way entities are rendered with WebGL.
 *
 * @module XEO
 * @submodule rendering
 */;/**
 A **ColorBuf** configures the WebGL color buffer for attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>

 <li>A ColorBuf configures **the way** that pixels are written to the WebGL color buffer.</li>
 <li>ColorBuf is not to be confused with {{#crossLink "ColorTarget"}}ColorTarget{{/crossLink}}, which stores rendered pixel
 colors for consumption by {{#crossLink "Texture"}}Textures{{/crossLink}}, used when performing *render-to-texture*.</li>

 </ul>

 <img src="../../../assets/images/ColorBuf.png"></img>

 ## Example

 In this example we're configuring the WebGL color buffer for an {{#crossLink "Entity"}}{{/crossLink}}.

 This example scene contains:

 <ul>
 <li>a ColorBuf that enables blending and sets the color mask,</li>
 <li>a {{#crossLink "Geometry"}}{{/crossLink}} that is the default box shape, and
 <li>an {{#crossLink "Entity"}}{{/crossLink}} attached to all of the above.</li>
 </ul>

 ````javascript
 var scene = new XEO.Scene();

 var colorBuf = new XEO.ColorBuf(scene, {
    blendEnabled: true,
    colorMask: [true, true, true, true]
});

 var geometry = new XEO.Geometry(scene); // Defaults to a 2x2x2 box

 var Entity = new XEO.Entity(scene, {
    colorBuf: colorBuf,
    geometry: geometry
});
 ````

 @class ColorBuf
 @module XEO
 @submodule rendering
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this ColorBuf within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} ColorBuf configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this ColorBuf.
 @param [cfg.blendEnabled=false] {Boolean} Indicates if blending is enabled.
 @param [cfg.colorMask=[true, true, true, true]] {Array of Boolean} The color mask,
 @extends Component
 */
(function () {

    "use strict";

    XEO.ColorBuf = XEO.Component.extend({

        type: "XEO.ColorBuf",

        _init: function (cfg) {

            this._state = new XEO.renderer.ColorBuf({
                blendEnabled: false,
                colorMask: [true, true, true, true]
            });

            this.blendEnabled = cfg.blendEnabled;
            this.colorMask = cfg.colorMask;
        },

        _props: {

            /**
             * Indicates if blending is enabled for this ColorBuf.
             *
             * Fires a {{#crossLink "ColorBuf/blendEnabled:event"}}{{/crossLink}} event on change.
             *
             * @property blendEnabled
             * @default false
             * @type Boolean
             */
            blendEnabled: {

                set: function (value) {

                    this._state.blendEnabled = value === true;

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this ColorBuf's {{#crossLink "ColorBuf/blendEnabled:property"}}{{/crossLink}} property changes.

                     @event blendEnabled
                     @param value {Boolean} The property's new value
                     */
                    this.fire("blendEnabled", this._state.blendEnabled);
                },

                get: function () {
                    return this._state.blendEnabled;
                }
            },

            /**
             * Specifies whether red, green, blue, and alpha can or cannot be written into the frame buffer.
             *
             * Fires a {{#crossLink "ColorBuf/colorMask:event"}}{{/crossLink}} event on change.
             *
             * @property colorMask
             * @default [true, true, true, true]
             * @type {Four element array of Boolean}
             */
            colorMask: {

                set: function (value) {

                    this._state.colorMask = value || [true, true, true, true];

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this ColorBuf's {{#crossLink "ColorBuf/colorMask:property"}}{{/crossLink}} property changes.

                     @event colorMask
                     @param value {Four element array of Boolean} The property's new value
                     */
                    this.fire("colorMask", this._state.colorMask);
                },

                get: function () {
                    return this._state.colorMask;
                }
            }
        },

        _compile: function () {
            this._renderer.colorBuf = this._state;
        },

        _getJSON: function () {
            return {
                blendEnabled: this._state.blendEnabled,
                colorMask: this._state.colorMask
            };
        },

        _destroy: function () {
            this._state.destroy();
        }
    });

})();
;/**
 A **DepthBuf** configures the WebGL depth buffer for attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>
 <li>A DepthBuf configures **the way** that pixel depths are written to the WebGL depth buffer</li>
 <li>DepthBuf is not to be confused with {{#crossLink "DepthTarget"}}DepthTarget{{/crossLink}}, which stores rendered pixel
 depths for consumption by {{#crossLink "Texture"}}Textures{{/crossLink}}, used when performing *render-to-texture*.</li>
 </ul>

 <img src="../../../assets/images/DepthBuf.png"></img>

 ## Example

 In this example we're configuring the WebGL depth buffer for an {{#crossLink "Entity"}}{{/crossLink}}.

 The scene contains:

 <ul>
 <li>a DepthBuf that configures the clear depth and depth comparison function,</li>
 <li>a {{#crossLink "Geometry"}}{{/crossLink}} that is the default box shape and
 <li>an {{#crossLink "Entity"}}{{/crossLink}} attached to all of the above.</li>
 </ul>

 ````javascript
 var scene = new XEO.Scene();

 // Create a DepthBuf that configures the WebGL depth buffer to set pixels depths to 0.5
 // whenever it is cleared, and to use the "less" depth comparison function
 var depthBuf = new XEO.DepthBuf(scene, {
    clearDepth: 0.5,
    depthFunc: "less"
});

 var geometry = new XEO.Geometry(scene); // Defaults to a 2x2x2 box

 // Create a Entity that renders the Geometry to the depth buffer,
 // as configured by our DepthBuf
 var Entity = new XEO.Entity(scene, {
    depthBuf: depthBuf,
    geometry: geometry
});
 ````

 @class DepthBuf
 @module XEO
 @submodule rendering
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this DepthBuf
 within the default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} DepthBuf configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this DepthBuf.
 @param [cfg.clearDepth=1.0] {Number} The clear depth.
 @param [cfg.depthFunc="less"] {String} The depth function.
 @param [cfg.active=true] {Boolean} True when this DepthBuf is active.
 @extends Component
 */
(function () {

    "use strict";

    XEO.DepthBuf = XEO.Component.extend({

        type: "XEO.DepthBuf",

        _init: function (cfg) {

            this._state = new XEO.renderer.DepthBuf({
                clearDepth: null,
                depthFunc: null,
                active: null
            });

            this.clearDepth = cfg.clearDepth;
            this.depthFunc = cfg.depthFunc;
            this.active = cfg.active;
        },

        _props: {

            /**
             * The clear depth for this DepthBuf.
             *
             * Fires a {{#crossLink "DepthBuf/clearDepth:event"}}{{/crossLink}} event on change.
             *
             * @property clearDepth
             * @default 1.0
             * @type Number
             */
            clearDepth: {

                set: function (value) {

                    this._state.clearDepth = value !== undefined ? value : 1.0;

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this DepthBuf's {{#crossLink "DepthBuf/clearDepth:property"}}{{/crossLink}} property changes.

                     @event clearDepth
                     @param value {Number} The property's new value
                     */
                    this.fire("clearDepth",  this._state.clearDepth);
                },

                get: function () {
                    return this._state.clearDepth;
                }
            },

            /**
             * The depth function for this DepthBuf.
             *
             * Accepted values are:
             *
             * <ul>
             *     <li>"less"</li>
             *     <li>"equal"</li>
             *     <li>"lequal"</li>
             *     <li>"greater"</li>
             *     <li>"notequal"</li>
             *     <li>"gequal"</li>
             * </ul>
             *
             * Fires a {{#crossLink "DepthBuf/depthFunc:event"}}{{/crossLink}} event on change.
             *
             * @property depthFunc
             * @default "less"
             * @type Number
             */
            depthFunc: {

                set: function (value) {

                    value = value || "less";

                    var enumName = this._depthFuncNames[value];

                    if (enumName === undefined) {
                        this.error("Unsupported value for 'clearFunc': '" + value +
                            "' - supported values are 'less', 'equal', 'lequal', 'greater', 'notequal' and 'gequal. " +
                            "Defaulting to 'less'.");

                        enumName = "less";
                    }

                    this._state.depthFunc = this.scene.canvas.gl[enumName];
                    this._state.depthFuncName = value;

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this DepthBuf's {{#crossLink "DepthBuf/depthFunc:property"}}{{/crossLink}} property changes.
                     @event depthFunc
                     @param value {String} The property's new value
                     */
                    this.fire("depthFunc", this._state.depthFuncName);
                },

                get: function () {
                    return this._state.depthFuncName;
                }
            },

            /**
             * Flag which indicates whether this DepthBuf is active or not.
             *
             * Fires an {{#crossLink "DepthBuf/active:event"}}{{/crossLink}} event on change.
             *
             * @property active
             * @type Boolean
             */
            active: {

                set: function (value) {

                    if (this._state.active === value) {
                        return;
                    }

                    this._state.active = value;

                    /**
                     * Fired whenever this DepthBuf's {{#crossLink "DepthBuf/active:property"}}{{/crossLink}} property changes.
                     * @event active
                     * @param value The property's new value
                     */
                    this.fire('active', this._state.active);
                },

                get: function () {
                    return this._state.active;
                }
            }
        },

        /**
         * Lookup GL depth function enums
         * @private
         */
        _depthFuncNames: {
            less: "LESS",
            equal: "EQUAL",
            lequal: "LEQUAL",
            greater: "GREATER",
            notequal: "NOTEQUAL",
            gequal: "GEQUAL"
        },

        _compile: function () {
            this._renderer.depthBuf = this._state;
        },

        _getJSON: function () {
            return {
                clearDepth: this._state.clearDepth,
                depthFunc: this._state.depthFuncName,
                active: this._state.active
            };
        },

        _destroy: function () {
            this._state.destroy();
        }
    });

})();
;/**
 A **Layer** specifies the render order of {{#crossLink "Entity"}}Entities{{/crossLink}} within their {{#crossLink "Stage"}}Stages{{/crossLink}}.

 ## Overview

 <ul>
 <li>When xeoEngine renders a {{#crossLink "Scene"}}Scene{{/crossLink}}, each {{#crossLink "Stage"}}Stage{{/crossLink}} within that will render its bin
 of {{#crossLink "Entity"}}Entities{{/crossLink}} in turn, from the lowest priority {{#crossLink "Stage"}}Stage{{/crossLink}} to the highest.</li>

 <li>{{#crossLink "Stage"}}Stages{{/crossLink}} are typically used for ordering the render-to-texture steps in posteffects pipelines.</li>

 <li>You can control the render order of the individual {{#crossLink "Entity"}}Entities{{/crossLink}} ***within*** a {{#crossLink "Stage"}}Stage{{/crossLink}}
 by associating them with {{#crossLink "Layer"}}Layers{{/crossLink}}.</li>

 <li>{{#crossLink "Layer"}}Layers{{/crossLink}} are typically used to <a href="https://www.opengl.org/wiki/Transparency_Sorting" target="_other">transparency-sort</a> the
 {{#crossLink "Entity"}}Entities{{/crossLink}} within {{#crossLink "Stage"}}Stages{{/crossLink}}.</li>


 <li>{{#crossLink "Entity"}}Entities{{/crossLink}} not explicitly attached to a Layer are implicitly
 attached to the {{#crossLink "Scene"}}Scene{{/crossLink}}'s default
 {{#crossLink "Scene/layer:property"}}layer{{/crossLink}}. which has
 a {{#crossLink "Layer/priority:property"}}{{/crossLink}} value of zero.</li>

 <li>You can use Layers without defining any {{#crossLink "Stage"}}Stages{{/crossLink}} if you simply let your
 {{#crossLink "Entity"}}Entities{{/crossLink}} fall back on the {{#crossLink "Scene"}}Scene{{/crossLink}}'s default
 {{#crossLink "Scene/stage:property"}}stage{{/crossLink}}. which has a {{#crossLink "Stage/priority:property"}}{{/crossLink}} value of zero.</li>
 </ul>

 <img src="../../../assets/images/Layer.png"></img>

 ## Example

 In this example we'll use Layers to perform <a href="https://www.opengl.org/wiki/Transparency_Sorting" target="_other">transparency sorting</a>,
 which ensures that transparent entities are rendered farthest-to-nearest, so that they alpha-blend correctly with each other.

 We want to render the three nested boxes shown below, in which the innermost box is opaque and blue,
 the box enclosing that is transparent and yellow, and the outermost box is transparent and green. We need the boxes to
 render in order innermost-to-outermost, in order to blend transparencies correctly.

 <img src="../../assets/images/transparencySort.jpg"></img>

 Our scene has one {{#crossLink "Stage"}}{{/crossLink}}, just for completeness. As mentioned earlier, you don't have to
 create this because the {{#crossLink "Scene"}}{{/crossLink}} will provide its default {{#crossLink "Stage"}}{{/crossLink}}.
 Then, within that {{#crossLink "Stage"}}{{/crossLink}}, we create an {{#crossLink "Entity"}}{{/crossLink}} for each box,
 each assigned to a different prioritised {{#crossLink "Layer"}}{{/crossLink}} to ensure that they are rendered in the right order.

 ````javascript
 var scene = new XEO.Scene();

 // View transform
 var lookat = new XEO.Lookat(scene, {
    eye: [0,0,10]
});

 // Camera, using Scene's default projection transform
 var camera = new XEO.Camera(scene, {
    view: lookat
});

 // A Stage, just for completeness
 // We could instead just implicitly use the Scene's default Stage
 var stage = new XEO.Stage(scene, {
    priority: 0
});

 // Geometry with no parameters defaults to a 2x2x2 box
 var geometry = new XEO.Geometry(scene);

 //-----------------------------------------------------------------------------
 // Innermost box
 // Blue and opaque, in Layer with render order 0, renders first
 //-----------------------------------------------------------------------------

 var layer1 = new XEO.Layer(scene, {
    priority: 1
});

 var material1 = new XEO.PhongMaterial(scene, {
    diffuse: [0.2, 0.2, 1.0],
    opacity: 1.0
});

 var entity1 = new XEO.Entity(scene, {
    camera: camera,
    geometry: geometry,
    stage: stage,
    layer: layer1,
    material: material1
});

 //-----------------------------------------------------------------------------
 // Middle box
 // Red and transparent, in Layer with render order 2, renders next
 //-----------------------------------------------------------------------------

 var layer2 = new XEO.Layer(scene, {
    priority: 2
});

 var material2 = new XEO.PhongMaterial(scene, {
    diffuse: [1, 0.2, 0.2],
    opacity: 0.2
});

 var scale2 = new XEO.Scale(scene, {
    xyz: [6, 6, 6]
});

 var entity2 = new XEO.Entity(scene, {
    camera: camera,
    geometry: geometry,
    stage: stage,
    layer: layer2,
    material: material2,
    scale: scale2
});

 //-----------------------------------------------------------------------------
 // Outermost box
 // Green and transparent, in Layer with render order 3, renders last
 //-----------------------------------------------------------------------------

 var layer3 = new XEO.Layer(scene, {
    priority: 3
});

 var material3 = new XEO.PhongMaterial(scene, {
    diffuse: [0.2, 1, 0.2],
    opacity: 0.2
});

 var scale3 = new XEO.Scale(scene, {
    xyz: [9, 9, 9]
});

 var entity3 = new XEO.Entity(scene, {
    camera: camera,
    geometry: geometry,
    stage: stage,
    layer: layer3,
    material: material3,
    scale: scale3
});

 ````

 @class Layer
 @module XEO
 @submodule rendering
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Geometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Layer.
 @param [cfg.priority=0] {Number} The rendering priority,
 @extends Component
 */
(function () {

    "use strict";

    XEO.Layer = XEO.Component.extend({

        type: "XEO.Layer",

        _init: function (cfg) {

            this._state = new XEO.renderer.Layer({
                priority: null
            });

            this.priority = cfg.priority;
        },

        _props: {

            /**
             * Indicates this Layer's rendering priority for the attached {{#crossLink "Entity"}}Entities{{/crossLink}}.
             *
             * Each {{#crossLink "Entity"}}{{/crossLink}} is also attached to a {{#crossLink "Stage"}}Stage{{/crossLink}}, which sets a *stage* rendering
             * priority via its {{#crossLink "Stage/priority:property"}}priority{{/crossLink}} property.
             *
             * Fires a {{#crossLink "Layer/priority:event"}}{{/crossLink}} event on change.
             *
             * @property priority
             * @default 0
             * @type Number
             */
            priority: {

                set: function (value) {

                    // TODO: Only accept rendering priority in range [0...MAX_PRIORITY]

                    value = value || 0;

                    value = Math.round(value);


                    if (value === this._state.priority) {
                        return;
                    }

                    this._state.priority = value;

                    this._renderer.stateOrderDirty = true;

                    /**
                     * Fired whenever this Layer's  {{#crossLink "Layer/priority:property"}}{{/crossLink}} property changes.
                     *
                     * @event priority
                     * @param value The property's new value
                     */
                    this.fire("priority", this._state.priority);
                },

                get: function () {
                    return this._state.priority;
                }
            }
        },

        _compile: function () {
            this._renderer.layer = this._state;
        },

        _getJSON: function () {
            return {
                priority: this._state.priority
            };
        },

        _destroy: function () {
            this._state.destroy();
        }
    });

})();
;/**
 A **ColorTarget** is a  <a href="http://en.wikipedia.org/wiki/Render_Target" target="other">render target</a>  that
 captures the colors of the pixels rendered for the attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>
 <li>ColorTargets are typically used when *rendering-to-texture*.</li>
 <li>A ColorTarget provides the pixel colors as a dynamic color image that may be consumed by {{#crossLink "Texture"}}Textures{{/crossLink}}.</li>
 <li>ColorTarget is not to be confused with {{#crossLink "ColorBuf"}}ColorBuf{{/crossLink}}, which configures ***how*** the pixel colors are written with respect to the WebGL color buffer.</li>
 <li>Use {{#crossLink "Stage"}}Stages{{/crossLink}} when you need to ensure that a ColorTarget is rendered before
 the {{#crossLink "Texture"}}Textures{{/crossLink}} that consume it.</li>
 <li>For special effects, we often use ColorTargets and {{#crossLink "Texture"}}Textures{{/crossLink}} in combination
 with {{#crossLink "DepthTarget"}}DepthTargets{{/crossLink}} and {{#crossLink "Shader"}}Shaders{{/crossLink}}.</li>
 </ul>

 <img src="../../../assets/images/ColorTarget.png"></img>

 ## Example

 In this example we essentially have one {{#crossLink "Entity"}}{{/crossLink}}
 that's rendered to a {{#crossLink "Texture"}}{{/crossLink}}, which is then applied to a second {{#crossLink "Entity"}}{{/crossLink}}.

 The scene contains:

 <ul>
 <li>a ColorTarget,</li>
 <li>a {{#crossLink "Geometry"}}{{/crossLink}} that is the default box shape,
 <li>an {{#crossLink "Entity"}}{{/crossLink}} that renders the {{#crossLink "Geometry"}}{{/crossLink}} pixel color values to the ColorTarget,</li>
 <li>a {{#crossLink "Texture"}}{{/crossLink}} that sources its pixels from the ColorTarget,</li>
 <li>a {{#crossLink "Material"}}{{/crossLink}} that includes the {{#crossLink "Texture"}}{{/crossLink}}, and</li>
 <li>a second {{#crossLink "Entity"}}{{/crossLink}} that renders the {{#crossLink "Geometry"}}{{/crossLink}}, with the {{#crossLink "Material"}}{{/crossLink}} applied to it.</li>
 </ul>


 ````javascript
 var scene = new XEO.Scene();

 var colorTarget = new XEO.ColorTarget(scene);

 var geometry = new XEO.Geometry(scene); // Defaults to a 2x2x2 box

 // First Entity renders to the ColorTarget

 var entity1 = new XEO.Entity(scene, {
    geometry: geometry,
    colorTarget: colorTarget
});

 var texture = new XEO.Texture(scene, {
    target: colorTarget
});

 var material = new XEO.PhongMaterial(scene, {
    textures: [
        texture
    ]
});

 // Second Entity is textured with the
 // image of the first Entity

 var entity2 = new XEO.Entity(scene, {
    geometry: geometry,  // Reuse our simple box geometry
    material: material
});
 ````

 @class ColorTarget
 @module XEO
 @submodule rendering
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this ColorTarget within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} ColorTarget configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this ColorTarget.
 @param [cfg.active=true] {Boolean} Indicates if this ColorTarget is active or not.
 @param [cfg.size=null] {Array of Number} Optional fixed size for the ColorTarget's pixel buffer. When this is null, the buffer
 will dynamically resize to the canvas.
 @extends Component
 */
(function () {

    "use strict";

    XEO.ColorTarget = XEO.Component.extend({

        type: "XEO.ColorTarget",

        _init: function (cfg) {

            this._state = new XEO.renderer.RenderTarget({
                type: XEO.renderer.RenderTarget.COLOR,
                renderBuf: null
            });

            var canvas = this.scene.canvas;
            var self = this;

            this._webglContextRestored = canvas.on("webglContextRestored",
                function () {
                    if (self._state.renderBuf) {
                        self._state.renderBuf.webglRestored(canvas.gl);
                    }
                });

            this.size = cfg.size;
            this.active = cfg.active;
        },

        _props: {

            /**
             * The resolution of this ColorTarget's pixel buffer.
             *
             * Fires an {{#crossLink "ColorTarget/size:event"}}{{/crossLink}} event on change.
             *
             * @property size
             * @default null
             * @type {Array of Number}
             */
            size: {

                set: function (value) {

                    value = value || null;

                    this._size = value;

                    if (this._active) {
                        this._state.renderBuf.setSize(this._size);
                    }

                    /**
                     Fired whenever this ColorTarget's {{#crossLink "ColorTarget/size:property"}}{{/crossLink}} property changes.
                     @event size
                     @param value {Array of Number} The property's new value
                     */
                    this.fire("size", this._size);
                },

                get: function () {
                    return this._size;
                }
            },

            /**
             * Determines whether this ColorTarget is active or not.
             *
             * When active, the pixel colors of associated {{#crossLink "Entities"}}{{/crossLink}} will be rendered
             * to this ColorTarget. When inactive, the colors will be written to the default WebGL color buffer instead.
             *
             * Fires a {{#crossLink "ColorTarget/active:event"}}{{/crossLink}} event on change.
             *
             * @property active
             * @default true
             * @type Number
             */
            active: {

                set: function (value) {

                    value = value !== false;

                    if (this._active === value) {
                        return;
                    }

                    var state = this._state;
                    this._active = value;

                    if (this._active) {

                        var canvas = this.scene.canvas;

                        state.renderBuf = new XEO.renderer.webgl.RenderBuffer({
                            canvas: canvas.canvas,
                            gl: canvas.gl,
                            size: this._size
                        });

                        this._renderer.imageDirty = true;

                    } else {

                        if (state.renderBuf) {
                            state.renderBuf.destroy();
                            state.renderBuf = null;
                        }
                    }

                    /**
                     Fired whenever this ColorTarget's {{#crossLink "ColorTarget/active:property"}}{{/crossLink}} property changes.

                     @event active
                     @param value {Boolean} The property's new value
                     */
                    this.fire("active", this._active);
                },

                get: function () {
                    return this._active;
                }
            }
        },

        _compile: function () {
            this._renderer.colorTarget = this._state;
        },

        _getJSON: function () {

            var json = {
                active: this._active
            };

            if (this._size) {
                json.size = this._size
            }

            return json;
        },

        _destroy: function () {

            this.scene.canvas.off(this._webglContextRestored);

            this._state.renderBuf.destroy();

            this._state.destroy();
        }
    });

})();
;/**
 A **DepthTarget** is a  <a href="http://en.wikipedia.org/wiki/Render_Target" target="other">render target</a>  that
 captures the depths of the pixels rendered for the attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>
 <li>DepthTargets are typically used when *rendering-to-texture*.</li>
 <li>A DepthTarget provides the pixel depths as a dynamic color-encoded image that may be fed into {{#crossLink "Texture"}}Textures{{/crossLink}}.</li>
 <li>DepthTarget is not to be confused with {{#crossLink "DepthBuf"}}DepthBuf{{/crossLink}}, which configures ***how*** the pixel depths are written with respect to the WebGL depth buffer.</li>
 <li>Use {{#crossLink "Stage"}}Stages{{/crossLink}} when you need to ensure that a DepthTarget is rendered before
 the {{#crossLink "Texture"}}Textures{{/crossLink}} that consume it.</li>
 <li>For special effects, we often use DepthTargets and {{#crossLink "Texture"}}Textures{{/crossLink}} in combination
 with {{#crossLink "DepthTarget"}}DepthTargets{{/crossLink}} and {{#crossLink "Shader"}}Shaders{{/crossLink}}.</li>
 </ul>

 <img src="../../../assets/images/DepthTarget.png"></img>

 ## Example

 In the example below, we essentially have one {{#crossLink "Entity"}}{{/crossLink}}
 that renders its pixel Z-depth values to a {{#crossLink "Texture"}}{{/crossLink}}, which is then applied
 to a second {{#crossLink "Entity"}}{{/crossLink}}.

 The scene contains:

 <ul>
 <li>a DepthTarget,</li>
 <li>a {{#crossLink "Geometry"}}{{/crossLink}} that is the default box shape,
 <li>an {{#crossLink "Entity"}}{{/crossLink}} that renders the {{#crossLink "Geometry"}}{{/crossLink}} fragment depth values to the DepthTarget,</li>
 <li>a {{#crossLink "Texture"}}{{/crossLink}} that sources its pixels from the DepthTarget,</li>
 <li>a {{#crossLink "PhongMaterial"}}{{/crossLink}} that includes the {{#crossLink "Texture"}}{{/crossLink}}, and</li>
 <li>a second {{#crossLink "Entity"}}{{/crossLink}} that renders the {{#crossLink "Geometry"}}{{/crossLink}}, with the {{#crossLink "Material"}}{{/crossLink}} applied to it.</li>
 </ul>

 The pixel colours in the DepthTarget will be depths encoded into RGBA, so will look a little weird when applied directly to the second
 {{#crossLink "Entity"}}{{/crossLink}} as a {{#crossLink "Texture"}}{{/crossLink}}. In practice the {{#crossLink "Texture"}}{{/crossLink}}
 would carry the depth values into a custom {{#crossLink "Shader"}}{{/crossLink}}, which would then be applied to the second {{#crossLink "Entity"}}{{/crossLink}}.

 ````javascript
 var scene = new XEO.Scene();

 var geometry = new XEO.Geometry(scene); // Defaults to a 2x2x2 box.

 var depthTarget = new XEO.DepthTarget(scene);

 // First Entity renders its pixel depth values to our DepthTarget
 var entity1 = new XEO.Entity(scene, {
    depthTarget: depthTarget
});

 // Texture consumes our DepthTarget
 var texture = new XEO.Texture(scene, {
    target: depthTarget
});

 // Material contains our Texture
 var material = new XEO.PhongMaterial(scene, {
    textures: [
        texture
    ]
});

 // Second Entity is effectively textured with the color-encoded
 // pixel depths of the first Entity
 var entity2 = new XEO.Entity(scene, {
    geometry: geometry,  // Reuse our simple box geometry
    material: material
});
 ````
 @class DepthTarget
 @module XEO
 @submodule rendering
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this DepthTarget within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} DepthTarget configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this DepthTarget.
 @param [cfg.active=true] {Boolean} Indicates if this DepthTarget is active or not.

 @extends Component
 */
(function () {

    "use strict";

    XEO.DepthTarget = XEO.Component.extend({

        type: "XEO.DepthTarget",

        _init: function (cfg) {

            this._state = new XEO.renderer.RenderTarget({
                type: XEO.renderer.RenderTarget.DEPTH,
                renderBuf: null
            });

            var canvas = this.scene.canvas;
            var self = this;

            this._webglContextRestored = canvas.on("webglContextRestored",
                function () {
                    if (self._state.renderBuf) {
                        self._state.renderBuf.webglRestored(canvas.gl);
                    }
                });

            this.active = cfg.active;
        },

        _props: {

            /**
             * Indicates whether this DepthTarget is active or not.
             *
             * When active, the pixel depths of associated {{#crossLink "Entities"}}{{/crossLink}} will be rendered
             * to this DepthTarget. When inactive, the colors will be written to the default WebGL depth buffer instead.
             *
             * Fires a {{#crossLink "DepthTarget/active:event"}}{{/crossLink}} event on change.
             *
             * @property active
             * @default true
             * @type Number
             */
            active: {

                set: function (value) {

                    value = value !== false;

                    if (this._active === value) {
                        return;
                    }

                    this._active = value;
                    var state = this._state;

                    if (this._active) {

                        var canvas = this.scene.canvas;

                        state.renderBuf = new XEO.renderer.webgl.RenderBuffer({
                            canvas: canvas.canvas,
                            gl: canvas.gl
                        });

                        this._renderer.imageDirty = true;


                    } else {
                        if (state.renderBuf) {
                            state.renderBuf.destroy();
                            state.renderBuf = null;
                        }
                    }

                    /**
                     Fired whenever this DepthTarget's {{#crossLink "DepthTarget/active:property"}}{{/crossLink}} property changes.

                     @event active
                     @param value {Boolean} The property's new value
                     */
                    this.fire("active", this._active);
                },

                get: function () {
                    return this._active;
                }
            }
        },

        _compile: function () {
            this._renderer.depthTarget = this._state;
        },

        _getJSON: function () {
            return {
                active: this._active
            };
        },

        _destroy: function () {

            this.scene.canvas.off(this._webglContextRestored);

            this._state.renderBuf.destroy();

            this._state.destroy();
        }
    });

})();
;/**
 A **Modes** toggles various xeoEngine modes and capabilities for attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>

 <li>Though the rendering modes are defined by various different components attached to the {{#crossLink "Entity"}}Entities{{/crossLink}},
 Modes components provide a single point through which you can toggle them on or off.</li>

 <li>A Modes may be shared among multiple {{#crossLink "Entity"}}Entities{{/crossLink}} to toggle
 rendering modes for them as a group.</li>

 <li>See <a href="Shader.html#inputs">Shader Inputs</a> for the variables that Modes create within xeoEngine's shaders.</li>

 </ul>

 <img src="../../../assets/images/Modes.png"></img>

 ## Example

 In this example we have a Modes that toggles rendering modes for
 two {{#crossLink "Entity"}}Entities{{/crossLink}}. The properties of the Modes are initialised to their
 default values.

 ````javascript
 var scene = new XEO.Scene();

 // Create a Modes with default properties
 var modes = new XEO.Modes(scene, {
    pickable: true,             // Enable picking
    clipping true,              // Enable effect of XEO.Clip components
    transparent : false,        // Disable transparency
    backfaces : true,           // Render backfaces
    frontface : "ccw"
 });

 // Create two Entities whose rendering modes will be controlled by our Modes

 var entity1 = new XEO.Entity(scene, {
       modes: modes
 });

 var entity2 = new XEO.Entity(scene, {
       modes: modes
 });

 // Subscribe to change on the Modes' "backfaces" property
 var handle = modes.on("backfaces", function(value) {
       //...
 });

 // Hide backfaces on our Entities by flipping the Modes' "backfaces" property,
 // which will also call our handler
 modes.backfaces = false;

 // Unsubscribe from the Modes again
 modes.off(handle);

 // When we destroy our Modes, the Entities will fall back
 // on the Scene's default Modes instance
 modes.destroy();

 ````

 @class Modes
 @module XEO
 @submodule rendering
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Modes in the default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Modes.
 @param [cfg.pickable=true] {Boolean}  Whether to enable picking.
 @param [cfg.clipping=true] {Boolean} Whether to enable clipping by {{#crossLink "Clips"}}{{/crossLink}}.
 @param [cfg.transparent=false] {Boolean} Whether to enable the transparency effect created by {{#crossLink "Material"}}Material{{/crossLink}}s when they have
 {{#crossLink "PhongMaterial/opacity:property"}}{{/crossLink}} < 1.0. This mode will set attached {{#crossLink "Entity"}}Entities{{/crossLink}} transparent (ie. to be rendered in a
 transparency pass with blending enabled etc), while
 the {{#crossLink "PhongMaterial/opacity:property"}}{{/crossLink}} will indicate the **degree** of their transparency
 (ie. where opacity of 0.0 indicates maximum translucency and opacity of 1.0 indicates minimum translucency).
 @param [cfg.backfaces=false] {Boolean} Whether to render {{#crossLink "Geometry"}}Geometry{{/crossLink}} backfaces.
 @param [cfg.frontface="ccw"] {Boolean} The winding order for {{#crossLink "Geometry"}}Geometry{{/crossLink}} front faces - "cw" for clockwise, or "ccw" for counter-clockwise.
 @param [cfg.collidable=true] {Boolean} Whether attached {{#crossLink "Entity"}}Entities{{/crossLink}} are included in boundary-related calculations. Set this false if the
 {{#crossLink "Entity"}}Entities{{/crossLink}} are things like helpers or indicators that should not be included in boundary calculations.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Modes = XEO.Component.extend({

        type: "XEO.Modes",

        _init: function (cfg) {

            this._state = new XEO.renderer.Modes({
                pickable: true,
                clipping: true,
                transparent: false,
                backfaces: false,
                frontface: true, // Boolean for speed; true == "ccw", false == "cw"
                collidable: true
            });

            this.pickable = cfg.pickable;
            this.clipping = cfg.clipping;
            this.transparent = cfg.transparent;
            this.backfaces = cfg.backfaces;
            this.frontface = cfg.frontface;
            this.collidable = cfg.collidable;
        },

        _props: {

            /**
             Whether this Modes enables picking of attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

             Picking is performed via calls to {{#crossLink "Canvas/pick:method"}}Canvas#pick{{/crossLink}}.

             Fires a {{#crossLink "Modes/pickable:event"}}{{/crossLink}} event on change.

             @property pickable
             @default true
             @type Boolean
             */
            pickable: {

                set: function (value) {

                    this._state.pickable = value !== false;

                    this._renderer.drawListDirty = true;

                    /**
                     * Fired whenever this Modes' {{#crossLink "Modes/pickable:property"}}{{/crossLink}} property changes.
                     *
                     * @event pickable
                     * @param value The property's new value
                     */
                    this.fire("pickable", this._state.pickable);
                },

                get: function () {
                    return this._state.pickable;
                }
            },

            /**
             Whether this Modes enables clipping of attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

             Clipping is done by {{#crossLink "Clips"}}{{/crossLink}} that are also attached to
             the {{#crossLink "Entity"}}Entities{{/crossLink}}.

             Fires a {{#crossLink "Modes/clipping:event"}}{{/crossLink}} event on change.

             @property clipping
             @default true
             @type Boolean
             */
            clipping: {

                set: function (value) {

                    this._state.clipping = value !== false;

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this Modes' {{#crossLink "Modes/clipping:property"}}{{/crossLink}} property changes.

                     @event clipping
                     @param value The property's new value
                     */
                    this.fire("clipping", this._state.clipping);
                },

                get: function () {
                    return this._state.clipping;
                }
            },

            /**
             Whether this Modes sets attached {{#crossLink "Entity"}}Entities{{/crossLink}} transparent.

             When true. this property will set attached {{#crossLink "Entity"}}Entities{{/crossLink}} transparent (ie. to be rendered in a
             transparency pass with blending enabled etc), while
             the {{#crossLink "PhongMaterial/opacity:property"}}{{/crossLink}} will be used to indicate the **degree** of their transparency
             (ie. where opacity of 0.0 indicates maximum translucency and opacity of 1.0 indicates minimum translucency).

             Fires a {{#crossLink "Modes/transparent:event"}}{{/crossLink}} event on change.

             @property transparent
             @default false
             @type Boolean
             */
            transparent: {

                set: function (value) {

                    this._state.transparent = !!value;

                    this._renderer.stateOrderDirty = true;

                    /**
                     Fired whenever this Modes' {{#crossLink "Modes/transparent:property"}}{{/crossLink}} property changes.

                     @event transparent
                     @param value The property's new value
                     */
                    this.fire("transparent", this._state.transparent);
                },

                get: function () {
                    return this._state.transparent;
                }
            },

            /**
             Whether this Modes enables backfaces to be visible on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

             The backfaces will belong to {{#crossLink "Geometry"}}{{/crossLink}} compoents that are also attached to
             the {{#crossLink "Entity"}}Entities{{/crossLink}}.

             Fires a {{#crossLink "Modes/backfaces:event"}}{{/crossLink}} event on change.

             @property backfaces
             @default false
             @type Boolean
             */
            backfaces: {

                set: function (value) {

                    value = !!value;

                    this._state.backfaces = value;

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this Modes' {{#crossLink "Modes/backfaces:property"}}{{/crossLink}} property changes.

                     @event backfaces
                     @param value The property's new value
                     */
                    this.fire("backfaces", this._state.backfaces);
                },

                get: function () {
                    return this._state.backfaces;
                }
            },

            /**
             Indicates the winding direction of front faces on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

             The faces will belong to {{#crossLink "Geometry"}}{{/crossLink}} components that are also attached to
             the {{#crossLink "Entity"}}Entities{{/crossLink}}.

             Fires a {{#crossLink "Modes/frontface:event"}}{{/crossLink}} event on change.

             @property frontface
             @default "ccw"
             @type String
             */
            frontface: {

                set: function (value) {

                    this._state.frontface = value !== "cw";

                    this._renderer.imageDirty = true;

                    /**
                     Fired whenever this Modes' {{#crossLink "Modes/frontface:property"}}{{/crossLink}} property changes.

                     @event frontface
                     @param value The property's new value
                     */
                    this.fire("frontface", this._state.frontface ? "ccw" : "cw");
                },

                get: function () {
                    return this._state.frontface ? "ccw" : "cw";
                }
            },

            /**
             Whether attached {{#crossLink "Entity"}}Entities{{/crossLink}} are included
             in boundary-related calculations.

             Set this false if the
             {{#crossLink "Entity"}}Entities{{/crossLink}} are things like helpers or indicators that should not be included in boundary calculations.

             For example, when set false, the {{#crossLink "Entity/worldBoundary:property"}}World-space boundary{{/crossLink}} of all attached {{#crossLink "Entity"}}Entities{{/crossLink}} would not be considered when calculating the {{#crossLink "Scene/worldBoundary:property"}}World-space boundary{{/crossLink}} of their
             {{#crossLink "Scene"}}{{/crossLink}}.

             Fires a {{#crossLink "Modes/collidable:event"}}{{/crossLink}} event on change.

             @property collidable
             @default true
             @type Boolean
             */
            collidable: {

                set: function (value) {

                    value = value !== false;

                    if (value === this._state.collidable) {
                        return;
                    }

                    this._state.collidable = value;

                    /**
                     Fired whenever this Modes' {{#crossLink "Modes/collidable:property"}}{{/crossLink}} property changes.

                     @event collidable
                     @param value The property's new value
                     */
                    this.fire("collidable", this._state.collidable);
                },

                get: function () {
                    return this._state.collidable;
                }
            }
        },

        _compile: function () {
            this._renderer.modes = this._state;
        },

        _getJSON: function () {
            return {
                pickable: this._state.pickable,
                clipping: this._state.clipping,
                transparent: this._state.transparent,
                backfaces: this._state.backfaces,
                frontface: this._state.frontface,
                collidable: this._state.collidable
            };
        },

        _destroy: function () {
            this._state.destroy();
        }
    });

})();
;/**
 A **Stage** is a bin of {{#crossLink "Entity"}}Entities{{/crossLink}} that is rendered in a specified priority with respect to
 other Stages in the same {{#crossLink "Scene"}}{{/crossLink}}.

 ## Overview

 <ul>
 <li>When the parent {{#crossLink "Scene"}}Scene{{/crossLink}} renders, each Stage renders its bin
 of {{#crossLink "Entity"}}Entities{{/crossLink}} in turn, from the lowest priority Stage to the highest.</li>

 <li>Stages are typically used for ordering the render-to-texture steps in posteffects pipelines.</li>

 <li>You can control the render order of the individual {{#crossLink "Entity"}}Entities{{/crossLink}} ***within*** a Stage
 by associating them with {{#crossLink "Layer"}}Layers{{/crossLink}}.</li>

 <li>{{#crossLink "Layer"}}Layers{{/crossLink}} are typically used to <a href="https://www.opengl.org/wiki/Transparency_Sorting" target="_other">transparency-sort</a> the
 {{#crossLink "Entity"}}Entities{{/crossLink}} within Stages.</li>

 <li>{{#crossLink "Entity"}}Entities{{/crossLink}} not explicitly attached to a Stage are implicitly
 attached to the {{#crossLink "Scene"}}Scene{{/crossLink}}'s default
 {{#crossLink "Scene/stage:property"}}stage{{/crossLink}}. which has
 a {{#crossLink "Stage/priority:property"}}{{/crossLink}} value of zero.</li>

 </ul>

 <img src="../../../assets/images/Stage.png"></img>

 ## Example

 In this example we're performing render-to-texture using {{#crossLink "ColorTarget"}}ColorTarget{{/crossLink}} and
 {{#crossLink "Texture"}}Texture{{/crossLink}} components.

 Note how we use two prioritized Stages, to ensure that the {{#crossLink "ColorTarget"}}ColorTarget{{/crossLink}} is
 rendered ***before*** the {{#crossLink "Texture"}}Texture{{/crossLink}} that consumes it.

 ````javascript
 var scene = new XEO.Scene();

 // First stage: an Entity that renders to a ColorTarget

 var stage1 = new XEO.Stage(scene, {
       priority: 0
  });

 var geometry = new XEO.Geometry(scene); // Geometry with no parameters defaults to a 2x2x2 box

 var colorTarget = new XEO.ColorTarget(scene);

 var entity1 = new XEO.Entity(scene, {
       stage: stage1,
       geometry: geometry,
       colorTarget: colorTarget
  });


 // Second stage: an Entity with a Texture that sources from the ColorTarget

 var stage2 = new XEO.Stage(scene, {
       priority: 1
  });

 var texture = new XEO.Texture(scene, {
       target: colorTarget
  });

 var material = new XEO.PhongMaterial(scene, {
       textures: [
           texture
       ]
  });

 var geometry2 = new XEO.Geometry(scene);

 var entity2 = new XEO.Entity(scene, {
       stage: stage2,
       material: material,
       geometry: geometry2
  });
 ````

 @class Stage
 @module XEO
 @submodule rendering
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Stage in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Stage.
 @param [cfg.priority=0] {Number} The rendering priority for the attached {{#crossLink "Entity"}}Entities{{/crossLink}}.
 @param [cfg.pickable=true] {Boolean} Indicates whether attached {{#crossLink "Entity"}}Entities{{/crossLink}} are pickable.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Stage = XEO.Component.extend({

        type: "XEO.Stage",

        _init: function (cfg) {

            this._state = new XEO.renderer.Stage({
                priority: null,
                pickable: true
            });

            this.priority = cfg.priority;
            this.pickable = cfg.pickable;
        },

        _props: {

            priority: {

                /**
                 * Indicates the rendering priority for the
                 * {{#crossLink "Entity"}}Entities{{/crossLink}} in
                 * this Stage.
                 *
                 * Fires a {{#crossLink "Stage/priority:event"}}{{/crossLink}}
                 * event on change.
                 *
                 * @property priority
                 * @default 0
                 * @type Number
                 */
                set: function (value) {

                    value = value || 0;

                    if (value === this._state.priority) {
                        return;
                    }

                    value = Math.round(value);

                    this._state.priority = value;

                    this._renderer.stateOrderDirty = true;

                    /**
                     * Fired whenever this Stage's
                     * {{#crossLink "Stage/priority:property"}}{{/crossLink}}
                     * property changes.
                     *
                     * @event priority
                     * @param value The property's new value
                     */
                    this.fire("priority", this._state.priority);
                },

                get: function () {
                    return this._state.priority;
                }
            },

            /**
             * Indicates whether the attached
             * {{#crossLink "Entity"}}Entities{{/crossLink}} are
             * pickable (see {{#crossLink "Canvas/pick:method"}}Canvas#pick{{/crossLink}}).
             *
             * Fires a {{#crossLink "Stage/pickable:event"}}{{/crossLink}} event on change.
             *
             * @property pickable
             * @default true
             * @type Boolean
             */
            pickable: {

                set: function (value) {

                    this._state.pickable = value !== false;

                    this._renderer.drawListDirty = true;

                    /**
                     * Fired whenever this Stage's
                     * {{#crossLink "Stage/pickable:pickable"}}{{/crossLink}}
                     * property changes.
                     *
                     * @event pickable
                     * @param value The property's new value
                     */
                    this.fire("pickable", this._state.pickable);
                },

                get: function () {
                    return this._state.pickable;
                }
            }
        },

        _compile: function () {
            this._renderer.stage = this._state;
        },

        _getJSON: function () {
            return {
                priority: this.priority,
                pickable: this.pickable
            };
        },

        _destroy: function () {
            this._state.destroy();
        }
    });

})();
;/**
 * Components for reporting Scene statistics.
 *
 * @module XEO
 * @submodule reporting
 */;/**
 A **Task** represents an asynchronously-running process within a {{#crossLink "Tasks"}}Tasks{{/crossLink}}.

 ## Overview

 See the {{#crossLink "Tasks"}}{{/crossLink}} documentation for more information.</li>

 <img src="../../../assets/images/Task.png"></img>

 @class Task
 @module XEO
 @submodule reporting
 @extends Component
 */
(function () {

    "use strict";

    XEO.Task = XEO.Component.extend({

        type: "XEO.Task",

        serializable: false,

        _init: function (cfg) {

            this.description = cfg.description || "";

            this.failed = false;

            this.completed = false;
        },

        /**
         * Sets this Task as successfully completed.
         *
         * Fires a  {{#crossLink "Task/completed:event"}}{{/crossLink}} event on this task, as well as
         * a {{#crossLink "Tasks/completed:event"}}{{/crossLink}} event on the parent  {{#crossLink "Tasks"}}Task{{/crossLink}}.
         *
         * @method setCompleted
         */
        setCompleted: function () {

            /**
             * Fired when this Task has successfully completed.
             *
             * @event completed
             */
            this.fire("completed", this.completed = true);
        },

        /**
         * Sets this Task as having failed.
         *
         * Fires a  {{#crossLink "Task/failed:event"}}{{/crossLink}} event on this task, as well as
         * a {{#crossLink "Tasks/failed:event"}}{{/crossLink}} event on the parent  {{#crossLink "Tasks"}}Tasks{{/crossLink}}.
         *
         * @method setFailed
         */
        setFailed: function () {

            /**
             * Fired when this Task has failed to complete successfully.
             *
             * @event failed
             */
            this.fire("failed", this.failed = true);
        },

        _destroy: function () {
            if (!this.completed && this.destroyed) {
                this.setCompleted();
            }
        }
    });

})();
;/**
 A **Tasks** tracks general asynchronous tasks running within a {{#crossLink "Scene"}}Scene{{/crossLink}}.

 ## Overview

 <ul>
 <li>Each {{#crossLink "Scene"}}Scene{{/crossLink}} has a Tasks component, available via the
 {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Scene/tasks:property"}}tasks{{/crossLink}} property,
 within which it will create and destroy {{#crossLink "Task"}}Task{{/crossLink}} components to indicate what processes
 it's running internally.</li>

 <li>You can also manage your own {{#crossLink "Task"}}Task{{/crossLink}} components within that, to indicate what
 application-level processes you are running.</li>
 </ul>

 <img src="../../../assets/images/Tasks.png"></img>

 ## Example

 This example shows how to manage tasks and subscribe to their life cycles.

 ````Javascript
 // Create a Scene
 var scene = new XEO.Scene();

 // Get the Tasks tracker
 var tasks = scene.tasks;

 // Subscribe to all task creations
 tasks.on("started", function(task) {
     console.log("Task started: " + task.id +", " + task.description);
});

 // Subscribe to all task completions
 tasks.on("completed", function(task) {
      console.log("Task completed: " + task.id +", " + task.description);
});

 // Subscribe to all task failures
 tasks.on("failed", function(task) {
     console.log("Task failed: " + task.id +", " + task.description);
});

 // Create and start Task "foo"
 var taskFoo = tasks.create({
     id: "foo", // Optional, unique ID generated automatically when omitted
     description: "Loading something"
});

 // Create and start Task "bar"
 var taskBar = tasks.create({
     id: "bar",
     description: "Loading something else"
});

 // Subscribe to completion of Task "foo"
 taskFoo.on("completed", function(task) {
     console.log("Task completed: " + task.id +", " + task.description);
});

 // Subscribe to failure of a specific task
 taskFoo.on("failed", function(task) {
     console.log("Task failed: " + task.id +", " + task.description);
});

 // Set Task "foo" as completed, via the Tasks
 // Fires the "completed" handler we registered above, also fires "completed" on the Task itself
 tasks.setCompleted("foo");

 // Set Task "bar" as failed, this time directly on the Task in question
 myTask2.setFailed();

 ````
 @class Tasks
 @module XEO
 @submodule reporting
 @constructor
 @extends Component
 */
(function () {

    "use strict";

    XEO.Tasks = XEO.Component.extend({

        type: "XEO.Tasks",

        serializable: false,

        _init: function (cfg) {

            this._idMap = new XEO.utils.Map();

            this.tasks = {};
        },

        /**
         * Creates and starts a new {{#crossLink "Task"}}Task{{/crossLink}} instance with this Tasks.
         *
         * If an ID is given for the new {{#crossLink "Task"}}Task{{/crossLink}} that is already in use for
         * another, will log an error message and return null.
         *
         * On success, fires a {{#crossLink "Tasks/started:event"}}{{/crossLink}} event and returns the new {{#crossLink "Task"}}Task{{/crossLink}}
         *  instance.
         *
         * @method create
         * @param params Task params.
         * @param [params.id] {String} Optional unique ID,
         * internally generated if not supplied.
         * @param [params.description] {String} Optional description.
         * @returns {Task|null} The new new {{#crossLink "Task"}}Task{{/crossLink}} instance, or null if there was an ID
         * clash with an existing {{#crossLink "Task"}}Task{{/crossLink}}.
         */
        create: function (params) {

            params = params || {};

            if (params.id) {
                if (this.tasks[params.id]) {
                    this.error("Task " + XEO._inQuotes(params.id) + "already exists");
                    return null;
                }
            } else {
                params.id = this._idMap.addItem({});
            }

            var task = new XEO.Task(this, params);

            this.tasks[params.id] = task;

            var self = this;

            /**
             * Fired whenever a Task within this Tasks has successfully completed.
             *
             * @event completed
             * @param {Task} value The task that has completed
             */
            task.on("completed",
                function () {
                    delete self.tasks[task.id];
                    self._idMap.removeItem(task.id);
                    self.fire("completed", task, true);
                });

            /**
             * Fired whenever a Task within this Tasks has failed.
             *
             * @event failed
             * @param {Task} value The task that has failed
             */
            task.on("failed",
                function () {
                    delete self.tasks[task.id];
                    self._idMap.removeItem(task.id);
                    self.fire("failed", task, true);
                });

            self.fire("started", task, true);

            return task;
        },

        /**
         * Completes the {{#crossLink "Task"}}Task{{/crossLink}} with the given ID.
         *
         * Fires a {{#crossLink "Tasks/completed:event"}}{{/crossLink}} event, as well as separate
         * {{#crossLink "Task/completed:event"}}{{/crossLink}} event on the {{#crossLink "Task"}}Task{{/crossLink}} itself.
         *
         * Logs an error message if no task can be found for the given ID.
         *
         * @method setCompleted
         * @param {String} id ID of the {{#crossLink "Task"}}Task{{/crossLink}} to complete.
         */
        setCompleted: function (id) {

            var task = this.tasks[id];

            if (!task) {
                this.error("Task not found:" + XEO._inQuotes(id));
                return;
            }

            task.fire("completed", task, true);
        },

        /**
         * Fails the {{#crossLink "Task"}}Task{{/crossLink}} with the given ID.
         *
         * Fires a {{#crossLink "Tasks/failed:event"}}{{/crossLink}} event, as well as separate
         * {{#crossLink "Task/failed:event"}}{{/crossLink}} event on the {{#crossLink "Task"}}Task{{/crossLink}} itself.
         *
         * Logs an error message if no task can be found for the given ID.
         *
         * @method setFailed
         * @param {String} id ID of the {{#crossLink "Task"}}Task{{/crossLink}} to fail.
         */
        setFailed: function (id) {

            var task = this.tasks[id];

            if (!task) {
                this.error("Task not found:" + XEO._inQuotes(id));
                return;
            }

            task.fire("failed", task, true);
        },

        clear: function () {
            for (var id in this.tasks) {
                if (this.tasks.hasOwnProperty(id)) {
                    this.tasks[id].setCompleted();
                }
            }
        }
    });


})();
;/**
 * Components for defining custom GLSL shaders.
 *
 * @module XEO
 * @submodule shaders
 */;/**
 A **Shader** specifies a custom GLSL shader to apply when rendering attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>
 <li>Normally you would rely on xeoEngine to automatically generate shaders for you, however the Shader component allows you to author them manually.</li>
 <li>You can use xeoEngine's reserved uniform and variable names in your Shaders to read all the WebGL state that's set by other
 components on the attached {{#crossLink "Entity"}}Entities{{/crossLink}}.</li>
 <li>Use Shaders in combination with {{#crossLink "ShaderParams"}}ShaderParams{{/crossLink}} components when you need to share
 the same Shaders among multiple {{#crossLink "Entity"}}Entities{{/crossLink}} while setting the Shaders' uniforms
 differently for each {{#crossLink "Entity"}}Entity{{/crossLink}}.</li>
 <li>Use {{#crossLink "ColorTarget"}}ColorTarget{{/crossLink}}, {{#crossLink "DepthTarget"}}DepthTarget{{/crossLink}}
 and {{#crossLink "Texture"}}Texture{{/crossLink}} components to connect the output of one Shader as input into another Shader.</li>
 </ul>

 <img src="../../../assets/images/Shader.png"></img>

 ## Example

 This example shows the simplest way to use a Shader, where we're just going to render a ripply water
 pattern to a screen-aligned quad.

 <img src="../../assets/images/shaderExample1.png"></img>

 In our scene definition, we have an  {{#crossLink "Entity"}}Entity{{/crossLink}} that has a {{#crossLink "Geometry"}}Geometry{{/crossLink}} that is our
 screen-aligned quad, plus a Shader that will render the fragments of that quad with our cool rippling water pattern.
 Finally, we animate the rippling by periodically updating the Shader's "time" uniform.

 ````javascript

 var scene = new XEO.Scene();

 // Shader that's used by our Object. Note the 'xeo_aPosition' and 'xeo_aUV attributes',
 // which will receive the positions and UVs from the Geometry. Also note the 'time'
 // uniform, which we'll be animating via Shader#setParams.

 var shader = new XEO.Shader(scene, {

       // Vertex shading stage
       vertex: [
           "attribute vec3 xeo_aPosition;",
           "attribute vec2 xeo_aUV;",
           "varying vec2 vUv;",
           "void main () {",
           "    gl_Position = vec4(xeo_aPosition, 1.0);",
           "    vUv = xeo_aUV;",
           "}"
       ],

       // Fragment shading stage
       fragment: [
           "precision mediump float;",

           "uniform float time;",
           "varying vec2 vUv;",

           "void main( void ) {",
           "    vec2 sp = vUv;",
           "    vec2 p = sp*5.0 - vec2(10.0);",
           "    vec2 i = p;",
           "    float c = 1.0;",
           "    float inten = 0.10;",
           "    for (int n = 0; n < 10; n++) {",
           "        float t = time * (1.0 - (3.0 / float(n+1)));",
           "        i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));",
           "        c += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));",
           "    }",
           "    c /= float(10);",
           "    c = 1.5-sqrt(c);",
           "    gl_FragColor = vec4(vec3(c*c*c*c), 999.0) + vec4(0.0, 0.3, 0.5, 1.0);",
           "}"
       ],

       // Initial value for the 'time' uniform in the fragment stage.
       params: {
           time: 0.0
       }
  });

 // A screen-aligned quad
 var quad = new XEO.Geometry(scene, {
       primitive:"triangles",
       positions:[ 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0 ],
       normals:[ -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0 ],
       uv:[ 1, 1, 0, 1, 0, 0, 1, 0 ],
       indices:[ 0, 1, 2, 0, 2, 3 ]
  });

 var object = new XEO.Entity(scene, {
       shader: shader,
       geometry: quad
  });

 ````
 Now let's animate the "time" parameter on the Shader, to make the water ripple:

 ```` javascript
 scene.on("tick", function(params) {
            shader.setParams({
                time: params.timeElapsed
            });
        });
 ````

 ## <a name="inputs">Shader Inputs</a>

 xeoEngine provides the following inputs for your shaders.

 #### Attributes

 *Attributes are used only in vertex shaders*

 | Attribute  | Description | Depends on  |
 |---|---|
 | attribute vec3 xeo_aPosition   | Geometry vertex positions | {{#crossLink "Geometry"}}Geometry{{/crossLink}} {{#crossLink "Geometry/positions:property"}}{{/crossLink}} |
 | attribute vec2 xeo_aUV         | Geometry vertex UV coordinates | {{#crossLink "Geometry"}}Geometry{{/crossLink}} {{#crossLink "Geometry/uv:property"}}{{/crossLink}}  |
 | attribute vec3 xeo_aNormal     | Geometry vertex normals | {{#crossLink "Geometry"}}Geometry{{/crossLink}} {{#crossLink "Geometry/normals:property"}}{{/crossLink}}  |
 | attribute vec4 xeo_aColor      | Geometry vertex colors  | {{#crossLink "Geometry"}}Geometry{{/crossLink}} {{#crossLink "Geometry/colors:property"}}{{/crossLink}}  |
 | attribute vec4 xeo_aTangent    | Geometry vertex tangents, for normal mapping | {{#crossLink "Geometry"}}Geometry{{/crossLink}} {{#crossLink "Geometry/normals:property"}}{{/crossLink}} and {{#crossLink "Geometry/uv:property"}}{{/crossLink}}  |

 #### Uniforms

 *Uniforms are used in vertex and fragment shaders*

 | Uniform  | Description | Depends on  |
 |---|---|
 | uniform mat4  xeo_uModelMatrix                                   | Modelling transform matrix | {{#crossLink "Transform"}}{{/crossLink}} |
 | uniform mat4  xeo_uModelNormalMatrix                             | Modelling transform normal matrix | {{#crossLink "Geometry/normals:property"}}Geometry normals{{/crossLink}} and {{#crossLink "Transform"}}{{/crossLink}} |
 | uniform mat4  xeo_uViewMatrix                                    | View transform matrix | {{#crossLink "Lookat"}}Lookat{{/crossLink}} |
 | uniform mat4  xeo_uViewNormalMatrix                              | View transform normal matrix | {{#crossLink "Geometry/normals:property"}}Geometry normals{{/crossLink}} and {{#crossLink "Lookat"}}Lookat{{/crossLink}} |
 | uniform mat4  xeo_uProjMatrix                                    | Projection transform matrix | {{#crossLink "Ortho"}}Ortho{{/crossLink}}, {{#crossLink "Frustum"}}Frustum{{/crossLink}} or {{#crossLink "Perspective"}}Perspective{{/crossLink}} |
 | uniform float xeo_uZNear                                         | Near clipping plane |{{#crossLink "Ortho"}}Ortho{{/crossLink}}, {{#crossLink "Frustum"}}Frustum{{/crossLink}} or {{#crossLink "Perspective"}}Perspective{{/crossLink}} |
 | uniform float xeo_uZFar                                          | Far clipping plane |{{#crossLink "Ortho"}}Ortho{{/crossLink}}, {{#crossLink "Frustum"}}Frustum{{/crossLink}} or {{#crossLink "Perspective"}}Perspective{{/crossLink}} |
 |---|---|
 | uniform vec3  xeo_uLightAmbientColor                             | Color of the first {{#crossLink "AmbientLight"}}{{/crossLink}} in {{#crossLink "Lights"}}{{/crossLink}}| {{#crossLink "AmbientLight"}}{{/crossLink}} |
 | uniform vec3 xeo_uLightColor&lt;***N***&gt;                    | Diffuse color of {{#crossLink "DirLight"}}{{/crossLink}} or {{#crossLink "PointLight"}}{{/crossLink}} at index ***N*** in {{#crossLink "Lights"}}{{/crossLink}} | {{#crossLink "DirLight"}}{{/crossLink}} or {{#crossLink "PointLight"}}{{/crossLink}} |
 | uniform vec3 xeo_uLightIntensity&lt;***N***&gt;                   | Specular color of {{#crossLink "DirLight"}}{{/crossLink}} or {{#crossLink "PointLight"}}{{/crossLink}} at index ***N*** in {{#crossLink "Lights"}}{{/crossLink}} | {{#crossLink "DirLight"}}{{/crossLink}} or {{#crossLink "PointLight"}}{{/crossLink}} |
 | uniform vec3 xeo_uLightDir&lt;***N***&gt;                        | Direction of {{#crossLink "DirLight"}}{{/crossLink}} at index ***N*** in {{#crossLink "Lights"}}{{/crossLink}} | {{#crossLink "DirLight"}}{{/crossLink}} |
 | uniform vec3 xeo_uLightPos&lt;***N***&gt;                        | Position of {{#crossLink "PointLight"}}{{/crossLink}} at index ***N*** in {{#crossLink "Lights"}}{{/crossLink}} | {{#crossLink "PointLight"}}{{/crossLink}} |
 | uniform vec3 xeo_uLightConstantAttenuation&lt;***N***&gt;        | Constant attenuation factor for {{#crossLink "PointLight"}}{{/crossLink}} at index ***N*** in {{#crossLink "Lights"}}{{/crossLink}} | {{#crossLink "PointLight"}}{{/crossLink}} |
 | uniform vec3 xeo_uLightLinearAttenuation&lt;***N***&gt;          | Linear attenuation factor for {{#crossLink "PointLight"}}{{/crossLink}} at index ***N*** in {{#crossLink "Lights"}}{{/crossLink}} | {{#crossLink "PointLight"}}{{/crossLink}} |
 | uniform vec3 xeo_uLightQuadraticAttenuation&lt;***N***&gt;       | Quadratic attenuation factor for {{#crossLink "PointLight"}}{{/crossLink}} at index ***N*** in {{#crossLink "Lights"}}{{/crossLink}} | {{#crossLink "PointLight"}}{{/crossLink}} |
 |---|---|
 | uniform vec3 xeo_uDiffuse;       |  | {{#crossLink "PhongMaterial/diffuse:property"}}{{/crossLink}} |
 | uniform vec3 xeo_uSpecular;       |  | {{#crossLink "PhongMaterial/specular:property"}}{{/crossLink}} |
 | uniform vec3 xeo_uEmissive;       |  | {{#crossLink "PhongMaterial/emissive:property"}}{{/crossLink}} |
 | uniform float xeo_uOpacity;       |  | {{#crossLink "PhongMaterial/opacity:property"}}{{/crossLink}} |
 | uniform float xeo_uShininess;       |  | {{#crossLink "PhongMaterial/shininess:property"}}{{/crossLink}} |
 | uniform float xeo_uDiffuseFresnelBias;       |  | {{#crossLink "Fresnel/bias:property"}}{{/crossLink}} |

 #### Varying

 *Varying types are used in fragment shaders*

 | Varying | Description | Depends on  |
 |---|---|
 | varying vec4 xeo_vWorldPosition | |
 | varying vec4 xeo_vViewPosition | |
 | varying vec4 xeo_vColor | |

 #### Samplers

 *Samplers are used in fragment shaders*

 | Varying | Description | Depends on  |
 |---|---|



 @class Shader
 @module XEO
 @submodule shaders
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Shader in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Shader.
 @param [cfg.vertex=null] {String} GLSL Depends on code for the vertex shading staging.
 @param [cfg.fragment=null] {String} GLSL source code for the fragment shading staging.
 @param [cfg.params={}] {Object} Values for uniforms defined in the vertex and/or fragment stages.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Shader = XEO.Component.extend({

        type: "XEO.Shader",

        _init: function (cfg) {

            this._state = new XEO.renderer.Shader({
                vertex: null,
                fragment: null,
                params: {}
            });

            this.vertex = cfg.vertex;

            this.fragment = cfg.fragment;

            this.setParams(cfg.params);
        },

        _props: {

            /**
             * GLSL source code for this Shader's vertex stage.
             *
             * Fires a {{#crossLink "Shader/vertex:event"}}{{/crossLink}} event on change.
             *
             * @property vertex
             * @default null
             * @type String
             */
            vertex: {

                set: function (value) {

                    this._state.vertex = value;

                    // Trigger recompile
                    this.fire("dirty", true);

                    /**
                     * Fired whenever this Shader's {{#crossLink "Shader/vertex:property"}}{{/crossLink}} property changes.
                     *
                     * @event vertex
                     * @param value The property's new value
                     */
                    this.fire("vertex", this._state.vertex);
                },

                get: function () {
                    return this._state.vertex;
                }
            },

            /**
             * GLSL source code for this Shader's fragment stage.
             *
             * Fires a {{#crossLink "Shader/fragment:event"}}{{/crossLink}} event on change.
             *
             * @property fragment
             * @default null
             * @type String
             */
            fragment: {

                set: function (value) {

                    this._state.fragment = value;

                    // Trigger recompile
                    this.fire("dirty", true);

                    /**
                     * Fired whenever this Shader's {{#crossLink "Shader/fragment:property"}}{{/crossLink}} property changes.
                     *
                     * @event fragment
                     * @param value The property's new value
                     */
                    this.fire("fragment", this._state.fragment);
                },

                get: function () {
                    return this._state.fragment;
                }
            },

            /**
             * Params for this Shader.
             *
             * Fires a {{#crossLink "Shader/params:event"}}{{/crossLink}} event on change.
             *
             * @property params
             * @default {}
             * @type {}
             */
            params: {

                get: function () {
                    return this._state.params;
                }
            }
        },

        /**
         * Sets one or more params for this Shader.
         *
         * These will be individually overridden by any {{#crossLink "ShaderParams/setParams:method"}}params subsequently specified{{/crossLink}} on
         * {{#crossLink "ShaderParams"}}ShaderParams{{/crossLink}} on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.
         *
         * Fires a {{#crossLink "Shader/params:event"}}{{/crossLink}} event on change.
         *
         * @method setParams
         * @param {} [params={}] Values for params to set on this Shader, keyed to their names.
         */
        setParams: function (params) {

            for (var name in params) {
                if (params.hasOwnProperty(name)) {
                    this._state.params[name] = params[name];
                }
            }

            this._renderer.imageDirty = true;

            /**
             * Fired whenever this Shader's  {{#crossLink "Shader/params:property"}}{{/crossLink}}
             * property has been updated.
             *
             * @event params
             * @param value The property's new value
             */
            this.fire("params", this._state.params);
        },

        _compile: function () {
            this._renderer.shader = this._state;
        },

        _getJSON: function () {

            var json = {
                params: this._state.params
            };

            if (this._state.vertex) {
                json.vertex = this._state.vertex;
            }

            if (this._state.fragment) {
                json.fragment = this._state.fragment;
            }

            return json;
        }
    });

})();
;/**
 A **ShaderParams** sets uniform values for {{#crossLink "Shader"}}Shaders{{/crossLink}} on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>
 <li>Use ShaderParams components when you need to share the same {{#crossLink "Shader"}}Shaders{{/crossLink}} among multiple {{#crossLink "Entity"}}Entities{{/crossLink}},
 while setting the {{#crossLink "Shader"}}Shaders{{/crossLink}}' uniforms differently for each {{#crossLink "Entity"}}Entity{{/crossLink}}.</li>
 </ul>

 <img src="../../../assets/images/ShaderParams.png"></img>

 ## Example

 This example shows the simplest way to use a {{#crossLink "Shader"}}Shader{{/crossLink}}, where we're just going to render a ripply water
 pattern to a screen-aligned quad. As with all our examples, we're just creating the
 essential components while falling back on the <a href="XEO.Scene.html#defaults" class="crosslink">Scene's default components</a>
 for everything else.

 <img src="../../assets/images/shaderParamsExample1.png"></img>

 In our scene definition, we have an  {{#crossLink "Entity"}}Entity{{/crossLink}} that has a {{#crossLink "Geometry"}}Geometry{{/crossLink}} that is our
 screen-aligned quad, plus a {{#crossLink "Shader"}}Shader{{/crossLink}} that will render the fragments of that quad with our cool rippling water pattern.
 Finally, we animate the rippling by periodically updating the {{#crossLink "Shader"}}Shader{{/crossLink}}'s "time" uniform.

 ````javascript
 var scene = new XEO.Scene();

 // Shader that's shared by both our Entities. Note the 'xeo_aPosition' and 'xeo_aUV attributes',
 // which will receive the positions and UVs from the Geometry components. Also note the 'time'
 // uniform, which we'll be animating via the ShaderParams components.

 var shader = new XEO.Shader(scene, {

       // Vertex shading stage
       vertex: [
           "attribute vec3 xeo_aPosition;",
           "attribute vec2 xeo_aUV;",
           "varying vec2 vUv;",
           "void main () {",
           "    gl_Position = vec4(xeo_aPosition, 1.0);",
           "    vUv = xeo_aUV;",
           "}"
       ],

       // Fragment shading stage
       fragment: [
           "precision mediump float;",

           "uniform float time;",
           "varying vec2 vUv;",

           "void main( void ) {",
           "    vec2 sp = vUv;",
           "    vec2 p = sp*5.0 - vec2(10.0);",
           "    vec2 i = p;",
           "    float c = 1.0;",
           "    float inten = 0.10;",
           "    for (int n = 0; n < 10; n++) {",
           "        float t = time * (1.0 - (3.0 / float(n+1)));",
           "        i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));",
           "        c += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));",
           "    }",
           "    c /= float(10);",
           "    c = 1.5-sqrt(c);",
           "    gl_FragColor = vec4(vec3(c*c*c*c), 999.0) + vec4(0.0, 0.3, 0.5, 1.0);",
           "}"
       ],

       // Initial values for the 'time' uniform in the fragment stage.
       params: {
           time: 0.0
       }
  });

 // First Object using our Shader, with a quad covering the left half of the canvas,
 // along with its own ShaderParams to independently set its own values for the Shader's uniforms.

 var quad1 = new XEO.Geometry(scene, {
       primitive:"triangles",
       positions:[ 1, 1, 0, 0, 1, 0, 0, -1, 0, 1, -1, 0 ],
       normals:[ -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0 ],
       uv:[ 1, 1, 0, 1, 0, 0, 1, 0 ],
       indices:[ 0, 1, 2, 0, 2, 3 ]
  });

 var shaderParams1 = new XEO.ShaderParams(scene, {
       params: {
           time: 0.0
       }
  });

 var object1 = new XEO.Entity(scene, {
       shader: shader,
       geometry: quad1,
       shaderParams1: shaderParams1
  });

 // Second Object using the Shader, with a quad covering the right half of the canvas,
 // along with its own ShaderParams to independently set its own values for the Shader's uniforms.

 var quad2 = new XEO.Geometry(scene, {
       primitive:"triangles",
       positions:[ 1, 1, 0, 0, 1, 0, 0, -1, 0, 1, -1, 0 ],
       normals:[ -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0 ],
       uv:[ 1, 1, 0, 1, 0, 0, 1, 0 ],
       indices:[ 0, 1, 2, 0, 2, 3 ]
  });

 var shaderParams2 = new XEO.ShaderParams(scene, {
       params: {
           time: 0.0
       }
  });

 var object2 = new XEO.Entity(scene, {
       shader: shader,
       geometry2: quad2,
       shaderParams2: shaderParams2
  });

 ````
 Now let's animate the "time" parameter on the Shader, for each Object independently:

 ```` javascript
 scene.on("tick", function(params) {

            shaderParams1.setParams({
                time: params.timeElapsed
            });

            shaderParams2.setParams({
                time: params.timeElapsed  * 0.5
            });
        });
 ````
 @class ShaderParams
 @module XEO
 @submodule shaders
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this ShaderParams in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this ShaderParams.
 @param [cfg.params={}] {Object} The {{#crossLink "Shader"}}Shader{{/crossLink}} parameter values.
 @extends Component
 */
(function () {

    "use strict";

    XEO.ShaderParams = XEO.Component.extend({

        type: "XEO.ShaderParams",

        _init: function (cfg) {

            this._state = new XEO.renderer.ShaderParams({
                params: {}
            });

            this.setParams(cfg.params);
        },

        _props: {

            /**
             * Params for {{#crossLink "Shader"}}Shaders{{/crossLink}} on attached
             * {{#crossLink "Entity"}}Entities{{/crossLink}}.
             *
             * Fires a {{#crossLink "Shader/params:event"}}{{/crossLink}} event on change.
             *
             * @property params
             * @default {}
             * @type {}
             */
            params: {

                get: function () {
                    return this._state.params;
                }
            }
        },

        /**
         * Sets one or more params for {{#crossLink "Shader"}}Shaders{{/crossLink}} on attached
         * {{#crossLink "Entity"}}Entities{{/crossLink}}.
         *
         * These will individually override any params of the same names that are {{#crossLink "Shader/setParams:method"}}already specified{{/crossLink}} on
         * those {{#crossLink "Shader"}}Shaders{{/crossLink}}.
         *
         * Fires a {{#crossLink "ShaderParams/params:event"}}{{/crossLink}} event on change.
         *
         * @method setParams
         * @param {} [params={}] Values for params to set on the {{#crossLink "Shader"}}Shaders{{/crossLink}}, keyed to their names.
         */
        setParams: function (params) {

            for (var name in params) {
                if (params.hasOwnProperty(name)) {
                    this._state.params[name] = params[name];
                }
            }

            this._renderer.imageDirty = true;

            /**
             * Fired whenever this ShaderParams' {{#crossLink "ShaderParams/params:property"}}{{/crossLink}} property has been updated.
             * @event params
             * @param value The property's new value
             */
            this.fire("params", this._state.params);
        },

        _compile: function () {
            this._renderer.shaderParams = this._state;
        },

        _getJSON: function () {
            return {
                params: this._state.params
            };
        }
    });

})();
;/**
 * Skybox components.
 *
 * @module XEO
 * @submodule skyboxes
 */;/**

 A **Skybox** is a textured box that does not translate with respect to the
 {{#crossLink "Lookat"}}viewing transform{{/crossLink}}, to a provide the appearance of a background
 for associated {{#crossLink "Entities"}}Entities{{/crossLink}}.

 ## Overview

 TODO

 ## Example

 ````javascript
 // A bunch of random cube Entities

 for (var i = 0; i < 20; i++) {

        new XEO.Entity({
            transform: new XEO.Translate({
                xyz: [
                    Math.random() * 15 - 7,
                    Math.random() * 15 - 7,
                    Math.random() * 15 - 7
                ]
            }),
            material: new XEO.PhongMaterial({
                diffuse: [
                    Math.random(),
                    Math.random(),
                    Math.random()
                ]
            })
        });
    }

 // A Skybox that wraps our Entities in a cloudy background

 var skybox = new XEO.Skybox({
        src: "textures/skybox/miramarClouds.jpg",
        size: 1000 // Default
    });

 // Move the camera back a bit

 skybox.scene.camera.view.eye = [0, 0, -30];

 // Slowly orbit the camera on each frame

 skybox.scene.on("tick",
 function () {
         skybox.scene.camera.view.rotateEyeY(0.2);
     });

 // Allow user camera control

 new XEO.CameraControl();
 ````

 @class Skybox
 @module XEO
 @submodule skyboxes
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this Skybox within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted
 @param [cfg] {*} Skybox configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Skybox.
 @param [cfg.src=[null]] {String} Path to skybox texture
 @param [cfg.size=1000] {Number} Size of this Skybox, given as the distance from the center at [0,0,0] to each face.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Skybox = XEO.Component.extend({

        type: "XEO.Skybox",

        _init: function (cfg) {

            this._skybox = new XEO.Entity(this.scene, {

                geometry: new XEO.Geometry(this.scene, { // Box-shaped geometry
                    primitive: "triangles",
                    positions: [
                        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, // v0-v1-v2-v3 front
                        1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, // v0-v3-v4-v5 right
                        1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, // v0-v5-v6-v1 top
                        -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, // v1-v6-v7-v2 left
                        -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, // v7-v4-v3-v2 bottom
                        1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1 // v4-v7-v6-v5 back
                    ],
                    uv: [
                        0.5, 0.6666,
                        0.25, 0.6666,
                        0.25, 0.3333,
                        0.5, 0.3333,

                        0.5, 0.6666,
                        0.5, 0.3333,
                        0.75, 0.3333,
                        0.75, 0.6666,

                        0.5, 0.6666,
                        0.5, 1,
                        0.25, 1,
                        0.25, 0.6666,

                        0.25, 0.6666,
                        0.0, 0.6666,
                        0.0, 0.3333,
                        0.25, 0.3333,

                        0.25, 0,
                        0.50, 0,
                        0.50, 0.3333,
                        0.25, 0.3333,

                        0.75, 0.3333,
                        1.0, 0.3333,
                        1.0, 0.6666,
                        0.75, 0.6666
                    ],
                    indices: [
                        0, 1, 2,
                        0, 2, 3,
                        4, 5, 6,
                        4, 6, 7,
                        8, 9, 10,
                        8, 10, 11,
                        12, 13, 14,
                        12, 14, 15,

                        16, 17, 18,
                        16, 18, 19,

                        20, 21, 22,
                        20, 22, 23
                    ]
                }),

                transform: new XEO.Scale(this.scene, { // Scale the box
                    xyz: [2000, 2000, 2000] // Overridden when we initialize the 'size' property, below
                }),

                material: new XEO.PhongMaterial(this.scene, { // Emissive map of sky, no diffuse, ambient or specular reflection
                    ambient: [0, 0, 0],
                    diffuse: [0, 0, 0],
                    specular: [0, 0, 0],
                    emissiveMap: new XEO.Texture(this.scene, {
                        src: cfg.src
                    })
                }),

                stationary: new XEO.Stationary(this.scene, { // Lock skybox position with respect to viewpoint
                    active: true
                }),

                modes: new XEO.Modes(this.scene, {
                    backfaces: true, // Show interior faces of our skybox geometry
                    pickable: false, // Don't want to ba able to pick skybox

                    // SkyBox does not contribute to the size of any enclosing boundaries
                    // that might be calculated by xeoEngine, eg. like that returned by XEO.Scene#worldBoundary
                    collidable: false
                })
            });

            this.size = cfg.size; // Sets 'xyz' property on the Entity's Scale transform
        },

        _props: {

            /**
             * Size of this Skybox, given as the distance from the center at [0,0,0] to each face.
             *
             * Fires an {{#crossLink "Skybox/size:event"}}{{/crossLink}} event on change.
             *
             * @property size
             * @default 1000
             * @type {Number}
             */
            size: {

                set: function (value) {

                    this._size = value || 1000;

                    this._skybox.transform.xyz = [this._size, this._size, this._size];

                    /**
                     Fired whenever this Skybox's {{#crossLink "Skybox/size:property"}}{{/crossLink}} property changes.

                     @event size
                     @param value {Array of Number} The property's new value
                     */
                    this.fire("size", this._size);
                },

                get: function () {
                    return this._size;
                }
            }
        },

        _getJSON: function () {
            return {
                src: this._skybox.material.emissiveMap.src,
                size: this._size
            };
        }
    });

})();
;/**
 * Components to support spatial queries (eg. collisions etc).
 *
 * @module XEO
 * @submodule boundaries
 */;/**
 A **Boundary2D** is a Canvas-space 2D boundary.

 ## Overview

 A Boundary2D provides its spatial info in these properties:

 <ul>
 <li>{{#crossLink "Boundary2D/aabb:property"}}{{/crossLink}} - axis-aligned bounding box (AABB)</li>
 <li>{{#crossLink "Boundary2D/center:property"}}{{/crossLink}} - center coordinate </li>
 </ul>

 The following components have Boundary2Ds:

 <ul>
 <li>An {{#crossLink "Entity"}}{{/crossLink}} provides its Canvas-space boundary via
 its {{#crossLink "Entity/canvasBoundary:property"}}{{/crossLink}} property</li>
 </ul>

 <img src="../../../assets/images/Boundary2D.png"></img>

 ## Example

 An {{#crossLink "Entity"}}{{/crossLink}} provides its Canvas-space boundary as a Boundary2D that encloses
 its {{#crossLink "Geometry"}}{{/crossLink}} {{#crossLink "Geometry/positions:property"}}{{/crossLink}} after
 transformation by the Entity's {{#crossLink "Entity/transform:property"}}Modelling transform{{/crossLink}}
 and projection by the matrix of the Entity's {{#crossLink "Entity/camera:property"}}Modelling transform{{/crossLink}}.

 In this example we get the boundary and subscribe to updates on it, then animate the modelling transform,
 which gives us a running update of the moving boundary extents via our update handler.

 ```` javascript

 // Modelling transform
 var translate = new XEO.Translate({
    xyz: [-5, 0, 0]
 });

 // Entity that applies the modelling transform to the Geometry
 var entity = new XEO.Entity({
       geometry: myGeometry,
       transform: translate
  });

 var canvasBoundary = entity.canvasBoundary();

 // Canvas-space AABB
 var aabb = canvasBoundary.aabb;

 // Canvas-space center
 var center = canvasBoundary.center;

 // Subscribe to updates to the Boundary2D
 canvasBoundary.on("updated",
 function() {

        // Get the updated properties again

        aabb = canvasBoundary.aabb;
        center = canvasBoundary.center;

        //...
    });

 // Animate the modelling transform;
 // on each tick, this will update the Boundary2D and fire our
 // handler, enabling us to track the changing boundary.

 var x = 0;

 entity.scene.on("tick", function() {
    translate.xyz: [x, 0, 0];
    x += 0.5;
 });
 ````

 @class Boundary2D
 @module XEO
 @submodule boundaries
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Boundary2D within xeoEngine's default {{#crossLink "XEO/scene:property"}}scene{{/crossLink}} by default.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Boundary.
 @param [cfg.aabb] {Array of Number} Optional initial canvas-space 2D axis-aligned bounding volume (AABB).
 @param [cfg.center] {Array of Number} Optional initial canvas-space 2D center
 @param [cfg.getDirty] {Function} Optional callback to check if parent component has new OBB and matrix.
 @param [cfg.getOBB] {Function} Optional callback to get new view-space 3D OBB from parent.
 @param [cfg.getMatrix] {Function} Optional callback to get new projection matrix from parent.
 @param [cfg.shown] {Boolean} Set true to show a helper DIV that indicates the boundary.
 @extends Component
 */

/**
 * Fired whenever this Boundary2D's {{#crossLink "Boundary2D/abb:property"}}{{/crossLink}} abd {{#crossLink "Boundary2D/center:property"}}{{/crossLink}}.
 * properties change.
 * @event updated
 */
(function () {

    "use strict";

    XEO.Boundary2D = XEO.Component.extend({

        type: "XEO.Boundary2D",

        _init: function (cfg) {

            // Indicator DIV

            this._div = null;
            this._shown = false;

            // Cached boundaries

            this._obb = null; // Private 3D View-space OBB
            this._aabb = cfg.aabb || null; // 2D Canvas-space AABB
            this._center = cfg.center || null; // 2D Canvas-space center

            // Optional callbacks to lazy-pull
            // data from owner component

            this._getDirty = cfg.getDirty;
            this._getOBB = cfg.getOBB;
            this._getMatrix = cfg.getMatrix;

            this.shown = cfg.shown;
        },

        _props: {

            /**
             * 2D Canvas-space axis-aligned bounding box (AABB).
             *
             * @property aabb
             * @final
             * @type {*}
             */
            aabb: {

                get: function () {

                    if (this._getDirty()) {
                        this._buildBoundary();
                    }

                    return this._aabb;
                }
            },

            /**
             * 2D Canvas-space center point.
             *
             * @property center
             * @final
             * @type {Array of Number}
             */
            center: {

                get: function () {

                    if (this._getDirty()) {
                        this._buildBoundary();
                    }

                    return this._center;
                }
            },

            /**
             * When true, shows a helper DIV that indicates the boundary.
             *
             * @property shown
             * @type {Boolean}
             */
            shown: {

                set: function (value) {

                    if (value === this._shown) {
                        return;
                    }

                    if (value) {
                        if (!this._div) {

                            var body = document.getElementsByTagName("body")[0];
                            var div = document.createElement('div');

                            var style = div.style;
                            style.position = "absolute";
                            style.padding = "0";
                            style.margin = "0";
                            style.border = "3px solid #99FF99";
                            style["border-radius"] = "10px";
                            style["z-index"] = "1000";

                            body.appendChild(div);

                            var self = this;

                            this.on("updated",
                                function () {

                                    var aabb = self.aabb;

                                    div.style.left = aabb.min[0] + "px";
                                    div.style.top = aabb.min[1] + "px";
                                    div.style.width = (aabb.max[0] - aabb.min[0]) + "px";
                                    div.style.height = (aabb.max[1] - aabb.min[1]) + "px";
                                });

                            this._div = div;
                        }
                    } else {
                        if (this._div) {
                            this._div.parentNode.removeChild(this._div);
                            this._div = null;
                        }
                    }

                    this._shown = value;

                    /**
                     * Fired whenever this Boundary2d's
                     * {{#crossLink "Boundary2d/shown:property"}}{{/crossLink}} property changes.
                     * @event shown
                     * @param value The property's new value
                     */
                    this.fire("shown", this._shown);
                },

                get: function () {
                    return this._shown;
                }
            }
        },

        // Lazy (re)builds the obb, aabb and center.

        _buildBoundary: function () {

            var math = XEO.math;

            var canvas = this.scene.canvas.canvas;
            var width = canvas.width;
            var height = canvas.height;

            if (!this._obb) {

                // Lazy-allocate

                this._obb = [];
                this._aabb = XEO.math.AABB2();
                this._center = XEO.math.vec2();
            }

            var obb = this._getOBB();
            var matrix = this._getMatrix();

            if (obb && matrix) {

                math.transformPoints3(matrix, obb, this._obb);
                math.points3ToAABB2(this._obb, this._aabb);
                math.AABB2ToCanvas(this._aabb, width, height);
                math.getAABB2Center(this._aabb, this._center);
            }
        },

        _getJSON: function () {
            return {
                aabb: this.aabb,
                center: this.center
            };
        }
    });

})();
;/**
 A **Boundary3D** provides the axis-aligned and object-aligned extents of its owner component.

 ## Overview

 As shown in the diagram below, the following xeoEngine components have Boundary3Ds:
 * A {{#crossLink "Scene/worldBoundary:property"}}Scene's worldBoundary{{/crossLink}} provides a **World**-space boundary of all its {{#crossLink "Entity"}}Entities{{/crossLink}}
 * A {{#crossLink "Geometry/localBoundary:property"}}Geometry's localBoundary{{/crossLink}} provides a **Local**-space boundary enclosing its {{#crossLink "Geometry/positions:property"}}positions{{/crossLink}}
 * An {{#crossLink "Entity/localBoundary:property"}}Entity's localBoundary{{/crossLink}} (also) provides the **Local**-space boundary of its {{#crossLink "Geometry"}}{{/crossLink}}
 * An {{#crossLink "Entity/worldBoundary:property"}}Entity's worldBoundary {{/crossLink}} provides a **World**-space boundary that encloses
 its {{#crossLink "Geometry"}}Geometry's{{/crossLink}} {{#crossLink "Geometry/positions:property"}}{{/crossLink}} after
 their transformation by the {{#crossLink "Entity/transform:property"}}Entity's Modelling transform{{/crossLink}}.
 * An {{#crossLink "Entity/viewBoundary:property"}}Entity's viewBoundary{{/crossLink}} provides a **View**-space boundary that encloses
 its {{#crossLink "Geometry"}}Geometry's{{/crossLink}} {{#crossLink "Geometry/positions:property"}}{{/crossLink}} after
 their transformation by both the {{#crossLink "Entity/transform:property"}}Entity's Modelling transform{{/crossLink}} **and** {{#crossLink "Camera/view:property"}}Viewing transform{{/crossLink}}.
 * A {{#crossLink "CollectionBoundary/worldBoundary:property"}}CollectionBoundary's worldBoundary{{/crossLink}} provides a **World**-space boundary that encloses all the {{#crossLink "Entity"}}Entities{{/crossLink}} contained within its {{#crossLink "Collection"}}Collection{{/crossLink}}.

 Also shown in the diagram is an {{#crossLink "Entity/canvasBoundary:property"}}Entity's canvasBoundary{{/crossLink}}, which is a {{#crossLink "Boundary2D"}}{{/crossLink}} that provides a **Canvas**-space boundary that encloses the {{#crossLink "Geometry"}}Geometry's{{/crossLink}} {{#crossLink "Geometry/positions:property"}}{{/crossLink}}, after
 their transformation by the {{#crossLink "Entity/transform:property"}}Entity's Modelling transform{{/crossLink}}, {{#crossLink "Camera/view:property"}}Viewing transform{{/crossLink}}
 and {{#crossLink "Camera/project:property"}}Projection transform{{/crossLink}}.

 <br><br>
 <img src="../../../assets/images/Boundary3D.png"></img>

 ## OBB and AABB Representations

 Each Boundary3D instance provides two boundary representations, in these properties:

 <ul>
 <li>{{#crossLink "Boundary3D/obb:property"}}{{/crossLink}} - an object-aligned bounding box (OBB), as an array of eight corner vertex positions</li>
 <li>{{#crossLink "Boundary3D/aabb:property"}}{{/crossLink}} - an axis-aligned bounding box (AABB), as minimum and maximum corner vertex positions</li>
 </ul>

 The screenshot below shows an Entity (the green nut) with wireframe boxes indicating its World-space OOBB (yellow). World-space AABB (red) and
 Canvas-space AABB (green).

 <br><br>
 <img src="../../../assets/images/boundaries.png"></img>

 ## Example

 In the example below we'll get the World-space Boundary3D of an {{#crossLink "Entity"}}{{/crossLink}}, subscribe to updates on the Boundary3D,
 then animate the {{#crossLink "Entity"}}Entity's{{/crossLink}} modelling transform, which gives our callback a running update
 of the moving Boundary3D extents.

 ```` javascript

 // Geometry and modelling transform components

 var geometry = new XEO.BoxGeometry();

 var translate = new XEO.Translate({
    xyz: [-5, 0, 0]
 });

 // Create an Entity that has the Geometry and the transform

 var entity = new XEO.Entity({
       geometry: myGeometry,
       transform: translate
  });

 // Get the Entity's World-space Boundary3D and query its
 // various spatial properties

 var worldBoundary = entity.worldBoundary;

 var obb = worldBoundary.obb; // Object-aligned boundary, an array of eight corner vertex positions
 var aabb = worldBoundary.aabb; // an axis-aligned bounding box (AABB), as minimum and maximum corner vertex positions
 var center = worldBoundary.center; // Center point

 // Subscribe to updates to the Boundary3D

 worldBoundary.on("updated",
 function() {

        // Query the updated Boundary3D properties

        obb = worldBoundary.obb;
        aabb = worldBoundary.aabb;
        center = worldBoundary.center;

        //...
    });

 // Animate the modelling transform;
 // on each tick, this will update the Boundary3D and fire our
 // callback, which enables us to track the changing boundary.

 var x = 0;

 scene.on("tick", function() {
    translate.xyz: [x, 0, 0];
    x += 0.5;
 });
 ````

 @class Boundary3D
 @module XEO
 @submodule boundaries
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Boundary3D within xeoEngine's default {{#crossLink "XEO/scene:property"}}scene{{/crossLink}} by default.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Boundary3D.
 @param [cfg.obb] {Array of Number} Optional initial 3D object-aligned bounding volume (OBB).
 @param [cfg.aabb] {Array of Number} Optional initial 3D axis-aligned bounding volume (AABB).
 @param [cfg.center] {Array of Number} Optional initial 3D center
 @param [cfg.getDirty] {Function} Optional callback to check if parent component has new OBB, positions or transform matrix.
 @param [cfg.getOBB] {Function} Optional callback to get new OBB from parent.
 @param [cfg.getMatrix] {Function} Optional callback to get new transform matrix from parent.
 @param [cfg.getPositions] {Function} Optional callback to get new positions from parent.
 @extends Component
 */

/**
 * Fired whenever this Boundary3D's {{#crossLink "Boundary3D/obb:property"}}{{/crossLink}},
 * {{#crossLink "Boundary3D/aabb:property"}}{{/crossLink}} or {{#crossLink "Boundary3D/center:property"}}{{/crossLink}}.
 * properties change.
 * @event updated
 */
(function () {

    "use strict";

    XEO.Boundary3D = XEO.Component.extend({

        type: "XEO.Boundary3D",

        _init: function (cfg) {

            // Cached bounding boxes (oriented and axis-aligned) 

            this._obb = cfg.obb || null;
            this._aabb = cfg.aabb || null;

            // Cached center point

            this._center = cfg.center || null;

            // Owner injected callbacks to provide
            // resources on lazy-rebuild

            this._getDirty = cfg.getDirty;
            this._getOBB = cfg.getOBB;
            this._getAABB = cfg.getAABB;
            this._getMatrix = cfg.getMatrix;
            this._getPositions = cfg.getPositions;
        },

        _props: {

            /**
             * 3D oriented bounding box (OBB).
             *
             * @property obb
             * @final
             * @type {*}
             */
            obb: {

                get: function () {

                    if (this._getDirty()) {
                        this._buildBoundary();
                    }

                    return this._obb;
                }
            },

            /**
             * 3D axis-aligned bounding box (AABB).
             *
             * @property aabb
             * @final
             * @type {*}
             */
            aabb: {

                get: function () {

                    if (this._getDirty()) {
                        this._buildBoundary();
                    }

                    return this._aabb;
                }
            },

            /**
             * 3D center point.
             *
             * @property center
             * @final
             * @type {Array of Number}
             */
            center: {

                get: function () {

                    if (this._getDirty()) {
                        this._buildBoundary();
                    }

                    return this._center;
                }
            }
        },

        // (Re)builds the obb, aabb and center.

        _buildBoundary: function () {

            var math = XEO.math;

            // Lazy-allocate

            if (!this._obb) {
                this._obb = [];
            }

            if (!this._aabb) {
                this._aabb = XEO.math.AABB3();
            }

            if (!this._center) {
                this._center = XEO.math.vec3();
            }

            var aabb = this._getAABB ? this._getAABB() : null;

            if (aabb) {

                // Got AABB

                // Derive OBB and center

                this._aabb.min[0] = aabb.min[0];
                this._aabb.min[1] = aabb.min[1];
                this._aabb.min[2] = aabb.min[2];
                this._aabb.max[0] = aabb.max[0];
                this._aabb.max[1] = aabb.max[1];
                this._aabb.max[2] = aabb.max[2];

                math.AABB3ToOBB3(this._aabb, this._obb);
                math.getAABBCenter(this._aabb, this._center);

                return;
            }

            // Get resources through callbacks

            var positions = this._getPositions ? this._getPositions() : null;

            var matrix;

            if (positions) {

                // Got flattened WebGL positions array

                matrix = this._getMatrix ? this._getMatrix() : null;

                if (matrix) {

                    // Got transform matrix

                    // Transform OOBB by matrix,
                    // derive AABB and center

                    math.positions3ToAABB3(positions, this._aabb);
                    math.AABB3ToOBB3(this._aabb, this._obb);
                    this._obb = math.transformPoints3(matrix, this._obb);
                    math.points3ToAABB3(this._obb, this._aabb);
                    math.getAABBCenter(this._aabb, this._center);

                    return;

                }

                // No transform matrix

                math.positions3ToAABB3(positions, this._aabb);
                math.AABB3ToOBB3(this._aabb, this._obb);
                math.getAABBCenter(this._aabb, this._center);

                return
            }

            var obb = this._getOBB ? this._getOBB() : null;

            if (obb) {

                // Got OOBB (array of eight four-element subarrays)

                matrix = this._getMatrix ? this._getMatrix() : null;

                if (matrix) {

                    // Got transform matrix

                    // Transform OOBB by matrix,
                    // derive AABB and center

                    math.transformPoints3(matrix, obb, this._obb);
                    math.points3ToAABB3(this._obb, this._aabb);
                    math.getAABBCenter(this._aabb, this._center);

                    return;
                }

                // No transform matrix

                // Copy OOBB, derive AABB and center

                for (var i = 0, len = obb.length; i < len; i++) {
                    this._obb[i] = obb[i];
                }

                math.points3ToAABB3(this._obb, this._aabb);
                math.getAABBCenter(this._aabb, this._center);
            }
        },

        _getJSON: function () {
            return {
                obb: this.obb,
                aabb: this.aabb,
                center: this.center
            };
        }
    });

})();
;/**
 A **CollectionBoundary** TODO.

 ## Overview

 <ul>

 <li>TODO</li>

 </ul>

 <img src="../../../assets/images/CollectionBoundary.png"></img>

 ## Example

 TODO

 ````javascript
 var collectionBoundary = new XEO.CollectionBoundary({

    collection: new XEO.Collection({

        components: [
            new XEO.Entity({
                ..,,
            }),
            new XEO.Entity({
                ..,,
            }),
            new XEO.Entity({
                //..
            })
        ]
    })
});

 var showBoundary = new XEO.Entity({
        geometry: new XEO.BoundaryGeometry({
            boundary: collectionBoundary.worldBoundary
        }),
        material: new XEO.PhongMaterial({
            diffuse: [1,0,0]
        })
    });
 ````

 @class CollectionBoundary
 @module XEO
 @submodule boundaries
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this CollectionBoundary within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} CollectionBoundary configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this CollectionBoundary.
 @param [cfg.emissiveMap=null] {Collection} A {{#crossLink "Collection"}}Collection{{/crossLink}} to fit the {{#crossLink "CollectionBoundary/worldBoundary:property"}}{{/crossLink}} to. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this CollectionBoundary.
 @extends Component
 */
(function () {

    "use strict";

    XEO.CollectionBoundary = XEO.Component.extend({

        type: "XEO.CollectionBoundary",

        _init: function (cfg) {

            this._onAdded = {};
            this._onUpdated = {};
            this._onRemoved = {};

            this._aabb = null;
            this._aabbDirty = false;
            this._worldBoundary = null;

            this.collection = cfg.collection;
        },

        _props: {

            /**
             * The {{#crossLink "Collection"}}{{/crossLink}} attached to this CollectionBoundary.
             *
             * Fires a {{#crossLink "CollectionBoundary/collection:event"}}{{/crossLink}} event on change.
             *
             * @property collection
             * @type Collection
             */
            collection: {

                set: function (value) {

                    // Unsubscribe from old Collection's events

                    var oldCollection = this._children.collection;

                    if (oldCollection && (!value || value.id !== oldCollection.id)) {

                        oldCollection.off(this._onAdded);
                        oldCollection.off(this._onRemoved);

                        oldCollection.iterate(this._unbind, this);
                    }

                    /**
                     * Fired whenever this CollectionBoundary's {{#crossLink "CollectionBoundary/collection:property"}}{{/crossLink}} property changes.
                     *
                     * @event collection
                     * @param value The property's new value
                     */
                    var collection = this._setChild("collection", value);

                    if (collection) {

                        this._onAdded = collection.on("added", this._added, this);
                        this._onRemoved = collection.on("removed", this._removed, this);

                        collection.iterate(this._bind, this);

                        this._setAABBDirty();
                    }

                    this._setAABBDirty();
                },

                get: function () {
                    return this._children.collection;
                }
            },

            /**
             * World-space 3D boundary enclosing all the components contained in {{#crossLink "CollectionBoundary/collection:property"}}{{/crossLink}}.
             *
             * If you call {{#crossLink "Component/destroy:method"}}{{/crossLink}} on this boundary, then
             * this property will be assigned to a fresh {{#crossLink "Boundary3D"}}{{/crossLink}} instance next
             * time you reference it.
             *
             * @property worldBoundary
             * @type Boundary3D
             * @final
             */
            worldBoundary: {

                get: function () {

                    if (!this._worldBoundary) {

                        var self = this;

                        this._worldBoundary = new XEO.Boundary3D(this.scene, {

                            getDirty: function () {
                                if (self._aabbDirty) {
                                    self._buildAABB();
                                    self._aabbDirty = false;
                                    return true;
                                }
                                return false;
                            },

                            getAABB: function () {
                                return self._aabb;
                            }
                        });

                        this._worldBoundary.on("destroyed",
                            function () {
                                self._worldBoundary = null;
                            });
                    }

                    return this._worldBoundary;
                }
            }
        },

        _added: function (c) {
            if (c.worldBoundary) {
                this._bind(c);
            }
            if (!this._aabbDirty) {
                this._setAABBDirty();
            }
        },

        _removed: function (c) {
            if (c.worldBoundary) {
                this._unbind(c);
            }
            if (!this._aabbDirty) {
                this._setAABBDirty();
            }
        },

        _bind: function (c) {
            var worldBoundary = c.worldBoundary;
            if (!worldBoundary) {
                return;
            }
            this._onUpdated[c.id] = worldBoundary.on("updated", this._updated, this);
        },

        _updated: function () {
            if (!this._aabbDirty) {
                this._setAABBDirty();
            }
        },

        _unbind: function (c) {
            var worldBoundary = c.worldBoundary;
            if (!worldBoundary) {
                return;
            }
            worldBoundary.off(this._onUpdated[c.id]);
            delete this._onUpdated[c.id];
        },

        _setAABBDirty: function () {
            this._aabbDirty = true;
            if (this._worldBoundary) {
                this._worldBoundary.fire("updated", true);
            }
        },

        _buildAABB: function () {

            if (!this._aabb) {
                this._aabb = XEO.math.AABB3();
            }

            var xmin = 100000;
            var ymin = 100000;
            var zmin = 100000;
            var xmax = -100000;
            var ymax = -100000;
            var zmax = -100000;

            var component;
            var worldBoundary;
            var aabb;
            var min;
            var max;

            var collection = this.collection;

            if (collection) {

                var components = collection.components;

                for (var componentId in components) {
                    if (components.hasOwnProperty(componentId)) {

                        component = components[componentId];

                        worldBoundary = component.worldBoundary;
                        if (worldBoundary) {

                            aabb = worldBoundary.aabb;
                            min = aabb.min;
                            max = aabb.max;

                            if (min[0] < xmin) {
                                xmin = min[0];
                            }

                            if (min[1] < ymin) {
                                ymin = min[1];
                            }

                            if (min[2] < zmin) {
                                zmin = min[2];
                            }

                            if (max[0] > xmax) {
                                xmax = max[0];
                            }

                            if (max[1] > ymax) {
                                ymax = max[1];
                            }

                            if (max[2] > zmax) {
                                zmax = max[2];
                            }
                        }
                    }
                }
            }

            this._aabb.min[0] = xmin;
            this._aabb.min[1] = ymin;
            this._aabb.min[2] = zmin;
            this._aabb.max[0] = xmax;
            this._aabb.max[1] = ymax;
            this._aabb.max[2] = zmax;
        },

        _getJSON: function () {
            var json = {};
            if (this.collection) {
                json.collection = this.collection.id
            }
            return json;
        },

        _destroy: function () {

            this.collection = null; // Unsubscribes from worldBoundary updates on Collection members

            if (this._worldBoundary) {
                this._worldBoundary.destroy();
            }
        }
    });

})
();
;/**
 * Modelling transform components.
 *
 * @module XEO
 * @submodule transforms
 */;/**
 A **Transform** defines a modelling matrix to transform attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>
 <li>Sub-classes of Transform are: {{#crossLink "Translate"}}{{/crossLink}},
 {{#crossLink "Scale"}}{{/crossLink}}, {{#crossLink "Rotate"}}{{/crossLink}}, and {{#crossLink "Quaternion"}}{{/crossLink}}</li>
 <li>Instances of Transform and its sub-classes may be connected into hierarchies.</li>
 <li>An {{#crossLink "Entity"}}{{/crossLink}} would be connected to a leaf Transform
 within a hierarchy, and would be transformed by each Transform on the path up to the root, in that order.</li>
 <li>See <a href="./Shader.html#inputs">Shader Inputs</a> for the variables that Transform create within xeoEngine's shaders.</li>
 </ul>

 <img src="../../../assets/images/Transform.png"></img>

 ## Example

 TODO

 <img src="../../../assets/images/transformHierarchy.png"></img>

 ````javascript

 // Position of entire table

 var tablePos = new XEO.Translate({
        xyz: [0, 6, 0]
    });

 // Orientation of entire table

 var tableRotate = new XEO.Rotate({
        xyz: [1, 1, 1],
        angle: 0,
        parent: tablePos
    });

 // Red table leg

 var tableLg1 = new XEO.Entity({
        transform: new XEO.Scale({
            xyz: [1, 3, 1],
            parent: new XEO.Translate({
                xyz: [-4, -6, -4],
                parent: tableRotate
            })
        }),
        material: new XEO.PhongMaterial({
            diffuse: [1, 0.3, 0.3]
        })
    });

 // Green table leg

 var tableLeg2 = new XEO.Entity({
        transform: new XEO.Scale({
            xyz: [1, 3, 1],
            parent: new XEO.Translate({
                xyz: [4, -6, -4],
                parent: tableRotate
            })
        }),
        material: new XEO.PhongMaterial({
            diffuse: [0.3, 1.0, 0.3]
        })
    });

 // Blue table leg

 var tableLeg3 = new XEO.Entity({
        transform: new XEO.Scale({
            xyz: [1, 3, 1],
            parent: new XEO.Translate({
                xyz: [4, -6, 4],
                parent: tableRotate
            })
        }),
        material: new XEO.PhongMaterial({
            diffuse: [0.3, 0.3, 1.0]
        })
    });

 // Yellow table leg

 var tableLeg4 = new XEO.Entity({
        transform: new XEO.Scale({
            xyz: [1, 3, 1],
            parent: new XEO.Translate({
                xyz: [-4, -6, 4],
                parent: tableRotate
            })
        }),
        material: new XEO.PhongMaterial({
            diffuse: [1.0, 1.0, 0.0]
        })
    });

 // Purple table top

 var tableTop = new XEO.Entity({
        transform: new XEO.Scale({
            xyz: [6, 0.5, 6],
            parent: new XEO.Translate({
                xyz: [0, -3, 0],
                parent: tableRotate
            })
        }),
        material: new XEO.PhongMaterial({
            diffuse: [1.0, 0.3, 1.0]
        })
    });

 // Zoom camera out a bit
 // Get the Camera from one of the Entities

 tableTop.camera.view.zoom(10);

 // Spin the entire table

 var angle = 0;

 scene.on("tick", function () {

        angle += 0.5;

        tableRotate.angle = angle;
    });
 ````

 @class Transform
 @module XEO
 @submodule transforms
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Transform in the
 default {{#crossLink "Scene"}}Scene{{/crossLink}}  when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 You only need to supply an ID if you need to be able to find the Transform by ID within the {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Transform.
 @param [cfg.parent] {String|Transform} ID or instance of a parent Transform within the same {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg.matrix=[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]] {Array of Number} One-dimensional, sixteen element array of elements for the Transform, an identity matrix by default.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Transform = XEO.Component.extend({

        type: "XEO.Transform",

        _init: function (cfg) {

            this._leafMatrixDirty = false;

            this._onParentUpdated = null;
            this._onParentDestroyed = null;

            var mat = XEO.math.identityMat4(XEO.math.mat4());
            var invMat = XEO.math.inverseMat4(mat, XEO.math.mat4());

            this._state = new XEO.renderer.ModelTransform({
                matrix: mat,
                normalMatrix: invMat
            });

            this.parent = cfg.parent;
            this.matrix = cfg.matrix;
        },

        _props: {

            /**
             * The parent Transform.
             *
             * Fires a {{#crossLink "Transform/parent:event"}}{{/crossLink}} event on change.
             *
             * @property parent
             * @type Transform
             */
            parent: {

                set: function (value) {

                    // Unsubscribe from old parent's events

                    if (this._parent && (!value || value.id !== this._parent.id)) {
                        this._parent.off(this._onParentUpdated);
                        this._parent.off(this._onParentDestroyed);
                    }

                    this._parent = value;

                    /**
                     * Fired whenever this Transform's {{#crossLink "Transform/parent:property"}}{{/crossLink}} property changes.
                     * @event parent
                     * @param value The property's new value
                     */
                    this.fire("parent", this._parent);

                    if (this._parent) {
                        this._onParentUpdated = this._parent.on("updated", this._parentUpdated, this);
                        this._onParentDestroyed = this._parent.on("destroyed", this._parentUpdated, this);
                    }

                    this._parentUpdated();
                },

                get: function () {
                    return this._parent;
                }
            },

            /**
             * The Transform's local matrix.
             *
             * Fires a {{#crossLink "Transform/matrix:event"}}{{/crossLink}} event on change.
             *
             * @property matrix
             * @default [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
             * @type {Array of Number}
             */
            matrix: {

                set: function (value) {

                    value = value || XEO.math.identityMat4();

                    if (!this._matrix) {
                        this._matrix = XEO.math.mat4();
                    }

                    this._matrix.set(value);

                    this._leafMatrixDirty = true;

                    /**
                     * Fired whenever this Transform's {{#crossLink "Transform/matrix:property"}}{{/crossLink}} property changes.
                     * @event matrix
                     * @param value The property's new value
                     */
                    this.fire("matrix", this._matrix);

                    this.fire("updated", true);
                },

                get: function () {
                    return this._matrix;
                }
            },


            /**
             * Returns the product of all {{#crossLink "Transform/matrix:property"}}{{/crossLink}}'s on Transforms
             * on the path via {{#crossLink "Transform/parent:property"}}{{/crossLink}} up to the root.
             *
             * The value of this property will have a fresh value after each
             * {{#crossLink "Transform/updated:property"}}{{/crossLink}} event, which is fired whenever any Transform
             * on the path receives an update for its {{#crossLink "Transform/matrix:property"}}{{/crossLink}} or
             * {{#crossLink "Transform/matrix:property"}}{{/crossLink}} property.
             *
             * @property matrix
             * @default [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
             * @type {Array of Number}
             */
            leafMatrix: {

                get: function () {

                    if (this._leafMatrixDirty) {
                        this._buildLeafMatrix();
                    }

                    return this._state.matrix;
                }
            }
        },

        _parentUpdated: function () {

            this._leafMatrixDirty = true;

            /**
             * Fired whenever this Transform's {{#crossLink "Transform/leafMatrix:property"}}{{/crossLink}} property changes.
             *
             * This event does not carry the updated property value. Instead, subscribers will need to read
             * that property again to get its updated value (which may be lazy-computed then).
             *
             * @event updated
             */
            this.fire("updated", true);
        },

        // This is called if necessary when reading "leafMatrix", to update that property.
        // It's also called by Entity when the Transform is the leaf to which the
        // Entity is attached, in response to an "updated" event from the Transform.

        _buildLeafMatrix: function () {

            if (!this._leafMatrixDirty) {
                return;
            }

            this._state.matrix = this._state.matrix || XEO.math.identityMat4();

            if (!this._parent) {

                // No parent Transform;
                // copy matrix property into the render state's matrix

                var m1 = this._matrix;
                var m2 = this._state.matrix;

                for (var i = 0, len = m1.length; i < len; i++) {
                    m2[i] = m1[i];
                }

            } else {

                // Multiply parent's leaf matrix by this matrix,
                // store result in the render state's matrix

                XEO.math.mulMat4(this._parent.leafMatrix, this._matrix, this._state.matrix);
            }

            // Create normal matrix from inverse
            // of the state's matrix

            // TODO: only compute normal matrix on leaf!

            if (!this._state.normalMatrix) {
                this._state.normalMatrix = XEO.math.identityMat4();
            }

            XEO.math.inverseMat4(this._state.matrix, this._state.normalMatrix);
            XEO.math.transposeMat4(this._state.normalMatrix);

            this._renderer.imageDirty = true; //  TODO : Where should this go?

            this._leafMatrixDirty = false;
        },

        _compile: function () {
            this._renderer.modelTransform = this._state;
        },

        _getJSON: function () {
            return {
                matrix: Array.prototype.slice.call(this._matrix)
            };
        },

        _destroy: function () {
            if (this._parent) {
                this._parent.off(this._onParentUpdated);
                this._parent.off(this._onParentDestroyed);
            }
        }
    });

})();
;/**

 A **Rotate** rotates associated {{#crossLink "Entity"}}Entities{{/crossLink}} about an axis vector.

 ## Overview

 <ul>
 <li>Rotate is a sub-class of {{#crossLink "Transform"}}{{/crossLink}}</li>
 <li>Instances of Transform and its sub-classes may be connected into hierarchies.</li>
 <li>An {{#crossLink "Entity"}}{{/crossLink}} would be connected to a leaf Transform
 within a hierarchy, and would be transformed by each Transform on the path up to the root, in that order.</li>
 <li>See <a href="./Shader.html#inputs">Shader Inputs</a> for the variables that Transform create within xeoEngine's shaders.</li>
 </ul>


 <img src="../../../assets/images/Rotate.png"></img>

 ## Example

 In this example we have two {{#crossLink "Entity"}}Entities{{/crossLink}} that are transformed by a hierarchy that contains
 Rotate, {{#crossLink "Translate"}}{{/crossLink}} and {{#crossLink "Scale"}}{{/crossLink}} transforms.
 The Entities share the same {{#crossLink "Geometry"}}{{/crossLink}}, which is the default 2x2x2 cube.<br>

 ````javascript
 var scene = new XEO.Scene();

 var rotate = new XEO.Rotate(scene, {
    xyz: [0, 1, 0], // Rotate 30 degrees about Y axis
    angle: 30
});

 var translate1 = new XEO.Translate(scene, {
    parent: rotate,
    xyz: [-5, 0, 0] // Translate along -X axis
});

 var translate2 = new XEO.Translate(scene, {
    parent: rotate,
    xyz: [5, 0, 0] // Translate along +X axis
});

 var scale = new XEO.Scale(scene, {
    parent: translate2,
    xyz: [1, 2, 1] // Scale x2 on Y axis
});

 var geometry = new XEO.Geometry(scene); // Defaults to a 2x2x2 box

 var Entity1 = new XEO.Entity(scene, {
    transform: translate1,
    geometry: geometry
});

 var Entity2 = new XEO.Entity(scene, {
    transform: scale,
    geometry: geometry
});
 ````

 Since everything in xeoEngine is dynamically editable, we can restructure the transform hierarchy at any time.

 Let's insert a {{#crossLink "Scale"}}{{/crossLink}} between the first Translate and the first {{#crossLink "Entity"}}{{/crossLink}}:

 ````javascript
 var scale2 = new XEO.Scale(scene, {
    parent: translate1,
    xyz: [1, 1, 2] // Scale x2 on Z axis
});

 Entity2.transform = scale2;
 ````

 And just for fun, we'll start spinning the {{#crossLink "Rotate"}}{{/crossLink}}:

 ````javascript
 // Rotate 0.2 degrees on each frame
 scene.on("tick", function(e) {
    rotate.angle += 0.2;
});
 ````
 @class Rotate
 @module XEO
 @submodule transforms
 @extends Transform
 */
(function () {

    "use strict";

    XEO.Rotate = XEO.Transform.extend({

        type: "XEO.Rotate",

        _init: function (cfg) {

            this._super(cfg);

            this.xyz = cfg.xyz;
            this.angle = cfg.angle;
        },

        _props: {

            /**
             * Vector indicating the axis of rotation.
             *
             * Fires an {{#crossLink "Rotate/xyz:event"}}{{/crossLink}} event on change.
             *
             * @property xyz
             * @default [0,1,0]
             * @type {Array of Number}
             */
            xyz: {

                set: function (value) {

                    value = value || [0, 1, 0];

                    if (this._xyz) {
                        if (this._xyz[0] === value[0] && this._xyz[1] === value[1] && this._xyz[2] === value[2]) {
                            return;
                        } else {
                            this._xyz[0] = value[0];
                            this._xyz[1] = value[1];
                            this._xyz[2] = value[2];
                        }
                    } else {
                        this._xyz = value;
                    }

                    this._buildMatrix();

                    /**
                     Fired whenever this Rotate's {{#crossLink "Rotate/xyz:property"}}{{/crossLink}} property changes.

                     @event xyz
                     @param value {Array of Number} The property's new value
                     */
                    this.fire("xyz", this._xyz);
                },

                get: function () {
                    return this._xyz;
                }
            },

            /**
             * Angle of rotation in degrees.
             *
             * Fires an {{#crossLink "Rotate/angle:event"}}{{/crossLink}} event on change.
             *
             * @property angle
             * @default 0
             * @type {Number}
             */
            angle: {

                set: function (value) {

                    this._angle = value || 0;

                    this._buildMatrix();

                    /**
                     Fired whenever this Rotate's {{#crossLink "Rotate/angle:property"}}{{/crossLink}} property changes.

                     @event angle
                     @param value {Array of Number} The property's new value
                     */
                    this.fire("angle", this._angle);
                },

                get: function () {
                    return this._angle;
                }
            }
        },

        _buildMatrix: function () {

            if (this._xyz !== null && this._angle !== null) {

                // Both axis and angle have been set, so update the matrix.

                // Only do the update if both axis and angle have been set.

                // The update will be done once after both the axis and angle are set in the constructor,
                // and then subsequently every time that either the axis or angle is updated.
                //
                // This is wasteful for the case where both the axis and the angle are continually updated,
                // but that will be rarely be the case, where ormally it would just be the angle that is
                // continually updated.

                this.matrix = XEO.math.rotationMat4v(this._angle * XEO.math.DEGTORAD, this._xyz, this._matrix || (this._matrix = XEO.math.identityMat4()));
            }
        },

        _getJSON: function () {
            return {
                xyz: this._xyz,
                angle: this._angle
            };
        }
    });

})();
;/**

 A **Quaternion** applies a rotation transformation to associated {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>
 <li>Quaternion is a sub-class of {{#crossLink "Transform"}}{{/crossLink}}.</li>
 <li>Instances of Transform and its sub-classes may be connected into hierarchies.</li>
 <li>An {{#crossLink "Entity"}}{{/crossLink}} would be connected to a leaf Transform
 within a hierarchy, and would be transformed by each Transform on the path up to the root, in that order.</li>
 <li>See <a href="./Shader.html#inputs">Shader Inputs</a> for the variables that Transform create within xeoEngine's shaders.</li>
 </ul>

 <img src="../../../assets/images/Quaternion.png"></img>

 ## Example

 In this example we have two {{#crossLink "Entity"}}Entities{{/crossLink}} that are transformed by a hierarchy that contains
 Quaternion, {{#crossLink "Translate"}}{{/crossLink}} and {{#crossLink "Scale"}}{{/crossLink}} transforms.
 The Entities share the same {{#crossLink "Geometry"}}{{/crossLink}}, which is the default 2x2x2 cube.<br>

 ````javascript
 var scene = new XEO.Scene();

 var quaternion = new XEO.Quaternion(scene, {
    xyzw: [0, 0, 0, 1], // Unit quaternion
});

 var translate1 = new XEO.Translate(scene, {
   parent: quaternion,
   xyz: [-5, 0, 0] // Translate along -X axis
});

 var translate2 = new XEO.Translate(scene, {
   parent: quaternion,
   xyz: [5, 0, 0] // Translate along +X axis
});

 var scale = new XEO.Scale(scene, {
   parent: translate2,
   xyz: [1, 2, 1] // Scale x2 on Y axis
});

 var geometry = new XEO.Geometry(scene); // Defaults to a 2x2x2 box

 var Entity1 = new XEO.Entity(scene, {
   transform: translate1,
   geometry: geometry
});

 var Entity2 = new XEO.Entity(scene, {
   transform: scale,
   geometry: geometry
});
 ````

 Since everything in xeoEngine is dynamically editable, we can restructure the transform hierarchy at any time.

 Let's insert a {{#crossLink "Scale"}}{{/crossLink}} between the first Translate and the first {{#crossLink "Entity"}}{{/crossLink}}:

 ````javascript
 var scale2 = new XEO.Scale(scene, {
   parent: translate1,
   xyz: [1, 1, 2] // Scale x2 on Z axis
});

 Entity2.transform = scale2;
 ````

 And just for fun, we'll start spinning the Quaternion:

 ````javascript
 // Rotate 0.2 degrees about Y-axis on each frame
 scene.on("tick", function(e) {
    quaternion.rotate([0, 1, 0, 0.2]);
});
 ````
 @class Quaternion
 @module XEO
 @submodule transforms
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Quaternion in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Quaternion.
 @param [cfg.xyzw=[0,0,0,1]] {Array(Number)} The initial Quaternion elements.
 @extends Transform
 */
(function () {

    "use strict";
    XEO.Quaternion = XEO.Transform.extend({

        type: "XEO.Quaternion",

        _init: function (cfg) {
            this._super(cfg);
            this.xyzw = cfg.xyzw;
        },

        _props: {

            /**
             The quaternion elements
             Fires an {{#crossLink "Quaternion/xyzw:event"}}{{/crossLink}} event on change.
             @property xyzw
             @default [0,0,0,1]
             @type {Array of Number}
             */
            xyzw: {

                set: function (value) {
                    this._xyzw = value || [0, 0, 0, 1];
//                this.matrix = XEO.math.scalingMat4v(this._xyzw);

                    /**
                     Fired whenever this Quaternion's {{#crossLink "Quaternion/xyzw:property"}}{{/crossLink}} property changes.

                     @event xyzw
                     @param value {Array of Number} The property's new value
                     */
                    this.fire("xyzw", this._xyzw);
                },

                get: function () {
                    return this._xyz;
                }
            }
        },

        /**
         Rotates this Quaternion.
         Fires an {{#crossLink "Quaternion/xyzw:event"}}{{/crossLink}} event to notify of update to the Quaternion elements.
         @method rotate
         @param {Array of Number} angleAxis Rotation in angle-axis form.
         */
        rotate: function (angleAxis) {
            // TODO
        },

        _getJSON: function () {
            return {
                xyzw: this.xyzw
            };
        }
    });
})();;/**

 A **Scale** applies a scaling transformation to associated {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>
 <li>Scale is a sub-class of {{#crossLink "Transform"}}{{/crossLink}}</li>
 <li>Instances of Transform and its sub-classes may be connected into hierarchies.</li>
 <li>An {{#crossLink "Entity"}}{{/crossLink}} would be connected to a leaf Transform
 within a hierarchy, and would be transformed by each Transform on the path up to the root, in that order.</li>
 <li>See <a href="./Shader.html#inputs">Shader Inputs</a> for the variables that Transform create within xeoEngine's shaders.</li>
 </ul>

 <<img src="../../../assets/images/Scale.png"></img>

 ## Example

 In this example we have two {{#crossLink "Entity"}}Entities{{/crossLink}} that are transformed by a hierarchy that contains
 {{#crossLink "Rotate"}}{{/crossLink}}, {{#crossLink "Translate"}}{{/crossLink}} and Scale transforms.
 The Entities share the same {{#crossLink "Geometry"}}{{/crossLink}}, which is the default 2x2x2 cube.<br>

 ````javascript
 var scene = new XEO.Scene();

 var rotate = new XEO.Rotate(scene, {
    xyz: [0, 1, 0], // Rotate 30 degrees about Y axis
    angle: 30
});

 var translate1 = new XEO.Translate(scene, {
    parent: rotate,
    xyz: [-5, 0, 0] // Translate along -X axis
});

 var translate2 = new XEO.Translate(scene, {
    parent: rotate,
    xyz: [5, 0, 0] // Translate along +X axis
});

 var scale = new XEO.Scale(scene, {
    parent: translate2,
    xyz: [1, 2, 1] // Scale x2 on Y axis
});

 var geometry = new XEO.Geometry(scene); // Defaults to a 2x2x2 box

 var Entity1 = new XEO.Entity(scene, {
    transform: translate1,
    geometry: geometry
});

 var Entity2 = new XEO.Entity(scene, {
    transform: scale,
    geometry: geometry
});
 ````

 Since everything in xeoEngine is dynamically editable, we can restructure the transform hierarchy at any time.

 Let's insert a {{#crossLink "Scale"}}{{/crossLink}} between the first Translate and the first {{#crossLink "Entity"}}{{/crossLink}}:

 ````javascript

 var scale2 = new XEO.Scale(scene, {
    parent: translate1,
    xyz: [1, 1, 2] // Scale x2 on Z axis
});

 Entity2.transform = scale2;
 ````

 And just for fun, we'll start spinning the {{#crossLink "Rotate"}}{{/crossLink}}:

 ````javascript
 // Rotate 0.2 degrees on each frame
 scene.on("tick", function(e) {
    rotate.angle += 0.2;
});
 ````
 @class Scale
 @module XEO
 @submodule transforms
 @extends Transform
 */
(function () {

    "use strict";

    XEO.Scale = XEO.Transform.extend({

        type: "XEO.Scale",

        _init: function (cfg) {

            this._super(cfg);

            this.xyz = cfg.xyz;
        },

        _props: {

            /**
             * Vector indicating a scale factor for each axis.
             * Fires an {{#crossLink "Scale/xyz:event"}}{{/crossLink}} event on change.
             * @property xyz
             * @default [1,1,1]
             * @type {Array of Number}
             */
            xyz: {

                set: function (value) {

                    value = value || [1, 1, 1];

                    if (this._xyz) {
                        if (this._xyz[0] === value[0] && this._xyz[1] === value[1] && this._xyz[2] === value[2]) {
                            return;
                        } else {
                            this._xyz[0] = value[0];
                            this._xyz[1] = value[1];
                            this._xyz[2] = value[2];
                        }
                    } else {
                        this._xyz = value;
                    }

                    this.matrix = XEO.math.scalingMat4v(this._xyz, this._matrix || (this._matrix = XEO.math.identityMat4()));

                    /**
                     Fired whenever this Scale's {{#crossLink "Scale/xyz:property"}}{{/crossLink}} property changes.

                     @event xyz
                     @param value {Array of Number} The property's new value
                     */
                    this.fire("xyz", this._xyz);
                },

                get: function () {
                    return this._xyz;
                }
            }
        },

        _getJSON: function () {
            return {
                xyz: this.xyz
            };
        }
    });

})();
;/**

 A **Translate** translates associated {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 <ul>

 <li>Translate is a sub-class of {{#crossLink "Transform"}}{{/crossLink}}</li>
 <li>Instances of Transform and its sub-classes may be connected into hierarchies.</li>
 <li>An {{#crossLink "Entity"}}{{/crossLink}} would be connected to a leaf Transform
 within a hierarchy, and would be transformed by each Transform on the path up to the root, in that order.</li>
 <li>See <a href="./Shader.html#inputs">Shader Inputs</a> for the variables that Transform create within xeoEngine's shaders.</li>
 </ul>

 </ul>

 <img src="../../../assets/images/Translate.png"></img>

 ## Example

 This example has two {{#crossLink "Entity"}}Entities{{/crossLink}} that are transformed by a hierarchy that contains
 {{#crossLink "Rotate"}}{{/crossLink}}, Translate and {{#crossLink "Scale"}}{{/crossLink}} transforms.
 The Entities share the same {{#crossLink "Geometry"}}{{/crossLink}}, which is the default 2x2x2 cube.<br>

 ````javascript
 var scene = new XEO.Scene();

 var rotate = new XEO.Rotate(scene, {
    xyz: [0, 1, 0], // Rotate 30 degrees about Y axis
    angle: 30
});

 var translate1 = new XEO.Translate(scene, {
    parent: rotate,
    xyz: [-5, 0, 0] // Translate along -X axis
});

 var translate2 = new XEO.Translate(scene, {
    parent: rotate,
    xyz: [5, 0, 0] // Translate along +X axis
});

 var scale = new XEO.Scale(scene, {
    parent: translate2,
    xyz: [1, 2, 1] // Scale x2 on Y axis
});

 var geometry = new XEO.Geometry(scene); // Defaults to a 2x2x2 box

 var Entity1 = new XEO.Entity(scene, {
    transform: translate1,
    geometry: geometry
});

 var Entity2 = new XEO.Entity(scene, {
    transform: scale,
    geometry: geometry
});
 ````

 Since everything in xeoEngine is dynamically editable, we can restructure the transform hierarchy at any time.

 Let's insert a {{#crossLink "Scale"}}{{/crossLink}} between the first Translate and the first {{#crossLink "Entity"}}{{/crossLink}}:

 ````javascript
 var scale2 = new XEO.Scale(scene, {
    parent: translate1,
    xyz: [1, 1, 2] // Scale x2 on Z axis
});

 Entity2.transform = scale2;
 ````

 And just for fun, we'll start updating the second {{#crossLink "Translate"}}{{/crossLink}}:

 ````javascript
 // Rotate 0.2 degrees on each frame
 scene.on("tick", function(e) {
    var xyz = translate2.xyz;
    xyz[0] += 0.2;
    translate2.xyz = xyz;
});
 ````

 @class Translate
 @module XEO
 @submodule transforms
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Translate in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Translate.
 @param [cfg.xyzw=[0,0,0]] {Array(Number)} The translation vector
 @extends Transform
 */
(function () {

    "use strict";

    XEO.Translate = XEO.Transform.extend({

        type: "XEO.Translate",

        _init: function (cfg) {

            this._super(cfg);

            this.xyz = cfg.xyz;
        },

        _props: {

            /**
             * Vector indicating a translation amount for each axis.
             * Fires an {{#crossLink "Translate/xyz:event"}}{{/crossLink}} event on change.
             * @property xyz
             * @default [0,0,0]
             * @type {Array of Number}
             */
            xyz: {

                set: function (value) {

                    value = value || [0, 0, 0];

                    if (this._xyz) {
                        if (this._xyz[0] === value[0] && this._xyz[1] === value[1] && this._xyz[2] === value[2]) {
                            return;
                        } else {
                            this._xyz[0] = value[0];
                            this._xyz[1] = value[1];
                            this._xyz[2] = value[2];
                        }
                    } else {
                        this._xyz = value;
                    }

                    this.matrix = XEO.math.translationMat4v(this._xyz, this._matrix || (this._matrix = XEO.math.identityMat4()));

                    /**
                     Fired whenever this Translate's {{#crossLink "Translate/xyz:property"}}{{/crossLink}} property changes.
                     @event xyz
                     @param value {Array of Number} The property's new value
                     */
                    this.fire("xyz", this._xyz);
                },

                get: function () {
                    return this._xyz;
                }
            }
        },

        _getJSON: function () {
            return {
                xyz: this.xyz
            };
        }
    });

})();
;/**
 A **Billboard** causes associated {{#crossLink "Entity"}}Entities{{/crossLink}} to be always oriented towards the Camera.

 <ul>
 <li>**Spherical** billboards are free to rotate their {{#crossLink "Entity"}}Entities{{/crossLink}} in any direction and always face the {{#crossLink "Camera"}}{{/crossLink}} perfectly.</li>
 <li>**Cylindrical** billboards rotate their {{#crossLink "Entity"}}Entities{{/crossLink}} towards the {{#crossLink "Camera"}}{{/crossLink}}, but only around the Y-axis.</li>
 <li>A Billboard will cause {{#crossLink "Scale"}}{{/crossLink}} transformations to have no effect on its {{#crossLink "Entity"}}Entities{{/crossLink}}</li>
 </ul>
 <br>
 <img src="../../../assets/images/Billboard.png"></img>

 ### Example

 ```` javascript
 var geometry = new XEO.Geometry({
        primitive: "triangles",
        positions: [3, 3, 0, -3, 3, 0, -3, -3, 0, 3, -3, 0],
        normals: [-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0],
        uv: [1, 1, 0, 1, 0, 0, 1, 0],
        indices: [2, 1, 0, 3, 2, 0] // Ensure these will be front-faces
    });

 var material = new XEO.PhongMaterial({
        emissiveMap: new XEO.Texture({
            src: "textures/diffuse/teapot.jpg"
        })
    });

 var billboard = new XEO.Billboard({
        spherical: true
    });

 for (var i = 0; i < 1000; i++) {

        new XEO.Entity({
            geometry: geometry,
            material: material,
            billboard: billboard,
            transform: new XEO.Translate({
                xyz: [Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50]
            })
        });
  }

 var scene = XEO.scene;

 // Move the camera back a bit

 scene.camera.view.zoom(120);

 // Orbit the eye position about the look position.

 scene.on("tick",
 function () {

          var view = scene.camera.view;

          view.rotateEyeY(0.2);
          view.rotateEyeX(0.1);
     });
 ````

 @class Billboard
 @module XEO
 @submodule transforms
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Billboard in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Billboard.
 @param [cfg.active=true] {Boolean} Indicates if this Billboard is active or not.
 @param [cfg.spherical=true] {Boolean} Indicates if this Billboard is spherical (true) or cylindrical (false).
 @extends Component
 */
(function () {

    "use strict";

    XEO.Billboard = XEO.Component.extend({

        type: "XEO.Billboard",

        _init: function (cfg) {

            this._super(cfg);

            this._state = new XEO.renderer.Billboard({
                active: true,
                spherical: true,
                hash: "a;s;"
            });

            this.active = cfg.active !== false;
            this.spherical = cfg.spherical !== false;
        },

        _props: {

            /**
             * Flag which indicates whether this Billboard is active or not.
             *
             * Fires an {{#crossLink "Billboard/active:event"}}{{/crossLink}} event on change.
             *
             * @property active
             * @type Boolean
             */
            active: {

                set: function (value) {

                    value = !!value;

                    if (this._state.active === value) {
                        return;
                    }

                    this._state.active = value;

                    this._state.hash = (this._state.active ? "a;" : ";") + (this._state.spherical ? "s;" : ";");

                    this.fire("dirty", true);

                    /**
                     * Fired whenever this Billboard's {{#crossLink "Billboard/active:property"}}{{/crossLink}} property changes.
                     * @event active
                     * @param value The property's new value
                     */
                    this.fire('active', this._state.active);
                },

                get: function () {
                    return this._state.active;
                }
            },

            /**
             * Flag which indicates whether this Billboard is spherical (true) or cylindrical (false).
             *
             * Fires an {{#crossLink "Billboard/spherical:event"}}{{/crossLink}} event on change.
             *
             * @property spherical
             * @type Boolean
             */
            spherical: {

                set: function (value) {

                    value = !!value;

                    if (this._state.spherical === value) {
                        return;
                    }

                    this._state.spherical = value;

                    this._state.hash = (this._state.active ? "a;" : ";") + (this._state.spherical ? "s;" : ";");

                    this.fire("dirty", true);

                    /**
                     * Fired whenever this Billboard's {{#crossLink "Billboard/spherical:property"}}{{/crossLink}} property changes.
                     * @event spherical
                     * @param value The property's new value
                     */
                    this.fire('spherical', this._state.spherical);
                },

                get: function () {
                    return this._state.spherical;
                }
            }
        },

        _compile: function () {
            this._renderer.billboard = this._state;
        },


        _getJSON: function () {
            return {
                active: this._state.active
            };
        }
    });

})();
;/**

 A **Stationary** disables the effect of {{#crossLink "Lookat"}}view transform{{/crossLink}} translations for
 associated {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 TODO

 <img src="../../../assets/images/Stationary.png"></img>

 ## Example

 TODO

 @class Stationary
 @module XEO
 @submodule transforms
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Stationary in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Stationary.
 @param [cfg.active=true] {Boolean} Indicates if this Stationary is active or not.
 @extends Component
 */
(function () {

    "use strict";

    XEO.Stationary = XEO.Component.extend({

        type: "XEO.Stationary",

        _init: function (cfg) {

            this._super(cfg);

            this._state = new XEO.renderer.Stationary({
                active: true
            });

            this.active = cfg.active !== false;
        },

        _props: {

            /**
             * Flag which indicates whether this Stationary is active or not.
             *
             * Fires an {{#crossLink "Stationary/active:event"}}{{/crossLink}} event on change.
             *
             * @property active
             * @type Boolean
             */
            active: {

                set: function (value) {

                    value = !!value;

                    if (this._state.active === value) {
                        return;
                    }

                    this._state.active = value;

                    this._state.hash = (this._state.active ? "a;" : ";");

                    this.fire("dirty", true);

                    /**
                     * Fired whenever this Stationary's {{#crossLink "Stationary/active:property"}}{{/crossLink}} property changes.
                     * @event active
                     * @param value The property's new value
                     */
                    this.fire('active', this._state.active);
                },

                get: function () {
                    return this._state.active;
                }
            }
        },

        _compile: function () {
            this._renderer.stationary = this._state;
        },


        _getJSON: function () {
            return {
                active: this._state.active
            };
        }
    });

})();
XEO.version="0.1.0";